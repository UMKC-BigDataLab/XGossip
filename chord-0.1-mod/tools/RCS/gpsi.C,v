head	1.131;
access;
symbols;
locks; strict;
comment	@ * @;


1.131
date	2013.01.27.00.48.15;	author vsfgd;	state Exp;
branches;
next	1.130;

1.130
date	2012.12.20.19.08.36;	author vsfgd;	state Exp;
branches;
next	1.129;

1.129
date	2012.12.20.18.47.54;	author vsfgd;	state Exp;
branches;
next	1.128;

1.128
date	2012.12.19.21.55.14;	author vsfgd;	state Exp;
branches;
next	1.127;

1.127
date	2012.11.28.17.05.04;	author vsfgd;	state Exp;
branches;
next	1.126;

1.126
date	2012.11.28.06.37.20;	author vsfgd;	state Exp;
branches;
next	1.125;

1.125
date	2012.10.25.22.11.57;	author vsfgd;	state Exp;
branches;
next	1.124;

1.124
date	2012.10.25.20.24.11;	author vsfgd;	state Exp;
branches;
next	1.123;

1.123
date	2012.10.25.17.18.04;	author vsfgd;	state Exp;
branches;
next	1.122;

1.122
date	2012.07.11.13.53.13;	author vsfgd;	state Exp;
branches;
next	1.121;

1.121
date	2012.05.10.03.03.14;	author vsfgd;	state Exp;
branches;
next	1.120;

1.120
date	2012.05.10.00.11.39;	author vsfgd;	state Exp;
branches;
next	1.119;

1.119
date	2012.05.09.22.55.43;	author vsfgd;	state Exp;
branches;
next	1.118;

1.118
date	2012.04.30.21.45.45;	author vsfgd;	state Exp;
branches;
next	1.117;

1.117
date	2012.04.23.16.24.08;	author vsfgd;	state Exp;
branches;
next	1.116;

1.116
date	2012.04.20.16.49.58;	author vsfgd;	state Exp;
branches;
next	1.115;

1.115
date	2012.04.02.05.39.11;	author vsfgd;	state Exp;
branches;
next	1.114;

1.114
date	2012.03.29.23.16.11;	author vsfgd;	state Exp;
branches;
next	1.113;

1.113
date	2012.03.29.16.26.16;	author vsfgd;	state Exp;
branches;
next	1.112;

1.112
date	2012.03.27.15.54.10;	author vsfgd;	state Exp;
branches;
next	1.111;

1.111
date	2012.03.15.16.51.23;	author vsfgd;	state Exp;
branches;
next	1.110;

1.110
date	2012.03.08.17.19.46;	author vsfgd;	state Exp;
branches;
next	1.109;

1.109
date	2012.02.17.20.01.18;	author vsfgd;	state Exp;
branches;
next	1.108;

1.108
date	2012.02.06.19.43.20;	author vsfgd;	state Exp;
branches;
next	1.107;

1.107
date	2012.02.03.18.39.13;	author vsfgd;	state Exp;
branches;
next	1.106;

1.106
date	2012.02.02.16.15.34;	author vsfgd;	state Exp;
branches;
next	1.105;

1.105
date	2012.01.24.18.41.09;	author vsfgd;	state Exp;
branches;
next	1.104;

1.104
date	2012.01.23.16.43.05;	author vsfgd;	state Exp;
branches;
next	1.103;

1.103
date	2012.01.17.21.12.07;	author vsfgd;	state Exp;
branches;
next	1.102;

1.102
date	2012.01.17.18.58.45;	author vsfgd;	state Exp;
branches;
next	1.101;

1.101
date	2011.11.25.21.23.35;	author vsfgd;	state Exp;
branches;
next	1.100;

1.100
date	2011.11.23.20.37.16;	author vsfgd;	state Exp;
branches;
next	1.99;

1.99
date	2011.10.02.15.33.41;	author vsfgd;	state Exp;
branches;
next	1.98;

1.98
date	2011.09.23.17.05.24;	author vsfgd;	state Exp;
branches;
next	1.97;

1.97
date	2011.09.22.14.08.20;	author vsfgd;	state Exp;
branches;
next	1.96;

1.96
date	2011.09.21.18.36.39;	author vsfgd;	state Exp;
branches;
next	1.95;

1.95
date	2011.09.20.17.41.12;	author vsfgd;	state Exp;
branches;
next	1.94;

1.94
date	2011.09.19.18.15.42;	author vsfgd;	state Exp;
branches;
next	1.93;

1.93
date	2011.09.15.16.16.54;	author vsfgd;	state Exp;
branches;
next	1.92;

1.92
date	2011.09.14.19.31.32;	author vsfgd;	state Exp;
branches;
next	1.91;

1.91
date	2011.09.14.14.42.20;	author vsfgd;	state Exp;
branches;
next	1.90;

1.90
date	2011.09.13.19.50.44;	author vsfgd;	state Exp;
branches;
next	1.89;

1.89
date	2011.09.13.16.20.55;	author vsfgd;	state Exp;
branches;
next	1.88;

1.88
date	2011.09.12.18.26.06;	author vsfgd;	state Exp;
branches;
next	1.87;

1.87
date	2011.09.10.21.36.43;	author vsfgd;	state Exp;
branches;
next	1.86;

1.86
date	2011.09.08.20.52.29;	author vsfgd;	state Exp;
branches;
next	1.85;

1.85
date	2011.09.08.17.30.26;	author vsfgd;	state Exp;
branches;
next	1.84;

1.84
date	2011.09.07.17.14.52;	author vsfgd;	state Exp;
branches;
next	1.83;

1.83
date	2011.09.06.00.51.55;	author vsfgd;	state Exp;
branches;
next	1.82;

1.82
date	2011.09.05.06.58.12;	author vsfgd;	state Exp;
branches;
next	1.81;

1.81
date	2011.09.05.06.56.42;	author vsfgd;	state Exp;
branches;
next	1.80;

1.80
date	2011.09.03.22.02.51;	author vsfgd;	state Exp;
branches;
next	1.79;

1.79
date	2011.06.08.05.35.00;	author vsfgd;	state Exp;
branches;
next	1.78;

1.78
date	2011.06.08.02.12.29;	author vsfgd;	state Exp;
branches;
next	1.77;

1.77
date	2011.06.07.06.06.07;	author vsfgd;	state Exp;
branches;
next	1.76;

1.76
date	2011.06.01.14.36.43;	author vsfgd;	state Exp;
branches;
next	1.75;

1.75
date	2011.05.25.02.52.00;	author vsfgd;	state Exp;
branches;
next	1.74;

1.74
date	2011.05.23.06.55.29;	author vsfgd;	state Exp;
branches;
next	1.73;

1.73
date	2011.04.27.14.48.43;	author vsfgd;	state Exp;
branches;
next	1.72;

1.72
date	2011.03.26.21.09.11;	author vsfgd;	state Exp;
branches;
next	1.71;

1.71
date	2011.03.25.17.14.12;	author vsfgd;	state Exp;
branches;
next	1.70;

1.70
date	2011.03.25.15.49.30;	author vsfgd;	state Exp;
branches;
next	1.69;

1.69
date	2011.03.24.20.52.00;	author vsfgd;	state Exp;
branches;
next	1.68;

1.68
date	2011.03.23.01.08.43;	author vsfgd;	state Exp;
branches;
next	1.67;

1.67
date	2011.03.22.22.27.30;	author vsfgd;	state Exp;
branches;
next	1.66;

1.66
date	2010.12.11.01.42.38;	author vsfgd;	state Exp;
branches;
next	1.65;

1.65
date	2010.11.27.17.58.10;	author vsfgd;	state Exp;
branches;
next	1.64;

1.64
date	2010.11.24.17.11.25;	author vsfgd;	state Exp;
branches;
next	1.63;

1.63
date	2010.11.12.19.59.16;	author vsfgd;	state Exp;
branches;
next	1.62;

1.62
date	2010.10.18.04.43.52;	author vsfgd;	state Exp;
branches;
next	1.61;

1.61
date	2010.10.11.16.05.32;	author vsfgd;	state Exp;
branches;
next	1.60;

1.60
date	2010.09.21.05.09.20;	author vsfgd;	state Exp;
branches;
next	1.59;

1.59
date	2010.09.19.23.54.15;	author vsfgd;	state Exp;
branches;
next	1.58;

1.58
date	2010.09.18.21.43.56;	author vsfgd;	state Exp;
branches;
next	1.57;

1.57
date	2010.09.17.01.54.01;	author vsfgd;	state Exp;
branches;
next	1.56;

1.56
date	2010.09.15.00.35.20;	author vsfgd;	state Exp;
branches;
next	1.55;

1.55
date	2010.07.19.14.29.14;	author vsfgd;	state Exp;
branches;
next	1.54;

1.54
date	2010.07.16.17.50.15;	author vsfgd;	state Exp;
branches;
next	1.53;

1.53
date	2010.07.15.06.37.58;	author vsfgd;	state Exp;
branches;
next	1.52;

1.52
date	2010.07.15.02.19.17;	author vsfgd;	state Exp;
branches;
next	1.51;

1.51
date	2010.07.14.20.48.40;	author vsfgd;	state Exp;
branches;
next	1.50;

1.50
date	2010.07.08.23.29.58;	author vsfgd;	state Exp;
branches;
next	1.49;

1.49
date	2010.07.07.17.57.54;	author vsfgd;	state Exp;
branches;
next	1.48;

1.48
date	2010.07.07.16.45.03;	author vsfgd;	state Exp;
branches;
next	1.47;

1.47
date	2010.07.06.03.25.21;	author vsfgd;	state Exp;
branches;
next	1.46;

1.46
date	2010.07.05.00.40.38;	author vsfgd;	state Exp;
branches;
next	1.45;

1.45
date	2010.07.03.21.11.21;	author vsfgd;	state Exp;
branches;
next	1.44;

1.44
date	2010.07.02.03.51.11;	author vsfgd;	state Exp;
branches;
next	1.43;

1.43
date	2010.06.29.01.59.35;	author vsfgd;	state Exp;
branches;
next	1.42;

1.42
date	2010.06.24.13.34.06;	author vsfgd;	state Exp;
branches;
next	1.41;

1.41
date	2010.06.24.03.38.55;	author vsfgd;	state Exp;
branches;
next	1.40;

1.40
date	2010.06.12.23.36.35;	author vsfgd;	state Exp;
branches;
next	1.39;

1.39
date	2010.06.09.02.23.55;	author vsfgd;	state Exp;
branches;
next	1.38;

1.38
date	2010.06.07.01.51.21;	author vsfgd;	state Exp;
branches;
next	1.37;

1.37
date	2010.06.07.01.35.09;	author vsfgd;	state Exp;
branches;
next	1.36;

1.36
date	2010.05.03.00.40.32;	author vsfgd;	state Exp;
branches;
next	1.35;

1.35
date	2010.04.04.15.06.20;	author vsfgd;	state Exp;
branches;
next	1.34;

1.34
date	2010.03.28.16.29.26;	author vsfgd;	state Exp;
branches;
next	1.33;

1.33
date	2010.03.25.14.06.50;	author vsfgd;	state Exp;
branches;
next	1.32;

1.32
date	2010.03.18.05.58.32;	author vsfgd;	state Exp;
branches;
next	1.31;

1.31
date	2010.03.17.00.18.53;	author vsfgd;	state Exp;
branches;
next	1.30;

1.30
date	2010.03.08.22.10.57;	author vsfgd;	state Exp;
branches;
next	1.29;

1.29
date	2010.03.02.17.11.38;	author vsfgd;	state Exp;
branches;
next	1.28;

1.28
date	2010.02.23.22.35.32;	author vsfgd;	state Exp;
branches;
next	1.27;

1.27
date	2010.02.21.00.32.05;	author vsfgd;	state Exp;
branches;
next	1.26;

1.26
date	2010.02.18.04.35.59;	author vsfgd;	state Exp;
branches;
next	1.25;

1.25
date	2010.01.30.23.12.03;	author vsfgd;	state Exp;
branches;
next	1.24;

1.24
date	2010.01.30.20.25.39;	author vsfgd;	state Exp;
branches;
next	1.23;

1.23
date	2010.01.20.00.41.03;	author vsfgd;	state Exp;
branches;
next	1.22;

1.22
date	2010.01.12.23.06.36;	author vsfgd;	state Exp;
branches;
next	1.21;

1.21
date	2010.01.11.17.32.05;	author vsfgd;	state Exp;
branches;
next	1.20;

1.20
date	2009.12.30.22.26.00;	author vsfgd;	state Exp;
branches;
next	1.19;

1.19
date	2009.12.28.23.48.25;	author vsfgd;	state Exp;
branches;
next	1.18;

1.18
date	2009.12.28.23.42.59;	author vsfgd;	state Exp;
branches;
next	1.17;

1.17
date	2009.12.21.16.25.47;	author vsfgd;	state Exp;
branches;
next	1.16;

1.16
date	2009.12.18.15.16.46;	author vsfgd;	state Exp;
branches;
next	1.15;

1.15
date	2009.12.02.16.40.11;	author vsfgd;	state Exp;
branches;
next	1.14;

1.14
date	2009.12.02.03.32.32;	author vsfgd;	state Exp;
branches;
next	1.13;

1.13
date	2009.12.01.04.26.16;	author vsfgd;	state Exp;
branches;
next	1.12;

1.12
date	2009.12.01.02.04.11;	author vsfgd;	state Exp;
branches;
next	1.11;

1.11
date	2009.11.30.20.04.01;	author vsfgd;	state Exp;
branches;
next	1.10;

1.10
date	2009.11.22.19.56.27;	author vsfgd;	state Exp;
branches;
next	1.9;

1.9
date	2009.11.22.15.58.59;	author vsfgd;	state Exp;
branches;
next	1.8;

1.8
date	2009.11.18.21.31.56;	author vsfgd;	state Exp;
branches;
next	1.7;

1.7
date	2009.11.18.19.55.21;	author vsfgd;	state Exp;
branches;
next	1.6;

1.6
date	2009.10.07.04.23.42;	author vsfgd;	state Exp;
branches;
next	1.5;

1.5
date	2009.10.07.04.19.53;	author vsfgd;	state Exp;
branches;
next	1.4;

1.4
date	2009.08.19.04.52.35;	author vsfgd;	state Exp;
branches;
next	1.3;

1.3
date	2009.08.10.06.30.57;	author vsfgd;	state Exp;
branches;
next	1.2;

1.2
date	2009.08.07.18.27.56;	author vsfgd;	state Exp;
branches;
next	1.1;

1.1
date	2009.08.04.03.11.55;	author vsfgd;	state Exp;
branches;
next	;


desc
@copy of push_sum + some signature stuff
@


1.131
log
@added printing of loaded results files
@
text
@/*	$Id: gpsi.C,v 1.130 2012/12/20 19:08:36 vsfgd Exp vsfgd $	*/

#include <algorithm>
#include <cmath>
#include <cstdio>
#include <ctime>
#include <iostream>
#include <map>
#include <fstream>
#include <sstream>
#include <string>
#include <typeinfo>
#include <vector>
#include <float.h>
#include <math.h>

#include <dirent.h>
#include <libgen.h>
#include <sys/stat.h>
#include <sys/types.h>

#include <chord.h>
#include <dhash_common.h>
#include <dhashclient.h>
#include <dhblock.h>

#include "../utils/id_utils.h"
#include "../utils/utils.h"
#include "nodeparams.h"
#include "gpsi.h"

//#define _DEBUG_
#define _ELIMINATE_DUP_

static char rcsid[] = "$Id: gpsi.C,v 1.130 2012/12/20 19:08:36 vsfgd Exp vsfgd $";
extern char *__progname;

dhashclient *dhash;
int out;
int groupsleep;
int waitsleep;
int initsleep;
int gossipsleep;
int openfd = 0;
int closefd = 0;

chordID maxID;
chordID thisID;
static const char *dsock;
static const char *gsock;
static char *hashfile;
static char *killfile;
static char *idsfile;
static char *irrpolyfile;
static char *initfile;
static char *logfile;
static char *rootdir = "empty";
int myhostnum = -1;
std::vector<chordID> allIDs;
std::vector<POLY> irrnums;
std::vector<int> hasha;
std::vector<int> hashb;
std::vector<POLY> gproxysig;
double proxyminsim = 0;
double proxyavgsim = 0;
int lshseed = 0;
int plist = 0;
int gflag = 0;
int Qflag = 0;
int uflag = 0;
// by default, don't discard out of round msgs
int discardmsg = 0;
int compress = 0;
int peers = 0;
int teamsize = 5;
// TODO: make cmd line arg
int ninstances = 1;
double errorlimit = 100;
int freqbyx = 1;
int totalrxmsglen = 0;
int totaltxmsglen = 0;
int roundrxmsglen = 0;
int roundtxmsglen = 0;
bool initphase = false;
bool bcast = false;
bool vanilla = false;
bool gossipdone = false;
bool churn = false;
bool killme = false;

// paper:k, slides:bands
int mgroups = 10;
// paper:l, slides:rows
int lfuncs = 16;

// sig, id
typedef std::multimap<std::vector<POLY>, int, CompareSig> sig2idmulti;
sig2idmulti queryMap;

// sig, ids
//typedef std::map<std::vector<POLY>, std::vector<int>, CompareSig> sig2ids;
//sig2ids querysig2qids;
//sig2ids sig2qids;

// id, sigs
typedef std::map<int, std::vector<std::vector<POLY> > > id2sigs;
id2sigs qid2querysig;
id2sigs qid2sigs;

// id, chordIDs
typedef std::map<int, std::vector<chordID> > id2chordIDs;
id2chordIDs qid2teamIDs;

// id, string
typedef std::map<int, std::vector<std::string> > id2strings;
id2strings qid2dtd;

// strings, sig
typedef std::map<std::string, std::vector<std::vector<POLY> > > string2sigs;
string2sigs dtd2sigs;
string2sigs dtd2proxysigs;

// sig, (<freq,weight> | <avg,avg,...>)
typedef std::map<std::vector<POLY>, std::vector<double>, CompareSig> mapType;
// sig, (<freq,weight> | <avg,avg,...>)
typedef std::map<std::vector<POLY>, std::vector<long double>, CompareSig> lmapType;

typedef std::vector<mapType> vecomap;
typedef std::vector<lmapType> lvecomap;
// use only for storing the sigs after reading them from files:
// - during init phases
// - when querying
// store in:
// [0]: regular sigs
// [1]: proxy sigs
vecomap allT;
lvecomap lallT;

// list of sig2avg results
vecomap allsig2avg;

// map id of sig2avg to qid
typedef std::map<int, int> id2id;
id2id qid2id;

// vector of vector of maps for each team
// init phase uses 1st vecomap only
typedef std::vector<vecomap> totalvecomap;
totalvecomap totalT;

// map teamID to team's list index in totalT
// (store index in [0], use more only for Mflag with multiple init files)
typedef std::map<chordID, std::vector<int> > teamid2totalT;
teamid2totalT teamindex;

typedef std::map<chordID, int> teamidfreq;
teamidfreq teamidminhash;

// map chordIDs/POLYs to sig indices
typedef std::map<chordID, std::vector<int> > chordID2sig;
typedef std::map<POLY, std::vector<int> > poly2sig;

void acceptconn(int);
void addqid(int, std::vector<POLY>);
bool addteamID(int, chordID);
void add2querymap(std::vector<std::vector<POLY> >, std::vector<std::string>);
// XGossip
void add2vecomapx(std::vector<std::vector <POLY> >, std::vector<double>, std::vector<double>, chordID);
// VanillaXGossip
void add2vecomapv(std::vector<std::vector <POLY> >, std::vector<double>, std::vector<double>);
int getdir(std::string, std::vector<std::string>&);
void calcfreq(std::vector<std::vector <POLY> >, bool, bool);
void lcalcfreq(std::vector<std::vector <POLY> >, bool, bool);
void calcfreqM(std::vector<std::vector <POLY> >, std::vector<double>, std::vector<double>);
void calcteamids(std::vector <chordID>);
void delspecial(int);
void dividefreq(vecomap&, int, int, int);
void doublefreqgroup(int, mapType);
chordID findteamid(int);
bool fixnan(double, double);
void informteam(chordID, chordID, std::vector<POLY>);
void initgossiprecv(chordID, chordID, std::vector<POLY>, double, double);
DHTStatus insertDHT(chordID, char *, int, double &, int = MAXRETRIES, chordID = 0);
std::string itostring(int);
void retrieveDHT(chordID ID, int, str&, chordID guess = 0);
std::vector<POLY> inverse(std::vector<POLY>);
void listengossip(void);
//void *listengossip(void *);
void loginitstate(FILE *);
int loadinitstate(FILE *);
int loadresults(FILE *, InsertType &);
int lshsig(vecomap, int, InsertType, int, int);
int lshquery(sig2idmulti, int, InsertType, int);
int vanillaquery(sig2idmulti, int, InsertType, int);
int make_team(chordID, chordID, std::vector<chordID> &);
void mergelists(vecomap &);
void mergelists_nogossip(vecomap &);
void mergeinit();
void mergebyteamid();
void multiplyfreq(vecomap&, int, int, int);
char *netstring_decode(FILE *);
void netstring_encode(const char *, FILE *);
void printdouble(std::string, double);
void lprintdouble(std::string, long double);
int printlist(vecomap, int, int, bool hdr = true);
int lprintlist(lvecomap, int, int, bool hdr = true);
int printlistall(int seq = -1);
int lprintlistall(int seq = -1);
void printteamids();
void printteamidfreq();
chordID randomID(void);
void readgossip(int);
void readquery(std::string, std::vector<std::vector <POLY> > &, std::vector<std::string> &);
void readsig(std::string, std::vector<std::vector <POLY> > &, bool);
void readValues(FILE *, std::multimap<POLY, std::pair<std::string, enum OPTYPE> > &);
std::vector<chordID> run_lsh(std::vector<POLY>);
int run_query(int, std::vector<POLY>, int &, double &, double &, double &, InsertType, chordID = 0, bool = false);
bool sig2str(std::vector<POLY>, str &);
bool string2sig(std::string, std::vector<POLY> &);
bool sigcmp(std::vector<POLY>, std::vector<POLY>);
bool samesig(std::vector<POLY>, std::vector<POLY>);
int set_inter(std::vector<POLY>, std::vector<POLY>, bool &);
int set_inter(std::vector<chordID>, std::vector<chordID>, bool &);
int set_inter_noskip(std::vector<POLY>, std::vector<POLY>, bool &);
int set_uni(std::vector<POLY>, std::vector<POLY>, bool &);
double signcmp(std::vector<POLY>, std::vector<POLY>, bool &);
void tokenize(const std::string &, std::vector<std::string> &, const std::string &);
void usage(void);
bool validsig(std::vector<POLY>);
void vecomap2vec(vecomap, int, std::vector<std::vector <POLY> > &, std::vector<double> &, std::vector<double> &);
void lvecomap2vec(lvecomap, int, std::vector<std::vector <POLY> > &, std::vector<long double> &, std::vector<long double> &);

DHTStatus insertStatus;
std::string INDEXNAME;

// entries of a node
vec<str> nodeEntries;

bool insertError;
bool retrieveError;

//std::vector<std::map<std::vector<POLY>, std::vector<double>, CompareSig> > allT;
//std::map<std::vector<POLY>, std::vector<double>, CompareSig> uniqueSigList;
//std::map<std::vector<POLY>, double, CompareSig> uniqueSigList;
//std::map<std::vector<POLY>, double, CompareSig> uniqueWeightList;

//std::vector<int> rxmsglen;
std::vector<int> rxqseq;
std::vector<int> rxseq;
std::vector<int> txseq;

std::vector<POLY> dummysig;

// hash table statistics
int numReads;
int numWrites;
int numDocs;
int cacheHits;

// pSim
bool metric = 1;

// data transfered
int dataFetched = 0, dataStored = 0;

dhash_stat retrieveStatus;

chordID myGuess;

// retrieve TIMEOUT
const int RTIMEOUT = 20;

void
groupsleepnow()
{
	warnx << "group sleep interval is up\n";
	++groupsleep;
}

void
waitsleepnow()
{
	warnx << "wait sleep interval is up\n";
	++waitsleep;
}

void
initsleepnow()
{
	warnx << "init sleep interval is up\n";
	++initsleep;
}

void
gossipsleepnow()
{
	warnx << "gossip sleep interval is up\n";
	++gossipsleep;
}

// copied from psi.C
// Fetch callback for NOAUTH...
void
fetch_cb(dhash_stat stat, ptr<dhash_block> blk, vec<chordID> path)
{
	retrieveStatus = DHASH_OK;
   	myGuess = 0;
 
	if (stat != DHASH_OK) {
		//warnx << "Failed to fetch key...\n";
		if (stat == DHASH_DBERR) {
			warnx << "PANIC time...\n";
        	}
		retrieveStatus = stat;
		retrieveError = true;
    		out++;
        	return;
	}

	if (blk) {
		strbuf buf;
		
#ifdef _DEBUG_
		buf << " /times=";
		for (u_int i = 0; i < blk->times.size (); i++)
			buf << " " << blk->times[i];
		buf << " /";
		
		buf << "hops= " << blk->hops << " errors= " <<  blk->errors
		    << "vretries= " << blk->retries << " ";
		///////////////////
		buf << " path: ";
		for (u_int i=0; i < path.size (); i++) {
			buf << path[i] << " ";
		}
		
		buf << " \n";
		warnx << buf;
#endif

		myGuess = path.size() > 0 ? path[path.size() - 1] : 0;

		if (blk->vData.size () > 0) {
			//warn << blk->vData.size () << "\n";

			for (unsigned int i = 0; i < blk->vData.size (); i++) {
				nodeEntries.push_back(blk->vData[i]);
				dataFetched += nodeEntries[i].len();
			}
		} else {
		    nodeEntries.push_back(blk->data);
		}
		
		// Output hops
		warnx << "HOPS: " << blk->hops << "\n";
		numReads++;
		
#ifdef _DEBUG_ 
		warnx << "Retrieve information: " << buf << "\n";
#endif
	}
	out++;
}

// copied from psi.C
void
store_cb(dhash_stat status, ptr<insert_info> i)
{
	if (status == DHASH_NOTFIRST) {
		insertStatus = NOTFIRST;
	} else if (status == DHASH_FULL) {
		insertStatus = FULL;
	} else if (status == DHASH_RETRYINSERT) {
		insertStatus = RETRY;
	} else if (status == DHASH_CORRUPTHDR) {
		insertStatus = CORRUPTHDR;
		// Trying again
		//insertError = true;
	} else if (status != DHASH_OK) {
		warnx << "failed to store key...\n";
		insertError = true;
	} else {
		numWrites++;
		warnx << "key stored successfully...\n";
	}
	out++;
}

// TODO: why?
// error: no match for ‘operator=’ in ‘minhash = lsh::getHashCodeFindMod
// error: no match for ‘operator=’ in ‘minhash = lsh::getHashCode
template <class T>
int lshall(int listnum, std::vector<std::vector<T> > &matrix, unsigned int loseed, InsertType msgtype = 0)
{
	std::vector<T> minhash;
	std::vector<POLY> sig;
	std::vector<POLY> lshsig;
	str sigbuf;
	chordID ID;
	//DHTStatus status;
	//char *value;
	//int col, valLen;
	double freq, weight;

	sig.clear();
	lshsig.clear();
	for (mapType::iterator itr = allT[listnum].begin(); itr != allT[listnum].end(); itr++) {
		sig = itr->first;
		freq = itr->second[0];
		weight = itr->second[1];

		lsh *myLSH = new lsh(sig.size(), lfuncs, mgroups, lshseed, 0, irrnums, hasha, hashb);
		// convert multiset to set
		if (uflag == 1) {
			sig2str(sig, sigbuf);
			warnx << "multiset: " << sigbuf << "\n";
			lshsig = myLSH->getUniqueSet(sig);
			sig2str(lshsig, sigbuf);
			warnx << "set: " << sigbuf << "\n";
		}

		// XXX
		std::vector<POLY> polyhash;
		std::vector<chordID> idhash;
		warnx << "typeid: " << typeid(minhash).name() << "\n";
		// TODO: getHashCode on sig or lshsig
		if (typeid(minhash) == typeid(polyhash)) {
			polyhash = myLSH->getHashCodeFindMod(lshsig, myLSH->getIRRPoly());
		} else if (typeid(minhash) == typeid(idhash)) {
			idhash = myLSH->getHashCode(lshsig);
		} else {
			warnx << "invalid type\n";
			return -1;
		}

		/*
		//warnx << "minhash.size(): " << minhash.size() << "\n";
		if (plist == 1) {
			warnx << "minhash IDs:\n";
			for (int i = 0; i < (int)minhash.size(); i++) {
				warnx << minhash[i] << "\n";
			}
		}

		matrix.push_back(minhash);
		//srand(time(NULL));
		srand(loseed);
		int range = (int)minhash.size();
		col = int((double)range * rand() / (RAND_MAX + 1.0));
		ID = (matrix.back())[col];
		warnx << "ID in col " << col << ": " << ID << "\n";

		if (gflag == 1 && msgtype != 0) {
			strbuf t;
			t << ID;
			str key(t);
			warnx << "inserting INITGOSSIP:\n";
			makeKeyValue(&value, valLen, key, sig, freq, weight, msgtype);
			status = insertDHT(ID, value, valLen, MAXRETRIES);
			cleanup(value);

			// do not exit if insert FAILs!
			if (status != SUCC) {
				warnx << "error: insert FAILed\n";
			} else {
				warnx << "insert SUCCeeded\n";
			}

			// TODO: how long (if at all)?
			warnx << "sleeping...\n";
			sleep(intval);
		}
		*/
		delete myLSH;
	}
	return 0;
}

int
lshquery(sig2idmulti queryMap, int intval = -1, InsertType msgtype = INVALID, int col = 0)
{
	std::vector<std::vector<chordID> > matrix;
	std::vector<chordID> minhash;
	std::vector<chordID> buckets;
	std::vector<POLY> querysig;
	std::vector<POLY> lshquerysig;
	std::vector<POLY> regularsig;
	std::vector<POLY> lshregularsig;
	std::string dtd;
	lsh *myLSH = NULL;
	chordID ID;
	DHTStatus status;
	std::vector<chordID> team;
	chordID teamID;
	char *value;
	int valLen, n, range, randcol, qid;
	double beginTime, endTime, instime, totalinstime;
	str sigbuf;

	matrix.clear();
	minhash.clear();
	querysig.clear();
	lshquerysig.clear();
	regularsig.clear();
	lshregularsig.clear();
	n = 0;
	totalinstime = 0;
	for (sig2idmulti::iterator itr = queryMap.begin(); itr != queryMap.end(); itr++) {
		querysig = itr->first;
		qid = itr->second;
		id2strings::iterator ditr = qid2dtd.find(qid);
		if (ditr != qid2dtd.end()) {
			// TODO: assume 1 dtd per qid
			dtd = ditr->second.back();
		} else {
			warnx << "lshquery: no DTD found for qid: " << qid << "\n";
		}

		// use querysig or regularsig to generate teamIDs
		if (msgtype == QUERYX || msgtype == QUERYS) {
			sig2str(querysig, sigbuf);
			warnx << "running LSH on querysig: " << sigbuf << "\n";
			beginTime = getgtod();    
			myLSH = new lsh(querysig.size(), lfuncs, mgroups, lshseed, col, irrnums, hasha, hashb);
			endTime = getgtod();    
			printdouble("lshquery: lsh time: ", endTime - beginTime);
			warnx << "\n";

			// convert multiset to set
			if (uflag == 1) {
				//sig2str(querysig, sigbuf);
				//warnx << "multiset: " << sigbuf << "\n";
				lshquerysig = myLSH->getUniqueSet(querysig);
				//sig2str(lshquerysig, sigbuf);
				//warnx << "set: " << sigbuf << "\n";
				minhash = myLSH->getHashCode(lshquerysig);
			} else {
				minhash = myLSH->getHashCode(querysig);
			}

			sort(minhash.begin(), minhash.end());

			/*
			team.clear();
			for (int i = 0; i < (int)minhash.size(); i++) {
				teamID = minhash[i];
				warnx << "teamID: " << teamID << "\n";
				// TODO: check return status
				make_team(NULL, teamID, team);
				range = team.size();
				// randomness verified
				//randcol = randomNumGenZ(range-1);
				randcol = randomNumGenZ(range);
				ID = team[randcol];
				warnx << "ID in randcol " << randcol << ": " << ID << "\n";
			}
			*/
		// use proxy sig to generate teamIDs
		} else if (msgtype == QUERYXP) {
			string2sigs::iterator sitr = dtd2proxysigs.find(dtd);
			if (sitr != dtd2proxysigs.end()) {
				// TODO: assume 1 sig per DTD
				regularsig = sitr->second.back();
			} else {
				warnx << "lshquery: no proxy sig found for DTD: " << dtd.c_str() << "\n";
			}

			sig2str(regularsig, sigbuf);
			warnx << "running LSH on regularsig: " << sigbuf << "\n";
			beginTime = getgtod();    
			myLSH = new lsh(regularsig.size(), lfuncs, mgroups, lshseed, col, irrnums, hasha, hashb);
			endTime = getgtod();    
			printdouble("lshquery: lsh time: ", endTime - beginTime);
			warnx << "\n";

			// convert multiset to set
			if (uflag == 1) {
				//sig2str(regularsig, sigbuf);
				//warnx << "multiset: " << sigbuf << "\n";
				lshregularsig = myLSH->getUniqueSet(regularsig);
				//sig2str(lshregularsig, sigbuf);
				//warnx << "set: " << sigbuf << "\n";
				minhash = myLSH->getHashCode(lshregularsig);
			} else {
				minhash = myLSH->getHashCode(regularsig);
			}

			sort(minhash.begin(), minhash.end());
		}

		//warnx << "minhash.size(): " << minhash.size() << "\n";
		/*
		if (plist == 1) {
			warnx << "sig" << n << ": ";
			warnx << "minhash IDs: " << "\n";
			for (int i = 0; i < (int)minhash.size(); i++) {
				warnx << minhash[i] << "\n";
			}
		}
		*/

		//calcteamids(minhash);

		if ((Qflag == 1 || gflag == 1) && msgtype != INVALID) {
			team.clear();
			beginTime = getgtod();    
			for (int i = 0; i < (int)minhash.size(); i++) {
				teamID = minhash[i];
				warnx << "teamID: " << teamID << "\n";
				// TODO: check return status
				make_team(NULL, teamID, team);
				range = team.size();
				// randomness verified
				//randcol = randomNumGenZ(range-1);
				randcol = randomNumGenZ(range);
				ID = team[randcol];
				warnx << "ID in randcol " << randcol << ": " << ID << "\n";
				strbuf t;
				strbuf p;
				t << ID;
				p << team[0];
				str key(t);
				str strteamID(p);
				str dtdstr(dtd.c_str());
				warnx << "inserting " << msgtype << ":\n";
				makeKeyValue(&value, valLen, key, strteamID, dtdstr, querysig, qid, msgtype);
				totaltxmsglen += valLen;
				status = insertDHT(ID, value, valLen, instime, MAXRETRIES);
				totalinstime += instime;
				cleanup(value);

				// do not exit if insert FAILs!
				if (status != SUCC) {
					// TODO: do I care?
					warnx << "error: insert FAILed\n";
				} else {
					warnx << "insert SUCCeeded\n";
				}
			}

			// don't forget to clear team list!
			team.clear();
			endTime = getgtod();
			printdouble("lshquery: insert time (only): ", totalinstime);
			totalinstime = 0;
			warnx << "\n";
			printdouble("lshquery: insert time (+others): ", endTime - beginTime);
			warnx << "\n";

			warnx << "sleeping (lshquery)...\n";
			initsleep = 0;
			delaycb(intval, 0, wrap(initsleepnow));
			while (initsleep == 0) acheck();
		}
		// needed?
		minhash.clear();
		delete myLSH;
		++n;
	}
	return 0;
}

int
vanillaquery(sig2idmulti queryMap, int intval = -1, InsertType msgtype = INVALID, int col = 0)
{
	std::vector<POLY> querysig;
	std::string dtd;
	chordID ID;
	DHTStatus status;
	char *value;
	int valLen, n, qid;
	double beginTime, endTime, instime, totalinstime;
	str sigbuf;

	querysig.clear();
	n = 0;
	totalinstime = 0;
	for (sig2idmulti::iterator itr = queryMap.begin(); itr != queryMap.end(); itr++) {
		querysig = itr->first;
		qid = itr->second;
		id2strings::iterator ditr = qid2dtd.find(qid);
		if (ditr != qid2dtd.end()) {
			// TODO: assume 1 dtd per qid
			dtd = ditr->second.back();
		} else {
			warnx << "vanillaquery: no DTD found for qid: " << qid << "\n";
		}

		if ((Qflag == 1 || gflag == 1) && msgtype != INVALID) {
			beginTime = getgtod();    
			// send to random peer
			ID = make_randomID();
			strbuf z;
			z << ID;
			str key(z);
			str dtdstr(dtd.c_str());
			warnx << "inserting " << msgtype << ":\n";
			// teamID doesn't matter in Vanilla
			makeKeyValue(&value, valLen, key, key, dtdstr, querysig, qid, msgtype);
			totaltxmsglen += valLen;
			status = insertDHT(ID, value, valLen, instime, MAXRETRIES);
			totalinstime += instime;
			cleanup(value);

			// do not exit if insert FAILs!
			if (status != SUCC) {
				// TODO: do I care?
				warnx << "error: insert FAILed\n";
			} else {
				warnx << "insert SUCCeeded\n";
			}

			endTime = getgtod();
			printdouble("vanillaquery: insert time (only): ", totalinstime);
			totalinstime = 0;
			warnx << "\n";
			printdouble("vanillaquery: insert time (+others): ", endTime - beginTime);
			warnx << "\n";

			warnx << "sleeping (vanillaquery)...\n";
			initsleep = 0;
			delaycb(intval, 0, wrap(initsleepnow));
			while (initsleep == 0) acheck();
		}
		++n;
	}
	return 0;
}

// TODO: verify
int
lshsig(vecomap teamvecomap, int intval = -1, InsertType msgtype = INVALID, int listnum = 0, int col = 0)
{
	std::vector<std::vector<chordID> > matrix;
	std::vector<chordID> minhash;
	std::vector<chordID> buckets;
	std::vector<POLY> sig;
	//std::vector<POLY> sig1;
	//std::vector<POLY> sig2;
	std::vector<POLY> lshsig;
	chordID ID;
	DHTStatus status;
	char *value;
	int valLen, n, range, randcol;
	double freq, weight, beginTime, endTime, instime, totalinstime;
	str sigbuf;

	matrix.clear();
	minhash.clear();
	sig.clear();
	lshsig.clear();
	n = 0;
	totalinstime = 0;
	for (mapType::iterator itr = teamvecomap[listnum].begin(); itr != teamvecomap[listnum].end(); itr++) {
		sig = itr->first;
		freq = itr->second[0];
		weight = itr->second[1];

		// will hold last two signatures;
		/*
		if (n % 2 == 0)
			sig1 = sig;
		else
			sig2 = sig;
		*/

		beginTime = getgtod();    
		lsh *myLSH = new lsh(sig.size(), lfuncs, mgroups, lshseed, col, irrnums, hasha, hashb);
		endTime = getgtod();    
		printdouble("lshsig: lsh time: ", endTime - beginTime);
		warnx << "\n";
		// convert multiset to set
		if (uflag == 1) {
			//sig2str(sig, sigbuf);
			//warnx << "multiset: " << sigbuf << "\n";
			lshsig = myLSH->getUniqueSet(sig);
			//sig2str(lshsig, sigbuf);
			//warnx << "set: " << sigbuf << "\n";
			minhash = myLSH->getHashCode(lshsig);
		} else {
			minhash = myLSH->getHashCode(sig);
		}

		sort(minhash.begin(), minhash.end());

		//warnx << "minhash.size(): " << minhash.size() << "\n";
		/*
		if (plist == 1) {
			warnx << "sig" << n << ": ";
			warnx << "minhash IDs: " << "\n";
			for (int i = 0; i < (int)minhash.size(); i++) {
				warnx << minhash[i] << "\n";
			}
		}
		*/

		//calcteamids(minhash);

		if ((Qflag == 1 || gflag == 1) && msgtype != INVALID) {
			std::vector<chordID> team;
			chordID teamID;
			team.clear();
			beginTime = getgtod();    
			for (int i = 0; i < (int)minhash.size(); i++) {
				teamID = minhash[i];
				warnx << "teamID: " << teamID << "\n";
				// TODO: check return status
				make_team(NULL, teamID, team);
				range = team.size();
				// randomness verified
				//randcol = randomNumGenZ(range-1);
				randcol = randomNumGenZ(range);
				ID = team[randcol];
				warnx << "ID in randcol " << randcol << ": " << ID << "\n";
				strbuf t;
				strbuf p;
				t << ID;
				p << team[0];
				str key(t);
				str teamID(p);
				warnx << "inserting " << msgtype << ":\n";
				sig2str(sig, sigbuf);
				warnx << "txsig: " << sigbuf;
				printdouble(" ", freq);
				printdouble(" ", weight);
				warnx << "\n";
				makeKeyValue(&value, valLen, key, teamID, sig, freq, weight, msgtype);
				totaltxmsglen += valLen;
				status = insertDHT(ID, value, valLen, instime, MAXRETRIES);
				totalinstime += instime;
				cleanup(value);

				// do not exit if insert FAILs!
				if (status != SUCC) {
					// TODO: do I care?
					warnx << "error: insert FAILed\n";
				} else {
					warnx << "insert SUCCeeded\n";
				}
			}
			// don't forget to clear team list!
			team.clear();
			endTime = getgtod();
			printdouble("lshsig: insert time (only): ", totalinstime);
			totalinstime = 0;
			warnx << "\n";
			printdouble("lshsig: insert time (+others): ", endTime - beginTime);
			warnx << "\n";

			warnx << "sleeping (lshsig)...\n";
			initsleep = 0;
			delaycb(intval, 0, wrap(initsleepnow));
			while (initsleep == 0) acheck();
		}
		// needed?
		minhash.clear();
		delete myLSH;
		++n;
	}

	/*
	sig2str(sig1, sigbuf);
	warnx << "sig1: " << sigbuf << "\n";
	sig2str(sig2, sigbuf);
	warnx << "sig2: " << sigbuf << "\n";
	std::vector<POLY> gcdPoly;
	gcdPoly.clear();
	gcdSpecial(gcdPoly, sig1, sig2);
	int ismetric = 0;
	int deg = pSim(sig1, sig2, gcdPoly, ismetric);
	//sig2 = sig1;
	//gcdPoly.clear();
	//gcdSpecial(gcdPoly, sig1, sig2);
	int degOpt = pSimOpt(sig1, sig2, gcdPoly, ismetric);
	warnx << "pSim: " << deg << "\n";
	warnx << "pSimOpt: " << degOpt << "\n";
	*/

	/*
	sort(buckets.begin(), buckets.end());
	warnx << "sorted buckets:\n";
	for (int i = 0; i < (int)buckets.size(); i++) {
		warnx << "ID: " << buckets[i] << "\n";
	}
	*/

	//if (plist == 1) printteamidfreq();

	return 0;
}

// obsolete: use lshsig instead
int
lshpoly(vecomap teamvecomap, std::vector<std::vector<POLY> > &matrix, int intval = -1, InsertType msgtype = INVALID, int listnum = 0, int col = 0)
{
	std::vector<POLY> minhash;
	std::vector<POLY> sig;
	std::vector<POLY> lshsig;
	chordID ID;
	POLY mypoly;
	DHTStatus status;
	char *value;
	int valLen;
	double freq, weight, instime;
	//str sigbuf;

	minhash.clear();
	sig.clear();
	lshsig.clear();
	for (mapType::iterator itr = teamvecomap[listnum].begin(); itr != teamvecomap[listnum].end(); itr++) {
		sig = itr->first;
		freq = itr->second[0];
		weight = itr->second[1];

		lsh *myLSH = new lsh(sig.size(), lfuncs, mgroups, lshseed, col, irrnums, hasha, hashb);
		// convert multiset to set
		if (uflag == 1) {
			//sig2str(sig, sigbuf);
			//warnx << "multiset: " << sigbuf << "\n";
			lshsig = myLSH->getUniqueSet(sig);
			//sig2str(lshsig, sigbuf);
			//warnx << "set: " << sigbuf << "\n";
			minhash = myLSH->getHashCodeFindMod(lshsig, myLSH->getIRRPoly());
		} else {
			minhash = myLSH->getHashCodeFindMod(sig, myLSH->getIRRPoly());
		}

		//warnx << "minhash.size(): " << minhash.size() << "\n";

		/*
		if (plist == 1) {
			warnx << "minhash IDs:\n";
			for (int i = 0; i < (int)minhash.size(); i++) {
				warnx << minhash[i] << "\n";
			}
		}
		*/

		matrix.push_back(minhash);
		int range = (int)minhash.size();
		// randomness verified
		int randcol = randomNumGenZ(range);
		mypoly = (matrix.back())[randcol];
		warnx << "POLY in randcol " << randcol << ": " << mypoly << "\n";

		if (gflag == 1 && msgtype != INVALID) {
			strbuf mybuf;
			mybuf << mypoly;
			str mystr(mybuf);
			// TODO: verify
			ID = compute_hash(mystr, mystr.len());
			warnx << "compute_hash(POLY): " << ID << "\n";
			strbuf t;
			t << ID;
			str key(t);
			warnx << "inserting " << msgtype << ":\n";
			// TODO: generate teamID
			makeKeyValue(&value, valLen, key, key, sig, freq, weight, msgtype);
			totaltxmsglen += valLen;
			status = insertDHT(ID, value, valLen, instime, MAXRETRIES);
			cleanup(value);

			// do not exit if insert FAILs!
			if (status != SUCC) {
				warnx << "error: insert FAILed\n";
			} else {
				warnx << "insert SUCCeeded\n";
			}

			warnx << "sleeping (lsh)...\n";
			initsleep = 0;
			delaycb(intval, 0, wrap(initsleepnow));
			while (initsleep == 0) acheck();
		}
		delete myLSH;
	}
	return 0;
}

int
main(int argc, char *argv[])
{
	bool usedummy = false;
	bool useproxy = false;
	int Gflag, Lflag, lflag, rflag, Sflag, sflag, Oflag, zflag, vflag, Hflag, dflag, jflag, mflag, Iflag, Eflag, Pflag, Dflag, Mflag, Fflag, fflag, xflag, yflag, Zflag, Uflag, iflag;
	int ch, gintval, initintval, waitintval, listenintval, nids, rounds, valLen, logfd;
	int listnum;
	int qid;
	int bstrapport = 0;
	int sessionlen = 0;
	int sessionrounds = 0;
	int killroundrange = 0;
	int killround = 0;
	double beginTime = 0.0;
	double beginreadTime = 0.0;
	double begingossipTime, endgossipTime, endTime, endreadTime, instime;
	char *value;
	struct stat statbuf;
	time_t rawtime;
	chordID ID;
	chordID teamID;
	std::vector<chordID> team;
	DHTStatus status;
	InsertType msgtype = NONE;
	MergeType mergetype = OTHER;
	str sigbuf;
	std::string dtd;
	std::string initdir;
	std::string proxysigdir;
	std::string sigdir;
	std::string xpathdir;
	std::string inmergetype;
	std::string cmd;
	std::vector<std::string> initfiles;
	std::vector<std::string> proxysigfiles;
	std::vector<std::string> sigfiles;
	std::vector<std::string> xpathfiles;
	std::vector<std::string> dtdList;
	std::vector<std::vector<POLY> > proxysigList;
	std::vector<std::vector<POLY> > sigList;
	std::vector<double> freqList;
	std::vector<double> weightList;
	std::vector<long double> lfreqList;
	std::vector<long double> lweightList;
	std::vector<std::vector<POLY> > queryList;
	std::vector<POLY> sig;
	std::vector<POLY> proxysig;
	std::vector<POLY> querysig;
	std::vector<POLY> compressedList;
	std::vector<std::vector<unsigned char> > outBitmap;


	Gflag = Lflag = lflag = rflag = Sflag = sflag = Oflag = zflag = vflag = Hflag = dflag = jflag = mflag = Eflag = Iflag = Pflag = Dflag = Mflag = Fflag = fflag = xflag = yflag = Zflag = Uflag = iflag = 0;
	gintval = waitintval = listenintval = nids = 0;
	initintval = -1;
	rounds = -1;
	rxqseq.clear();
	rxseq.clear();
	txseq.clear();
	// init txseq/rxqseq: txseq/rxqseq.back() segfaults!
	txseq.push_back(0);
	rxqseq.push_back(0);
	// init dummysig: segfault!
	dummysig.clear();
	dummysig.push_back(1);

	// parse arguments
	while ((ch = getopt(argc, argv, "A:bB:CcD:d:EF:f:G:gHhIi:j:K:k:L:lMmN:n:O:o:P:pQq:R:rS:s:T:t:U:uVvW:w:X:x:y:Z:z")) != -1)
		switch(ch) {
		case 'A':
			bstrapport = strtol(optarg, NULL, 10);
			break;
		case 'B':
			mgroups = strtol(optarg, NULL, 10);
			break;
		case 'b':
			bcast = true;
			break;
		case 'R':
			lfuncs = strtol(optarg, NULL, 10);
			break;
		case 'C':
			compress = 1;
			break;
		case 'c':
			churn = true;
			break;
		case 'D':
			Dflag = 1;
			initdir = optarg;
			break;
		case 'd':
			dflag = 1;
			lshseed = strtol(optarg, NULL, 10);
			break;
		case 'E':
			Eflag = 1;
			break;
		case 'F':
			Fflag = 1;
			hashfile = optarg;
			break;
		case 'f':
			fflag = 1;
			killfile = optarg;
			break;
		case 'I':
			Iflag = 1;
			break;
		case 'i':
			iflag = 1;
			idsfile = optarg;
			break;
		case 'G':
			Gflag = 1;
			gsock = optarg;
			break;
		case 'g':
			gflag = 1;
			break;
		case 'H':
			Hflag = 1;
			break;
		case 'T':
			initintval = strtol(optarg, NULL, 10);
			break;
		case 't':
			gintval = strtol(optarg, NULL, 10);
			break;
		case 'j':
			jflag = 1;
			irrpolyfile = optarg;
			break;
		case 'K':
			killroundrange = strtol(optarg, NULL, 10);
			break;
		case 'k':
			sessionrounds = strtol(optarg, NULL, 10);
			break;
		case 'L':
			Lflag = 1;
			logfile = optarg;
			break;
		case 'l':
			lflag = 1;
			break;
		case 'M':
			Mflag = 1;
			break;
		case 'm':
			mflag = 1;
			break;
		case 'N':
			ninstances = strtol(optarg, NULL, 10);
			break;
		case 'n':
			nids = strtol(optarg, NULL, 10);
			break;
		case 'O':
			Oflag = 1;
			proxysigdir = optarg;
			break;
		case 'o':
			rounds = strtol(optarg, NULL, 10);
			break;
		case 'P':
			Pflag = 1;
			initfile = optarg;
			break;
		case 'p':
			plist = 1;
			break;
		case 'Q':
			Qflag = 1;
			break;
		case 'q':
			peers = strtol(optarg, NULL, 10);
			break;
		case 'r':
			rflag = 1;
			break;
		case 'S':
			Sflag = 1;
			dsock = optarg;
			break;
		case 's':
			sflag = 1;
			sigdir = optarg;
			break;
		case 'U':
			Uflag = 1;
			// TODO: check if valid chordID
			str2chordID(optarg, thisID);
			break;
		case 'u':
			uflag = 1;
			break;
		case 'W':
			listenintval = strtol(optarg, NULL, 10);
			break;
		case 'w':
			waitintval = strtol(optarg, NULL, 10);
			break;
		case 'X':
			freqbyx = strtol(optarg, NULL, 10);
			break;
		case 'x':
			xflag = 1;
			xpathdir = optarg;
			break;
		case 'y':
			yflag = 1;
			inmergetype = optarg;
			break;
		case 'Z':
			Zflag = 1;
			teamsize = strtol(optarg, NULL, 10);
			break;
		case 'z':
			zflag = 1;
			break;
		case 'V':
			vanilla = true;
			break;
		case 'v':
			vflag = 1;
			break;
		case 'h':
		case '?':
		default:
			usage();
			break;
		}
	argc -= optind;
	argv += optind;

	// print version
	if (vflag == 1) {
		warnx << "rcsid: " << rcsid << "\n";
		exit(0);
	}

	// set random local seed
	char host[256];
	struct timeval tv;
	unsigned int loseed;
	gethostname(host, 256);
	gettimeofday(&tv, NULL);
	loseed = ((long)tv.tv_sec + (long)tv.tv_usec) / (long)getpid();
	//warnx << "loseed: " << loseed << "\n";
	srandom(loseed);

	if (uflag == 1)	fatal << "don't try to convert multiset to set when using LSH!\n";

	// generate random chordIDs and -Z teams for each chordID
	if (zflag == 1 && nids != 0) {
		std::vector<chordID> IDs;
		for (int i = 0; i < nids; i++) {
			strbuf t;
			ID = make_randomID();
			//warnx << "ID: " << ID << "\n";
			IDs.push_back(ID);
		}
		sort(IDs.begin(), IDs.end());
		warnx << "sorted IDs:\n";
		for (int i = 0; i < (int)IDs.size(); i++) {
			warnx << "ID: " << IDs[i] << "\n";
		}
		warnx << "teams:\n";
		for (int i = 0; i < (int)IDs.size(); i++) {
			warnx << "team_" << i << ":\n";
			make_team(NULL, IDs[i], team);
		}

		//double dtype = 0.0556211;
		double dtype = 1;
		//long double ldtype = 0.0556211;
		long double ldtype = 1;

		printdouble("dtype: ", dtype);
		warnx << " sizeof(dtype): " << sizeof(dtype) << "\n";
		printdouble("ldtype: ", ldtype);
		warnx << " sizeof(ldtype): " << sizeof(ldtype) << "\n";
		std::cout << "DBL_MIN: " << DBL_MIN << "\n";
		std::cout << "DBL_MAX: " << DBL_MAX << "\n";
		for (int i = 0; i < rounds; i++) {
			warnx << "round " << i;
			dtype /= 2;
			ldtype /= 2;
			//std::cout << " c:dtype: " << dtype;
			printdouble(" p:dtype: ", dtype);
			lprintdouble(" lp:dtype: ", dtype);
			//std::cout << " c:ldtype: " << ldtype;
			printdouble(" p:ldtype: ", ldtype);
			lprintdouble(" lp:ldtype: ", ldtype);
			double nan = dtype / dtype;
			double inf = ldtype / dtype;
			printdouble(" p:nan: ", nan);
			printdouble(" p:inf: ", inf);
			if (isnan(nan)) {
				printdouble(" isnan(dtype/dtype): ", nan);
			}
			if (isinf(inf)) {
				printdouble(" isinf(ldtype/dtype): ", inf);
			}
			warnx << "\n";
		}

		return 0;
	}

	// TODO: make sure only one flag is set at a time
	// at least one action: read, gossip, LSH, query or listen
	if (rflag == 0 && gflag == 0 && lflag == 0 && Hflag == 0 && Mflag == 0 && Qflag == 0 && churn == false) usage();

	// sockets are required when listening or gossiping
	if ((gflag == 1 || lflag == 1) && (Gflag == 0 || Sflag == 0)) usage();

	// dhash socket is required when querying
	if (Qflag == 1 && Sflag == 0) usage();

	if (churn == true && (gintval == 0 || peers == 0 || ninstances == 0 || bstrapport == 0 || rounds == -1 || sessionrounds == 0 || listenintval == 0)) usage();

	// sig or xpath are required when querying
	if (Qflag == 1 && (sflag == 0 && xflag == 0)) usage();

	// TODO: handle sflag & Pflag
	if (gflag == 1 && gintval == 0) usage();

	// merge type and directory of files to be merged is required
	if (Mflag == 1 && (Dflag == 0 || yflag == 0 || Zflag == 0)) usage();

	if (yflag == 1) {
		if (strcmp(inmergetype.c_str(), "init") == 0)
			mergetype = INIT;	
		else if (strcmp(inmergetype.c_str(), "results") == 0)
			mergetype = RESULTS;	
		else
			usage();
	}

	// action H (for testing)
	if ((Hflag == 1) && (dflag == 0 || jflag == 0 || Fflag == 0)) usage();

	// option H (for gossiping)
	// TODO: handle sflag & Pflag & Fflag
	if ((Hflag == 1 && gflag == 1) && (waitintval == 0 || initintval == -1) &&
	    (Eflag == 1 || Iflag == 1))
		usage();

	// sigs/queries are required when listening or reading
	// TODO: add Oflag
	if ((lflag == 1 || rflag == 1) && (sflag == 0 && xflag == 0)) usage();

	// set up log file: log.gpsi
	if (Lflag == 1) {
		// overwrite existing log file
		logfd = open(logfile, O_CREAT|O_WRONLY|O_TRUNC, 0644);
		if (logfd < 0) fatal << "can't open log file " << logfile << "\n";
		lseek(logfd, 0, SEEK_END);
		errfd = logfd;

		// set root dir
		rootdir = dirname(logfile);
		myhostnum = strtol(basename(rootdir), NULL, 10);
	}

	time(&rawtime);
	warnx << "start ctime: " << ctime(&rawtime);
	warnx << "start sincepoch: " << time(&rawtime) << "\n";

	// set up init phase file: log.init
	FILE *initfp = NULL;
	std::string acc;
	if (Pflag == 1) {
		// overwrite in init phase or reading
		if (Iflag == 1 || rflag == 1)
			acc = "w+";
		// read-only in exec phase
		else
			acc = "r";

		if ((initfp = fopen(initfile, acc.c_str())) == NULL) {
			fatal << "can't open init file " << initfile << "\n";
		}
	}

	// check if this proc should be killed
	if (fflag == 1) {
		if (stat(killfile, &statbuf) != 0)
			fatal << "'" << killfile << "' does not exist" << "\n";

		std::ifstream killstream;
                killstream.open(killfile);
                int hostnum;
                while (killstream >> hostnum) {
			if (hostnum == myhostnum) killme = true;
                }
                killstream.close();

	}

	// set up hash file: hash.dat
	FILE *hashfp = NULL;
	if (Fflag == 1) {
		// init phase OR
		// generate chordIDs using LSH (no gossip)
		// but don't if querying
		// TODO: verify
		if ((Iflag == 1 || gflag == 0) && (Qflag != 1)) {
			acc = "w+";
			if ((hashfp = fopen(hashfile, acc.c_str())) == NULL) {
				fatal << "can't write hash file " << hashfile << "\n";
			}

			int random_integer_a;
			int random_integer_b;
			int lowest_a = 1, highest_a = -9;
			int lowest_b = 0, highest_b = -9;
			highest_a = highest_b = lshseed;
			int range_a = (highest_a - lowest_a) + 1;
			int range_b = (highest_b - lowest_b) + 1;
			hasha.clear();
			hashb.clear();
			srand(lshseed);
			int totalfuncs = lfuncs * mgroups;
			for (int i = 0; i < totalfuncs; i++) {
				// TODO: verify randomness
				random_integer_a  = lowest_a + int((double)range_a*rand()/(RAND_MAX + 1.0));
				random_integer_b  = lowest_b + int((double)range_b*rand()/(RAND_MAX + 1.0));
				hasha.push_back(random_integer_a);
				hashb.push_back(random_integer_b);
			}

			warnx << "writing " << hashfile << "...\n";
			for (int i = 0; i < (int)hasha.size(); i++) {
				fprintf(hashfp, "%d\n", hasha[i]);
			}

			for (int i = 0; i < (int)hashb.size(); i++) {
				fprintf(hashfp, "%d\n", hashb[i]);
			}
			fclose(hashfp);
		// exec phase OR
		// querying?
		} else {
			//acc = "r";
			//if ((hashfp = fopen(hashfile, acc.c_str())) == NULL) {
			//	fatal << "can't read hash file " << hashfile << "\n";
			//}

			std::ifstream hashstream(hashfile);
			int totalfuncs = lfuncs * mgroups;
			if (hashstream.is_open()) {
				int hashnum;
				hasha.clear();
				hashb.clear();
				int z = 0;
				while (hashstream >> hashnum) {
					++z;
					if (z <= totalfuncs)
						hasha.push_back(hashnum);
					else
						hashb.push_back(hashnum);
				}
				assert(hasha.size() == hashb.size());
				assert((int)hasha.size() == totalfuncs);
				hashstream.close();
			} else {
				fatal << "can't read hash file " << hashfile << "\n";
			}
		}
	}

	// load irreducible polys in memory
	if (jflag == 1) {
		if (stat(irrpolyfile, &statbuf) != 0)
			fatal << "'" << irrpolyfile << "' does not exist" << "\n";

		irrnums.clear();
		std::ifstream polystream;
                polystream.open(irrpolyfile);
                POLY num;
                while (polystream >> num) {
                        irrnums.push_back(num);
                }
                polystream.close();
	}

	// load chordIDs in memory
	if (iflag == 1) {
		if (stat(idsfile, &statbuf) != 0)
			fatal << "'" << idsfile << "' does not exist" << "\n";

		allIDs.clear();
		std::ifstream idstream;
                idstream.open(idsfile);
                std::string a;
		chordID b;
                while (idstream >> a) {
			str z(a.c_str());
			str2chordID(z, b);
			allIDs.push_back(b);
                }
                idstream.close();

		warnx << "chordIDs loaded: " << allIDs.size() << "\n";
		/*
		warnx << "before shuffle:\n";
		for (int i = 0; i < (int)allIDs.size(); i++)
			warnx << allIDs[i] << "\n";
		*/

		// shuffle all the IDs
		random_shuffle(allIDs.begin(), allIDs.end());

		warnx << "IDs after shuffle:\n";
		for (int i = 0; i < (int)allIDs.size(); i++)
			warnx << allIDs[i] << "\n";
	}

	// connect to Chord socket when: listening, gossiping, querying
	if (gflag == 1 || lflag == 1 || Qflag == 1) {
		if (stat(dsock, &statbuf) != 0)
			fatal << "'" << dsock << "' does not exist" << "\n";
		dhash = New dhashclient(dsock);
	}

	// read signatures in memory
	if ((rflag == 1 || gflag == 1 || Hflag == 1 || lflag == 1 || Qflag == 1 || Mflag == 1) && (sflag == 1 || Oflag == 1)) {
		usedummy = false;
		useproxy = false;

		// read regular sigs
		if (sflag == 1) {
			beginreadTime = getgtod();    
			getdir(sigdir, sigfiles);
			sigList.clear();

			// insert dummy
			// the polynomial "1" has a degree 0
			// don't add dummy when querying, gossiping using LSH, or merging results?
			if (Hflag == 0 && Qflag == 0 && Mflag == 0) {
				usedummy = true;
				sigList.push_back(dummysig);
			}

			warnx << "reading signatures from files...\n";
			for (unsigned int i = 0; i < sigfiles.size(); i++) {
				readsig(sigfiles[i], sigList, useproxy);
			}
			warnx << "calculating frequencies...\n";
			beginTime = getgtod();    
			warnx << "sigList.size() (all): " << sigList.size() << "\n";
			calcfreq(sigList, usedummy, useproxy);
			// long double
			//lcalcfreq(sigList, usedummy, useproxy);
			endTime = getgtod();    
			printdouble("calcfreq time (+sorting): ", endTime - beginTime);
			warnx << "\n";
			if (freqbyx > 1) {
				// don't multiply weight
				multiplyfreq(allT, 0, freqbyx, 1);
			}

			if (plist == 1) {
				// both init phases use allT
				printlist(allT, 0, -1);
				// long double
				//lprintlist(lallT, 0, -1);
				// print DTD names and how many sigs/DTD
				for (string2sigs::iterator itr = dtd2sigs.begin(); itr != dtd2sigs.end(); itr++) {
					warnx << "DTD: " << itr->first.c_str();
					warnx << " sigs: " << itr->second.size() << "\n";
					//sig2str(itr->second.back(), sigbuf);
					//warnx << " sig: " << sigbuf << "\n";
				}
			}
		}

		// read proxy sigs
		if (Oflag == 1) {
			getdir(proxysigdir, proxysigfiles);
			proxysigList.clear();
			usedummy = false;
			useproxy = true;

			warnx << "reading proxy signatures from files...\n";
			for (unsigned int i = 0; i < proxysigfiles.size(); i++) {
				readsig(proxysigfiles[i], proxysigList, useproxy);
			}
			warnx << "calculating frequencies...\n";
			warnx << "proxysigList.size() (all): " << proxysigList.size() << "\n";
			calcfreq(proxysigList, usedummy, useproxy);

			if (plist == 1) {
				// both init phases use allT
				printlist(allT, 1, -1);
				// print DTD names and how many sigs/DTD
				for (string2sigs::iterator itr = dtd2proxysigs.begin(); itr != dtd2proxysigs.end(); itr++) {
					warnx << "DTD: " << itr->first.c_str();
					warnx << " proxy sigs: " << itr->second.size() << "\n";
					//sig2str(itr->second.back(), sigbuf);
					//warnx << " sig: " << sigbuf << "\n";
				}
			}

		}

		// verify compress/uncompress/makeKeyValue/getKeyValue work
		/*
		if (compress == 1) {
			compressedList.clear();
			outBitmap.clear();
			sigList.clear();
			lfreqList.clear();
			lweightList.clear();
			lvecomap2vec(lallT, 0, sigList, lfreqList, lweightList);

			int sigbytesize = 0;
			for (int i = 0; i < (int)sigList.size(); i++) {
				sigbytesize += (sigList[i].size() * sizeof(POLY));
			}

			warnx << "sigList size (bytes): " << sigbytesize << "\n";
			warnx << "sigList.size() (unique): " << sigList.size() << "\n";

			compressSignatures(sigList, compressedList, outBitmap);

			int compressedsize = compressedList.size() * sizeof(POLY);
			warnx << "compressedList size (bytes): " << compressedsize << "\n";
			warnx << "compressedList.size(): " << compressedList.size() << "\n";

			int bitmapsize = 0;
			for (int i = 0; i < (int)outBitmap.size(); i++) {
				bitmapsize += (outBitmap[i].size() * sizeof(unsigned char));
			}

			warnx << "outBitmap size (bytes): " << bitmapsize << "\n";
			warnx << "outBitmap.size(): " << outBitmap.size() << "\n";

			warnx << "total compressed size (list+bitmap): " << compressedsize + bitmapsize << "\n";

			//for (int i = 0; i < (int) compressedList.size(); i++) {
			//	printf("%u\n", compressedList[i]);
			//	for (int j = 0; j < ceil(sigList.size() / 8.0); j++) {
			//		//warnx << "--> " << outBitmap[i][j] << "\n";
			//		printf("--> %x\n", outBitmap[i][j]);
			//	}
			//}

			ID = make_randomID();
			strbuf t;
			t << ID;
			str key(t);
			str teamID(t);
			txseq.push_back(777);
			warnx << "key: " << key << "\n";
			warnx << "teamID: " << teamID << "\n";
			warnx << "seq: " << txseq.back() << "\n";
			warnx << "numSigs: " << lfreqList.size() << "\n";
			warnx << "compressedList.size(): " << compressedList.size() << "\n";
			makeKeyValue(&value, valLen, key, teamID, compressedList, outBitmap, lfreqList, lweightList, txseq.back(), XGOSSIPC);

			// clear and init global txseq list!
			txseq.clear();
			txseq.push_back(0);

			int seq, numSigs;
			str newkey;
			str newteamID;
			compressedList.clear();
			outBitmap.clear();
			lfreqList.clear();
			lweightList.clear();

			int ret = getKeyValue(value, newkey, newteamID, compressedList, outBitmap, numSigs, lfreqList, lweightList, seq, valLen);
			if (ret == -1) warnx << "error: getKeyValue failed\n";
			warnx << "key: " << newkey << "\n";
			warnx << "teamID: " << newteamID << "\n";
			warnx << "seq: " << seq << "\n";
			warnx << "numSigs: " << numSigs << "\n";
			warnx << "compressedList.size(): " << compressedList.size() << "\n";

			//int numSigs = sigList.size();
			std::vector<std::vector<POLY> > newsigList;
			newsigList.clear();
			uncompressSignatures(newsigList, compressedList, outBitmap, numSigs);

			warnx << "after uncompress:\n";
			assert(newsigList.size() == sigList.size());
			bool multi;
			double simi;
			for (int i = 0; i < (int) newsigList.size(); i++) {
				simi = signcmp(sigList[i], newsigList[i], multi);
				if (simi != 1) {
					int ninter = set_inter_noskip(sigList[i], newsigList[i], multi);
					warnx << "warning: uncompressed sig differs ";
					printdouble("sim: ", simi);
					warnx << " common-POLYs: " << ninter;
					warnx << " sig-org.size: " << sigList[i].size();
					warnx << " sig-unc.size: " << newsigList[i].size();
					warnx << "\n";
					sig2str(sigList[i], sigbuf);
					warnx << "sig-org[" << i << "]: " << sigbuf << "\n";
					sig2str(newsigList[i], sigbuf);
					warnx << "sig-unc[" << i << "]: " << sigbuf << "\n";
				} else {
					printdouble("sim: ", simi);
					warnx << " ";
					sig2str(newsigList[i], sigbuf);
					warnx << "sig[" << i << "]: " << sigbuf << "\n";
				}
			}
		}
		*/

		// create log.init of sigs (why?)
		/*
		if (Pflag == 1) {
			warnx << "writing " << initfile << "...\n";
			loginitstate(initfp);
			fclose(initfp);
		}
		*/
		endreadTime = getgtod();    
		printdouble("read time: ", endreadTime - beginreadTime);
		warnx << "\n";
	}

	// reading or querying using XPath files
	if ((rflag == 1 || Qflag == 1) && xflag == 1) {
		getdir(xpathdir, xpathfiles);
		queryList.clear();
		dtdList.clear();

		warnx << "reading queries from files...\n";
		for (unsigned int i = 0; i < xpathfiles.size(); i++) {
			readquery(xpathfiles[i], queryList, dtdList);
		}
		add2querymap(queryList, dtdList);
		/*
		warnx << "calculating frequencies...\n";
		beginTime = getgtod();    
		calcfreq(queryList);
		endTime = getgtod();    
		printdouble("calcfreq time (+sorting): ", endTime - beginTime);
		warnx << "\n";
		*/
		if (plist == 1) {
			// both init phases use allT
			//printlist(allT, 0, -1);
			warnx << "queries:\n";
			for (sig2idmulti::iterator qitr = queryMap.begin(); qitr != queryMap.end(); qitr++) {
				querysig = qitr->first;
				qid = qitr->second;

				dtd = "";
				id2strings::iterator ditr = qid2dtd.find(qid);
				if (ditr != qid2dtd.end()) {
					if (ditr->second.size() != 1) {
						warnx << "more than 1 DTD per QID\n";
					}
					dtd = ditr->second.back();
				} else {
					warnx << "DTD missing\n";
				}
				sig2str(querysig, sigbuf);
				warnx << "QID: " << qid << " DTD: " << dtd.c_str() << " QUERYSIG: " << sigbuf << "\n";
			}
			/*
			for (unsigned int i = 0; i < queryList.size(); i++) {
				sig2str(queryList[i], sigbuf);
				warnx << "query" << i << ": " << sigbuf << "\n";
			}
			*/
		}
	}

	// run xpath queries on sigs locally
	//if (sflag == 1 && xflag == 1) {
	if (rflag == 1 && sflag == 1 && xflag == 1) {
		int sigmatches = 0;
		double totalfreq = 0;
		int tind = 0;
		double minsim = 0;
		double avgsim = 0;
		//int ninter;
		//bool multi;
		// store all sigs in allT[allnum]
		//int allnum = 0;
		// store results sigs in allT[resultsnum]
		//int resultsnum = 1;
		//mapType tmpvecomap;
		//allT.push_back(tmpvecomap);

		// from now on, work only with totalT
		totalT.push_back(allT);

		warnx << "running xpath queries locally...\n";
		warnx << "qid,dtd,querysig,sigmatches,totalfreq,minsim,avgsim\n";
		for (sig2idmulti::iterator qitr = queryMap.begin(); qitr != queryMap.end(); qitr++) {
			querysig = qitr->first;
			qid = qitr->second;

			// doesn't matter if it's QUERYX or QUERYXP
			run_query(tind, querysig, sigmatches, totalfreq, minsim, avgsim, QUERYX);

			/*
			// find if the query sig is a subset of any of the sigs
			for (mapType::iterator sitr = allT[allnum].begin(); sitr != allT[allnum].end(); sitr++) {
				ninter = set_inter_noskip(qitr->first, sitr->first, multi);
				//warnx << "ninter: " << ninter << ", querysig.size(): " << queryList[i].size() << "\n";
				if (ninter == (int)qitr->first.size()) {
					//if (Qflag == 1) {
						//allT[resultsnum][qitr->first][0] += sitr->second[0];
						//allT[resultsnum][qitr->first][1] += sitr->second[1];
					//}
					++sigmatches;
					// weight is always 1
					totalfreq += sitr->second[0];
					//totalavg += (sitr->second[0]/sitr->second[1]);
					if (plist == 1) {
						//warnx << "superset sig found: ";
						sig2str(sitr->first, sigbuf);
						warnx << "supersetsig: " << sigbuf;
						printdouble(" f: ", sitr->second[0]);
						printdouble(" w: ", sitr->second[1]);
						printdouble(" avg: ", sitr->second[0]/sitr->second[1]);
						warnx << "\n";
						//if (multi == 1) warnx << "superset sig is a multiset\n";
					}
				}
			}
			*/

			dtd = "";
			id2strings::iterator ditr = qid2dtd.find(qid);
			if (ditr != qid2dtd.end()) {
				if (ditr->second.size() != 1) {
					warnx << "more than 1 DTD per QID\n";
				}
				dtd = ditr->second.back();
			} else {
				warnx << "DTD missing\n";
			}

			warnx << qid << ",";
			warnx << dtd.c_str() << ",";
			sig2str(querysig, sigbuf);
			warnx << sigbuf << ",";
			warnx << sigmatches << ",";
			printdouble("", totalfreq);
			warnx << ",";
			printdouble("", minsim);
			warnx << ",";
			printdouble("", avgsim);
			warnx << ",\n";

			/*
			warnx << "qid: " << qitr->second;
			warnx << " querysig: " << sigbuf;
			warnx << " sigmatches: " << sigmatches;
			printdouble(" totalfreq: ", totalfreq);
			printdouble(" minsim: ", minsim);
			printdouble(" avgsim: ", avgsim);
			warnx << "\n";
			*/
			sigmatches = 0;
			totalfreq = 0;
		}
	}

	warnx << "rcsid: " << rcsid << "\n";
	warnx << "root dir: " << rootdir << "\n";
	warnx << "my host num: " << myhostnum << "\n";
	warnx << "will be killed: ";
	if (killme == true) warnx << "yes\n";
	else warnx << "no\n";
	warnx << "host: " << host << "\n";
	warnx << "pid: " << getpid() << "\n";
	warnx << "peers: " << peers << "\n";
	warnx << "instances: " << ninstances << "\n";
	printdouble("peers/instance: ", peers / ninstances);
	warnx << "\n";
	warnx << "loseed: " << loseed << "\n";
	warnx << "mgroups: " << mgroups << "\n";
	warnx << "lfuncs: " << lfuncs << "\n";
	warnx << "teamsize: " << teamsize << "\n";
	warnx << "total rounds: " << rounds << "\n";
	warnx << "round length: " << gintval << "\n";
	warnx << "kill round range: " << killroundrange << "\n";
	// pick random round to kill itself
	if (killroundrange != 0) {
		srand(loseed);
		// TODO: fix this mess
		int range;
		int max = killroundrange;
		int min;
		// b/w 1 and 10
		if (max == 10) {
			min = 1;
		// b/w 11 and 20
		} else if (max == 20) {
			min  = 11;
		} else {
			fatal << "wrong kill range\n";
		}
		range = max - min + 1;
		killround = rand() % range + min;
		warnx << "kill round: " << killround << "\n";
	}
	if (Uflag == 1) warnx << "myID: " << thisID << "\n";
	warnx << "compression: ";
	if (compress == 1) warnx << "yes\n";
	else warnx << "no\n";
	warnx << "churn: ";
	if (churn == true) {
		warnx << "yes\n";
		warnx << "session rounds: " << sessionrounds << "\n";
		sessionlen = gintval * sessionrounds;
		warnx << "session length: " << sessionlen << "\n";
		warnx << "bootstrap port: " << bstrapport << "\n";
	} else
		warnx << "no\n";

	if (churn == true) {
		//std::string myuser = getlogin();
		std::string myuser = "ec2-user";
		std::string myhome = "/home/" + myuser;
		std::string scripts = myhome + "/bin";
		std::string churnlsdroot = "/media/ephemeral0/tmp.churn.lsd";

		// pick random round to join
		srand(loseed);
		//int randround = randomNumGenZ(rounds);
		int randround = rand() % rounds + 1;
		warnx << "join round: " << randround << "\n";

		// wait for all other peers to start exec phase
		warnx << "listen interval: " << listenintval << "\n";
		warnx << "waiting to start exec phase (" << listenintval << "s)...\n";
		initsleep = 0;
		delaycb(listenintval, 0, wrap(initsleepnow));
		while (initsleep == 0) acheck();

		// wait to join in randround
		warnx << "waiting to join Chord (" << randround * gintval << "s)...\n";
		gossipsleep = 0;
		delaycb(randround * gintval, 0, wrap(gossipsleepnow));
		while (gossipsleep == 0) acheck();

		// join Chord
		int step = 5;
		int gap = 100;
		int lastport = peers * step + bstrapport + gap;

		// find next available port
		std::string sbport = itostring(bstrapport);
		std::string slport = itostring(lastport);
		std::string myroot = churnlsdroot + "/" + slport;
		while (stat(myroot.c_str(), &statbuf) == 0) {
			lastport += 5;
			slport = itostring(lastport);
			myroot = churnlsdroot + "/" + slport;
		}

		mkdir(myroot.c_str(), 0775);

		warnx << "joining Chord...\n";
		cmd = scripts + "/join_chord.sh " + sbport + " " + slport + " " + myroot;
		warnx << cmd.c_str() << "\n";
		system(cmd.c_str());

		// wait sessionlen in Chord
		warnx << "waiting in Chord (" << sessionlen << "s)...\n";
		gossipsleep = 0;
		delaycb(sessionlen, 0, wrap(gossipsleepnow));
		while (gossipsleep == 0) acheck();

		// leave
		warnx << "leaving Chord...\n";
		cmd = scripts + "/leave_chord.sh " + myroot;
		warnx << cmd.c_str() << "\n";
		system(cmd.c_str());

		return 0;
	}

	std::vector<std::vector<POLY> > pmatrix;

	// VanillaXGossip init phase ends?
	// VanillaXGossip exec phase starts?
	// start using totalT BEFORE listening
	if (gflag == 1 && Hflag == 0) {
		vanilla = true;
		// from now on, work only with totalT
		totalT.push_back(allT);
	}

	// listen
	if (gflag == 1 || lflag == 1) {
		time(&rawtime);
		warnx << "listen ctime: " << ctime(&rawtime);
		warnx << "listen sincepoch: " << time(&rawtime) << "\n";
		// enter init phase
		if (Iflag == 1) initphase = true;

		warnx << "listening for gossip...\n";
		listengossip();		
		warnx << "listen interval: " << listenintval << "\n";
		initsleep = 0;
		delaycb(listenintval, 0, wrap(initsleepnow));
		while (initsleep == 0) acheck();
	}

	// XGossip init phase and "action H" (not gossiping)
	if (Hflag == 1 && Iflag == 1) {
		warnx << "initgossipsend...\n";
		warnx << "interval b/w inserts: " << initintval << "\n";

		beginTime = getgtod();    
	
		// InitGossipSend: use findMod()
		if (mflag == 1) {
			// T_m is 1st list
			lshpoly(allT, pmatrix, initintval, INITGOSSIP);
			pmatrix.clear();
		// InitGossipSend: use compute_hash()
		} else {
			lshsig(allT, initintval, INITGOSSIP);
		}

		endTime = getgtod();    
		printdouble("xgossip init phase time: ", endTime - beginTime);
		warnx << "\n";

		if (gflag == 1) {
			warnx << "wait interval: " << waitintval << "\n";
			warnx << "waiting for all peers to finish init phase...\n";

			waitsleep = 0;
			delaycb(waitintval, 0, wrap(waitsleepnow));
			while (waitsleep == 0) acheck();

			printteamids();
			warnx << "writing " << initfile << "...\n";
			loginitstate(initfp);
			fclose(initfp);
			/*
			if (plist == 1) {
				printlistall();
			}
			*/
			warnx << "openfd: " << openfd << "\n";
			warnx << "closefd: " << closefd << "\n";
		}

		// exit init phase
		initphase = false;
	}

	// Broadcast exec phase
	if (bcast == true) {
		warnx << "broadcast exec...\n";
		warnx << "broadcast interval: " << gintval << "\n";
		//warnx << "interval b/w inserts: " << initintval << "\n";
		time(&rawtime);
		warnx << "start exec ctime: " << ctime(&rawtime);
		warnx << "start exec sincepoch: " << time(&rawtime) << "\n";

		begingossipTime = getgtod();    

		// needed?
		srandom(loseed);

		for (int i = 0; i < (int)allIDs.size(); i++) {
			// skip myID
			if (allIDs[i] == thisID) {
				warnx << "skipping myID: " << thisID << "\n";
				continue;
			}
			warnx << "inserting ";
			if (compress == 1) warnx << "BCASTC:\n";
			else warnx << "BCAST:\n";

			ID = allIDs[i];
			strbuf z;
			z << ID;
			str key(z);
			warnx << "ID" << i << ": " << ID;
			warnx << " txseq: " << txseq.back() << "\n";

			if (compress == 1) {
				compressedList.clear();
				outBitmap.clear();
				sigList.clear();
				freqList.clear();
				weightList.clear();
				lfreqList.clear();
				lweightList.clear();
				vecomap2vec(totalT[0], 0, sigList, freqList, weightList);
				//vecomap2vec(totalT[0], 0, sigList, lfreqList, lweightList);

				/*
				int sigbytesize = 0;
				warnx << "sigs before compression:\n";
				for (int i = 0; i < (int)sigList.size(); i++) {
					sigbytesize += (sigList[i].size() * sizeof(POLY));
					//sig2str(sigList[i], sigbuf);
					//warnx << "sig[" << i << "]: " << sigbuf << "\n";
				}

				warnx << "sigList size (bytes): " << sigbytesize << "\n";
				warnx << "sigList.size() (unique): " << sigList.size() << "\n";
				*/
				compressSignatures(sigList, compressedList, outBitmap);

				/*
				int compressedsize = compressedList.size() * sizeof(POLY);
				warnx << "compressedList size (bytes): " << compressedsize << "\n";
				warnx << "compressedList.size(): " << compressedList.size() << "\n";

				int bitmapsize = 0;
				for (int i = 0; i < (int)outBitmap.size(); i++) {
					bitmapsize += (outBitmap[i].size() * sizeof(unsigned char));
				}

				warnx << "outBitmap size (bytes): " << bitmapsize << "\n";
				warnx << "outBitmap.size(): " << outBitmap.size() << "\n";

				warnx << "total compressed size (list+bitmap): " << compressedsize + bitmapsize << "\n";
				*/

				// after merging, everything is stored in totalT[0][0]
				makeKeyValue(&value, valLen, key, key, compressedList, outBitmap, freqList, weightList, txseq.back(), BCASTC);
			} else {
				makeKeyValue(&value, valLen, key, key, totalT[0][0], txseq.back(), BCAST);
			}

			totaltxmsglen += valLen;
			roundtxmsglen += valLen;
			status = insertDHT(ID, value, valLen, instime, MAXRETRIES);
			cleanup(value);

			// do not exit if insert FAILs!
			if (status != SUCC) {
				warnx << "error: insert FAILed\n";
			} else {
				warnx << "insert SUCCeeded\n";
			}

			warnx << "roundtxmsglen: " << roundtxmsglen;
			warnx << " txseq: " << txseq.back() << "\n";
			roundtxmsglen = 0;
			txseq.push_back(txseq.back() + 1);
			warnx << "sleeping (broadcast)...\n";
			gossipsleep = 0;
			delaycb(gintval, 0, wrap(gossipsleepnow));
			while (gossipsleep == 0) acheck();
		}
		// TODO: merge all lists
		warnx << "totalT.size(): " << totalT.size() << "\n";
		for (int i = 0; i < (int)totalT.size(); i++) {
			warnx << "totalT[i].size(): " << totalT[i].size() << "\n";
		}
		printteamids();
		warnx << "done broadcasting\n";
		time(&rawtime);
		warnx << "stop exec ctime: " << ctime(&rawtime);
		warnx << "stop exec sincepoch: " << time(&rawtime) << "\n";
		endgossipTime = getgtod();    

		printdouble("broadcast exec phase time: ", endgossipTime - begingossipTime);
		warnx << "\n";
	// VanillaXGossip exec phase
	} else if (gflag == 1 && Hflag == 0) {
		warnx << "vanillaxgossip exec...\n";
		warnx << "gossip interval: " << gintval << "\n";
		warnx << "interval b/w inserts: " << initintval << "\n";
		time(&rawtime);
		warnx << "start exec ctime: " << ctime(&rawtime);
		warnx << "start exec sincepoch: " << time(&rawtime) << "\n";

		begingossipTime = getgtod();    

		// needed?
		srandom(loseed);

		while (1) {
			// by default, gossip indefinitely (unless "rounds" is set)
			// print this only once
			if (txseq.back() == rounds && gossipdone == false) {
				warnx << "txseq = " << rounds << "\n";
				warnx << "totaltxmsglen: " << totaltxmsglen << "\n";
				warnx << "done gossiping\n";
				gossipdone = true;
				time(&rawtime);
				warnx << "stop exec ctime: " << ctime(&rawtime);
				warnx << "stop exec sincepoch: " << time(&rawtime) << "\n";
				endgossipTime = getgtod();    

				printdouble("vanillaxgossip exec phase time: ", endgossipTime - begingossipTime);
				warnx << "\n";

				// don't break because you have to keep merging the received lists!
				//break;
				// don't exit since each peer will reach a particular round at a different time
				//return 0;
			}

			ID = make_randomID();
			strbuf z;
			z << ID;
			str key(z);
			beginTime = getgtod();    

			if (gossipdone == false) {
				// store everything in totalT[0]
				mergelists(totalT[0]);
			} else {
				// don't divide freq and weight by 2
				mergelists_nogossip(totalT[0]);
			}
			endTime = getgtod();    
			printdouble("merge lists time: ", endTime - beginTime);
			warnx << "\n";

			// don't print lists after gossip is done
			// (but print lists right after gossiping is done at "rounds")
			if (plist == 1 && (gossipdone == false || txseq.back() == rounds)) {
				printlist(totalT[0], 0, txseq.back());
				// TODO
				//lprintlist(totalT[0], 0, txseq.back());
			}

			if (gossipdone == false) {
				warnx << "inserting ";
				if (compress == 1) warnx << "VXGOSSIPC:\n";
				else warnx << "VXGOSSIP:\n";

				warnx << "txseq: " << txseq.back() << "\n";
				warnx << "txID: " << ID << "\n";

				if (compress == 1) {
					compressedList.clear();
					outBitmap.clear();
					sigList.clear();
					freqList.clear();
					weightList.clear();
					lfreqList.clear();
					lweightList.clear();
					vecomap2vec(totalT[0], 0, sigList, freqList, weightList);
					//vecomap2vec(totalT[0], 0, sigList, lfreqList, lweightList);

					int sigbytesize = 0;
					warnx << "sigs before compression:\n";
					for (int i = 0; i < (int)sigList.size(); i++) {
						sigbytesize += (sigList[i].size() * sizeof(POLY));
						//sig2str(sigList[i], sigbuf);
						//warnx << "sig[" << i << "]: " << sigbuf << "\n";
					}

					warnx << "sigList size (bytes): " << sigbytesize << "\n";
					warnx << "sigList.size() (unique): " << sigList.size() << "\n";
					compressSignatures(sigList, compressedList, outBitmap);

					int compressedsize = compressedList.size() * sizeof(POLY);
					warnx << "compressedList size (bytes): " << compressedsize << "\n";
					warnx << "compressedList.size(): " << compressedList.size() << "\n";

					int bitmapsize = 0;
					for (int i = 0; i < (int)outBitmap.size(); i++) {
						bitmapsize += (outBitmap[i].size() * sizeof(unsigned char));
					}

					warnx << "outBitmap size (bytes): " << bitmapsize << "\n";
					warnx << "outBitmap.size(): " << outBitmap.size() << "\n";

					warnx << "total compressed size (list+bitmap): " << compressedsize + bitmapsize << "\n";

					// after merging, everything is stored in totalT[0][0]
					makeKeyValue(&value, valLen, key, key, compressedList, outBitmap, freqList, weightList, txseq.back(), VXGOSSIPC);
				} else {
					makeKeyValue(&value, valLen, key, key, totalT[0][0], txseq.back(), VXGOSSIP);
				}

				totaltxmsglen += valLen;
				roundtxmsglen += valLen;
				status = insertDHT(ID, value, valLen, instime, MAXRETRIES);
				cleanup(value);

				// do not exit if insert FAILs!
				if (status != SUCC) {
					warnx << "error: insert FAILed\n";
					// to preserve mass conservation:
					// "send" msg to yourself (double freq)
					multiplyfreq(totalT[0], 0, 2, 2);
				} else {
					warnx << "insert SUCCeeded\n";
				}
			}
			warnx << "roundtxmsglen: " << roundtxmsglen;
			warnx << " txseq: " << txseq.back() << "\n";
			roundtxmsglen = 0;
			txseq.push_back(txseq.back() + 1);
			warnx << "sleeping (vanillaxgossip)...\n";
			gossipsleep = 0;
			delaycb(gintval, 0, wrap(gossipsleepnow));
			while (gossipsleep == 0) acheck();
		}
	// XGossip exec phase
	} else if (Hflag == 1 && Eflag == 1) {
		// load sigs and teams from log.init into memory
		if (Pflag == 1) {
			warnx << "state: loading from init file...\n";
			// TODO: what if some peer starts gossiping before this?
			loadinitstate(initfp);
			if (plist == 1) {
				printlistall();
			}
		} else if (sflag == 1) {
			warnx << "state: signature files\n";
		} else if (Iflag != 1 || Eflag != 1) {
			fatal << "state: none available\n";
		} else {
			warnx << "state: init phase\n";
		}

		warnx << "xgossip exec...\n";
		warnx << "gossip interval: " << gintval << "\n";
		warnx << "interval b/w inserts: " << initintval << "\n";
		time(&rawtime);
		warnx << "start exec ctime: " << ctime(&rawtime);
		warnx << "start exec sincepoch: " << time(&rawtime) << "\n";

		begingossipTime = getgtod();    

		// needed?
		//srandom(loseed);

		while (1) {
			// by default, gossip indefinitely (unless "rounds" is set)
			// print this only once
			if (txseq.back() == rounds && gossipdone == false) {
				warnx << "txseq = " << rounds << "\n";
				warnx << "totaltxmsglen: " << totaltxmsglen << "\n";
				warnx << "done gossiping\n";
				gossipdone = true;
				time(&rawtime);
				warnx << "stop exec ctime: " << ctime(&rawtime);
				warnx << "stop exec sincepoch: " << time(&rawtime) << "\n";
				endgossipTime = getgtod();    

				printdouble("xgossip exec phase time: ", endgossipTime - begingossipTime);
				warnx << "\n";

				// don't break because you have to keep merging the received lists!
				//break;
				// don't exit since each peer will reach a particular round at a different time!
				//return 0;
			}

			beginTime = getgtod();    
			warnx << "totalT.size(): " << totalT.size() << "\n";
			for (int i = 0; i < (int)totalT.size(); i++) {
				warnx << "merging totalT[" << i << "]\n";
				if (gossipdone == false) {
					mergelists(totalT[i]);
				} else {
					// don't divide freq and weight by 2
					mergelists_nogossip(totalT[i]);
				}
			}
			endTime = getgtod();    
			printdouble("merge lists time: ", endTime - beginTime);
			warnx << "\n";
			//delspecial(0);
			// don't print lists after gossip is done
			// (but print lists right after gossiping is done at "rounds")
			if (plist == 1 && (gossipdone == false || txseq.back() == rounds)) {
				printlistall(txseq.back());
			}
		
			if (gossipdone == false) {
				if (mflag == 1) {
					fatal << "not implemented\n";
				// use compute_hash()
				} else {
					for (int i = 0; i < (int)totalT.size(); i++) {
						// TODO: needed?
						if (gflag == 1) {
							warnx << "inserting ";
							if (compress == 1) warnx << "XGOSSIPC:\n";
							else warnx << "XGOSSIP:\n";

							warnx << "txseq: " << txseq.back() << "\n";

							teamID = findteamid(i);
							if (teamID == NULL) {
								warnx << "xgossip: teamID is NULL\n";
								continue;
							}
							warnx << "teamID(" << i << "): " << teamID << "\n";

							// TODO: check return status
							make_team(NULL, teamID, team);
							int range = team.size();
							// randomness verified
							int randcol = randomNumGenZ(range);
							ID = team[randcol];
							// TODO: check if p is succ(ID)
							//ID = (matrix.back())[randcol];
							warnx << "ID in randcol " << randcol << ": " << ID << "\n";
							strbuf t;
							strbuf p;
							t << ID;
							p << team[0];
							str key(t);
							str teamID(p);
							warnx << "txID: " << ID << "\n";

							if (compress == 1) {
								compressedList.clear();
								outBitmap.clear();
								sigList.clear();
								freqList.clear();
								weightList.clear();
								vecomap2vec(totalT[i], 0, sigList, freqList, weightList);

								int sigbytesize = 0;
								warnx << "sigs before compression:\n";
								for (int i = 0; i < (int)sigList.size(); i++) {
									sigbytesize += (sigList[i].size() * sizeof(POLY));
									//sig2str(sigList[i], sigbuf);
									//warnx << "sig[" << i << "]: " << sigbuf << "\n";
								}

								warnx << "sigList size (bytes): " << sigbytesize << "\n";
								warnx << "sigList.size() (unique): " << sigList.size() << "\n";
								compressSignatures(sigList, compressedList, outBitmap);

								int compressedsize = compressedList.size() * sizeof(POLY);
								warnx << "compressedList size (bytes): " << compressedsize << "\n";
								warnx << "compressedList.size(): " << compressedList.size() << "\n";

								int bitmapsize = 0;
								for (int i = 0; i < (int)outBitmap.size(); i++) {
									bitmapsize += (outBitmap[i].size() * sizeof(unsigned char));
								}

								warnx << "outBitmap size (bytes): " << bitmapsize << "\n";
								warnx << "outBitmap.size(): " << outBitmap.size() << "\n";

								warnx << "total compressed size (list+bitmap): " << compressedsize + bitmapsize << "\n";

								makeKeyValue(&value, valLen, key, teamID, compressedList, outBitmap, freqList, weightList, txseq.back(), XGOSSIPC);
							} else {
								makeKeyValue(&value, valLen, key, teamID, totalT[i][0], txseq.back(), XGOSSIP);
							}

							totaltxmsglen += valLen;
							roundtxmsglen += valLen;

							status = insertDHT(ID, value, valLen, instime, MAXRETRIES);
							cleanup(value);
							// don't forget to clear team list!
							team.clear();

							// do not exit if insert FAILs!
							if (status != SUCC) {
								warnx << "error: insert FAILed\n";
								// to preserve mass conservation:
								// "send" msg to yourself
								// (double freq)
								multiplyfreq(totalT[i], 0, 2, 2);
							} else {
								warnx << "insert SUCCeeded\n";
							}

							warnx << "sleeping (groups)...\n";
							//sleep(initintval);
							groupsleep = 0;
							delaycb(initintval, 0, wrap(groupsleepnow));
							while (groupsleep == 0) acheck();
						} else {
							return 0;
						}
					}
				}
			}
			warnx << "roundtxmsglen: " << roundtxmsglen;
			warnx << " txseq: " << txseq.back() << "\n";
			roundtxmsglen = 0;
			txseq.push_back(txseq.back() + 1);

			if ((killme == true) && (killround == txseq.back())) {
				warnx << "killing Chord processes...\n";
				cmd = "kill -ABRT `cat " + std::string(rootdir) + "/pid.syncd`";
				system(cmd.c_str());
				cmd = "kill -ABRT `cat " + std::string(rootdir) + "/pid.lsd`";
				system(cmd.c_str());
				cmd = "kill -ABRT `cat " + std::string(rootdir) + "/pid.adbd`";
				system(cmd.c_str());
				warnx << "exiting gpsi...\n";
				return 0;
			}

			warnx << "sleeping (xgossip)...\n";
			gossipsleep = 0;
			delaycb(gintval, 0, wrap(gossipsleepnow));
			while (gossipsleep == 0) acheck();
		}
	} else if (Qflag == 1) {
		//initintval = 1;
		warnx << "interval b/w inserts: " << initintval << "\n";
		warnx << "querying ";
		beginTime = getgtod();
		// VanillaXGossip
		if (vanilla == true) {
			// xpath: querysig
			if (xflag == 1 && Oflag == 0) {
				warnx << "using xpath...\n";
				vanillaquery(queryMap, initintval, QUERYX);
			// sig: regularsig
			} else {
				warnx << "using sig...\n";
				warnx << "not implemented\n";
				//sig(allT, initintval, QUERYS);
			}
		// XGossip
		} else {
			// xpath: LSH(proxysig)
			if (xflag == 1 && Oflag == 1) {
				warnx << "using xpath, LSH(proxysig)...\n";
				lshquery(queryMap, initintval, QUERYXP);
			// xpath: LSH(querysig)
			} else if (xflag == 1 && Oflag == 0) {
				warnx << "using xpath, LSH(querysig)...\n";
				lshquery(queryMap, initintval, QUERYX);
			// sig: LSH(regularsig)
			} else {
				warnx << "using sig, LSH(sig)...\n";
				lshsig(allT, initintval, QUERYS);
			}
		}
		endTime = getgtod();    
		printdouble("query time: ", endTime - beginTime - initintval);
		warnx << "\n";

		return 0;
	} else if (Mflag == 1) {
		int range;
		int randcol;
		int avgid;
		warnx << "action: merging ";
		getdir(initdir, initfiles);
		acc = "r";
		if (mergetype == INIT) {
			warnx << "init files...\n";
			int nlists = 0;
			int zerofiles = 0;
			int totallists = 0;
			warnx << "loading files...\n";
			beginTime = getgtod();    
			for (unsigned int i = 0; i < initfiles.size(); i++) {
				//warnx << "file: " << initfiles[i].c_str() << "\n";
				if ((initfp = fopen(initfiles[i].c_str(), acc.c_str())) == NULL) {
					warnx << "can't open init file" << initfiles[i].c_str() << "\n";
					continue;
				}
				nlists = loadinitstate(initfp);
				if (nlists == 0) ++zerofiles;
				totallists += nlists;
				fclose(initfp);
			}
			endTime = getgtod();    
			printdouble("loading files time: ", endTime - beginTime);
			warnx << "\n";

			beginTime = getgtod();    
			warnx << "total lists added: " << totallists << "\n";
			warnx << "total 0-sized init files: " << zerofiles << "\n";
			warnx << "totalT.size(): " << totalT.size() << "\n";
			if (plist == 1) {
				warnx << "teamids (before merging)\n";
				printteamids();
				warnx << "lists (before merging)\n";
				printlistall();
			}

 			// do not do it! why?
			// put everything in allT[0]
			/*
			warnx << "merging by teamID into allT[0]...\n";
			mergebyteamid();

			if (plist == 1) {
				warnx << "teamids (after merging by teamID)\n";
				printteamids();
				warnx << "lists (after merging by teamID)\n";
				printlistall();
			}
			*/

			allT.clear();
			// put everything in allT[0]
			warnx << "merging everything into allT[0]...\n";
			mergeinit();

			if (plist == 1) {
				printlist(allT, 0, -1);
			}

			/*
			for (int i = 0; i < (int)totalT.size(); i++) {
				mergelists(totalT[i]);
			}
			*/
			endTime = getgtod();    
			printdouble("merge init lists time: ", endTime - beginTime);
			warnx << "\n";
			/*
			if (plist == 1) {
				warnx << "teamids (after merging)\n";
				printteamids();
				warnx << "lists (after merging)\n";
				printlistall();
			}
			*/
		} else if (mergetype == RESULTS) {
			bool multi = false;
			int estsigmatches = 0;
			int truesigmatches = 0;
			int ninter = 0;
			int proxylshmisses = 0;
			int querylshmisses = 0;
			int qid;
			double totalninter = 0;
			double estfreq = 0;
			double estmaxfreq = 0;
			double truefreq = 0;
			double relerror = 0;
			double maxrelerror = 0;
			//double estcursim;
			//double estminsim = 1;
			double trueminsim = 0;
			double trueavgsim = 0;
			std::string dtd;
			std::vector<chordID> proxylshIDs;
			std::vector<chordID> querylshIDs;
			std::vector<chordID> resultlshIDs;
			proxysig.clear();
			querysig.clear();
			proxylshIDs.clear();
			querylshIDs.clear();
			resultlshIDs.clear();
			//mapType uniqueSigList;
			//allT.clear();
			//allT.push_back(uniqueSigList);

			warnx << "results files...\n";
			warnx << "loading files...\n";
			beginTime = getgtod();    
			for (unsigned int i = 0; i < initfiles.size(); i++) {
				//warnx << "file: " << initfiles[i].c_str() << "\n";
				if ((initfp = fopen(initfiles[i].c_str(), acc.c_str())) == NULL) {
					warnx << "can't open results file" << initfiles[i].c_str() << "\n";
					continue;
				}
				warnx << initfiles[i].c_str() << "\n";
				if (loadresults(initfp, msgtype) == -1) warnx << "loadresults failed\n";
				fclose(initfp);
			}
			endTime = getgtod();    
			printdouble("loading files time: ", endTime - beginTime);
			warnx << "\n";

			if (msgtype == QUERYX || msgtype == QUERYXP) {
				// from now on, work only with totalT
				totalT.push_back(allT);
				int tind = 0;
				// TODO: make cmd line arg?
				bool lshmisses = true;

				warnx << "calculating xpath query estimates and true results...\n";
				warnx << "qid,querysig,sigmatches: est,sigmatches: true,sigmatches: rel error (%),freq (*teamsize): est,freq max (*teamsize): est,freq (*instances): true,freq: rel error (%),freq max: rel error (%),proxy lsh misses,query lsh misses,avg inter,query minsim,query avgsim,proxy minsim,proxy avgsim,query minsim > proxy minsim,teamIDs\n";
				for (id2sigs::iterator qitr = qid2querysig.begin(); qitr != qid2querysig.end(); qitr++) {
					if (qitr->second.size() > 1)
						warnx << "multiple queries for the same qid\n";

					qid = qitr->first;
					querysig = qitr->second[0];

					// find DTD
					id2strings::iterator ditr = qid2dtd.find(qid);
					if (ditr != qid2dtd.end()) {
						// TODO: assume 1 dtd per qid?
						dtd = ditr->second.back();
						//warnx << "found DTD\n";
					} else {
						// TODO: what to do?
						warnx << "no DTD found for qid: " << qid << "\n";
						dtd.clear();
					}

					if (msgtype == QUERYXP) {
						// find proxy sig
						string2sigs::iterator pitr = dtd2proxysigs.find(dtd);
						if (pitr != dtd2proxysigs.end()) {
							// TODO: assume 1 sig per DTD?
							proxysig = pitr->second.back();
							//warnx << "found proxysig\n";
						} else {
							// TODO: what to do?
							warnx << "no proxy sig found for DTD: " << dtd.c_str() << "\n";
							proxysig.clear();
						}
						proxylshIDs.clear();
						proxylshIDs = run_lsh(proxysig);
						//warnx << "run_lsh ran succuessfully\n";
					} else if (msgtype == QUERYX) {
						querylshIDs.clear();
						querylshIDs = run_lsh(querysig);
					}

					// find sigs which match this qid
					id2sigs::iterator sitr = qid2sigs.find(qid);
					if (sitr != qid2sigs.end()) {
						//warnx << "found sigs for qid: " << qid << "\n";
						// add up avg of different sigs and pick a random avg for same one
						for (int i = 0; i < (int)sitr->second.size(); i++) {
							// find id corresponding to this qid in allsig2avg
							id2id::iterator iditr = qid2id.find(qid);
							if (iditr != qid2id.end()) {
								avgid = iditr->second;
								//warnx << "found id for qid: " << qid << "\n";
							} else {
								warnx << "qid2id: can't find qid: " << qid << "\n";
								continue;
							}

							// find vector<avg> of the sig in the sig2avg map for this qid
							mapType::iterator saitr = allsig2avg[avgid].find(sitr->second[i]);
							if (saitr != allsig2avg[avgid].end()) {
								//warnx << "found avg\n";
								range = saitr->second.size();
								// TODO: verify range
								// pick random avg for that sig
								randcol = randomNumGenZ(range);
								//warnx << "sig2avg: range: " << range << " randcol: " << randcol << "\n";
								estfreq += saitr->second[randcol];

								// find max freq
								double maxavg = 0;
								for (int j = 0; j < (int)saitr->second.size(); j++) {
									if (maxavg < saitr->second[j])	
										maxavg = saitr->second[j];
								}
								estmaxfreq += maxavg;
								++estsigmatches;
							} else {
								warnx << "allsig2avg: where is the sig\n";
								continue;
							}

							// find minimum similarity b/w query and results
							/*
							estcursim = signcmp(querysig, sitr->second[i], multi);
							if (estminsim > estcursim)
								estminsim = estcursim;
							*/

							// run lsh on sig result
							if (lshmisses == true) {
								resultlshIDs.clear();
								resultlshIDs = run_lsh(sitr->second[i]);

								if (msgtype == QUERYXP) {
									// TODO: use set_inter_noskip() instead?
									ninter = set_inter(proxylshIDs, resultlshIDs, multi);
									totalninter += ninter;
									//warnx << "ninter: " << ninter << " multi: " << multi << "\n";
									if (ninter == 0) {
										//warnx << "lsh proxy sig miss\n";
										++proxylshmisses;
									}
								} else if (msgtype == QUERYX) {
									ninter = set_inter(querylshIDs, resultlshIDs, multi);
									totalninter += ninter;
									if (ninter == 0) {
										//warnx << "lsh query sig miss\n";
										++querylshmisses;
									}
								}
							}
						}
					} else {
						//warnx << "qid2sigs: can't find sigs for qid: " << qid << "\n";
					}

					// qid
					warnx << qid << ",";

					// querysig
					sig2str(querysig, sigbuf);
					warnx << sigbuf << ",";

					// get true result
					truesigmatches = 0;
					truefreq = 0;
					trueminsim = 0;
					trueavgsim = 0;

					if (msgtype == QUERYXP) {
						useproxy = true;
						gproxysig = proxysig;
					}

					// be careful with default arguments! (specify teamID)
					run_query(tind, querysig, truesigmatches, truefreq, trueminsim, trueavgsim, msgtype, 0, useproxy);

					// est sigmatches
					// don't multiply by teamsize!
					warnx << estsigmatches << ",";

					// true sigmatches
					// don't multiply by the number of instances!
					warnx << truesigmatches << ",";

					// sigmatches rel error
					if (truesigmatches != 0) {
						relerror = (double)(fabs((double)truesigmatches - estsigmatches) / truesigmatches) * 100;
					} else {
						relerror = 0;
					}
					printdouble("", relerror);
					warnx << ",";

					// est freq
					estfreq *= teamsize;
					printdouble("", estfreq);
					warnx << ",";

					// est max freq
					estmaxfreq *= teamsize;
					printdouble("", estmaxfreq);
					warnx << ",";

					// true totalfreq
					truefreq *= ninstances;
					printdouble("", truefreq);
					warnx << ",";

					// freq rel error
					if (truefreq != 0) {
						relerror = fabs(truefreq - estfreq) / truefreq * 100;
					} else {
						relerror = 0;
					}
					printdouble("", relerror);
					warnx << ",";

					// max freq rel error
					if (truefreq != 0) {
						maxrelerror = fabs(truefreq - estmaxfreq) / truefreq * 100;
					} else {
						maxrelerror = 0;
					}
					printdouble("", maxrelerror);
					warnx << ",";

					// proxy lsh misses
					warnx << proxylshmisses << ",";

					// query lsh misses
					warnx << querylshmisses << ",";

					// avg inter
					printdouble("", totalninter / mgroups);
					warnx << ",";

					// est minsim 
					//printdouble("", estminsim);
					//warnx << ",";

					// query minsim 
					printdouble("", trueminsim);
					warnx << ",";

					// query avgsim 
					printdouble("", trueavgsim);
					warnx << ",";

					// proxy minsim 
					printdouble("", proxyminsim);
					warnx << ",";

					// proxy avgsim 
					printdouble("", proxyavgsim);
					warnx << ",";

					// query minsim > proxy minsim
					if (trueminsim > proxyminsim)
						warnx << "y,";
					else
						warnx << "n,";

					// print teamIDs
					id2chordIDs::iterator titr = qid2teamIDs.find(qid);
					if (titr != qid2teamIDs.end()) {
						//warnx << "qid2teamIDs: qid: " << qid << " teamIDs: " << titr->second.size() << "\n";
						for (int i = 0; i < (int)titr->second.size(); i++ ) {
							warnx << titr->second[i] << ",";
						}
					} else {
						warnx << "qid2teamIDs: can't find teamIDs for qid: " << qid << "\n";
					}

					warnx << "\n";

					// print LSH() output when error is high
					if (relerror > errorlimit) {
						if (msgtype == QUERYXP) {
							warnx << proxylshIDs.size() << ",";
							for (int i = 0; i < (int)proxylshIDs.size(); i++) {
								warnx << proxylshIDs[i] << ",";
							}
						} else if (msgtype == QUERYX) {
							warnx << querylshIDs.size() << ",";
							for (int i = 0; i < (int)querylshIDs.size(); i++) {
								warnx << querylshIDs[i] << ",";
							}
						}
						warnx << "\n";

						warnx << resultlshIDs.size() << ",";
						for (int i = 0; i < (int)resultlshIDs.size(); i++) {
							warnx << resultlshIDs[i] << ",";
						}
						warnx << "\n";
					}

					//estminsim = 0;
					estsigmatches = 0;
					estfreq = 0;
					estmaxfreq = 0;
					proxylshmisses = 0;
					querylshmisses = 0;
					totalninter = 0;
					// very important!
					proxylshIDs.clear();
					querylshIDs.clear();
					resultlshIDs.clear();
				}
			// TODO:
			// decide where to put querysigs and sigs: allT[?], totalT[?][?]
			// call run_query()
			} else if (msgtype == QUERYS) {
				listnum = 0;
				int sid = 1;
				warnx << "sig query results...\n";
				warnx << "id,querysig,freq: est,freq (*teamsize): est\n";
				for (mapType::iterator itr = allT[listnum].begin(); itr != allT[listnum].end(); itr++) {
					warnx << sid << ",";
					sig2str(itr->first, sigbuf);
					warnx << sigbuf << ",";
					estfreq = itr->second[0]/itr->second[1];
					printdouble("", estfreq);
					warnx << ",";
					printdouble("", estfreq * teamsize);
					warnx << "\n";
					++sid;
				}
			} else {
				warnx << "error: invalid msgtype\n";
			}
		}
		return 0;
	// don't exit if listening
	} else if (lflag == 1) {
		warnx << "\n";
	} else if (rflag == 1 || Hflag == 1) {
		return 0;
	} else {
		usage();
	}

	amain();
	return 0;
}

// copied from psi.C
DHTStatus
insertDHT(chordID ID, char *value, int valLen, double &instime, int STOPCOUNT, chordID guess)
{
	//warnx << "txID: " << ID << "\n";
	dataStored += valLen;
	int numTries = 0;
		
	// Make sure the guess is a successor of ID
	if (guess < ID) {
		if (maxID - ID + guess < ID - guess) {
		// nothing	
		} else {
			guess = 0;
		}
	} else {
		if (maxID - guess + ID < guess - ID) {
			guess = 0;	
		}
	}

	do {    
		out = 0;
		insertError = false;
		insertStatus = SUCC;
		double beginTime = getgtod();    

		if (guess > 0) {
			ptr<option_block> options = New refcounted<option_block>();
			options->flags = DHASHCLIENT_GUESS_SUPPLIED;
			options->guess = guess;
			dhash->insert(ID, (char *) value, valLen, wrap(store_cb), options, DHASH_NOAUTH);
		} else {
			dhash->insert(ID, (char *) value, valLen, wrap(store_cb), NULL, DHASH_NOAUTH);
		}

		while (out == 0) acheck();
		double endTime = getgtod();
		// XXX
		//char timebuf[1024];
		//snprintf(timebuf, sizeof(timebuf), "%f", endTime - beginTime);
		//warnx << "key insert time: " << timebuf << " secs\n";
		instime = endTime - beginTime;
		printdouble("key insert time: ", instime);
		warnx << "\n";
		// Insert was successful
		if (!insertError) {
			return insertStatus;
		}
		numTries++;
		warnx << "numTries: " << numTries << "\n";
		 
		if (insertError && numTries == STOPCOUNT) {
			warnx << "Error during INSERT operation...\n";
			return FAIL;
		}
					
		// If error then don't use guess
		//guess = 0;

		//warnx << "Sleeping 10 seconds...\n";
		//sleep(10);
	} while (insertError);

	return insertStatus;
}

// copied from psi.C
void
retrieveDHT(chordID keyID, int MAXWAIT, str& sigdata, chordID guess)
{
	if (((keyID >> 32) << 32) == 0) {
		warnx << "Bad node id... Skipping retrieve...\n";
		retrieveError = true;
		return;
	}

	// Make sure the guess is a successor of keyID
	if (guess < keyID) {
		guess = 0;
	}
	nodeEntries.clear();
	// now fetch the node
	out = 0;
	retrieveError = false;
	//warnx << "Retrieve: " << keyID << " " << sigdata << "\n";	
	//warnx << "Retrieve: " << keyID << "\n";
	double beginTime = getgtod();
	if (guess > 0) {
		ptr<option_block> options = New refcounted<option_block>();
		options->flags = DHASHCLIENT_GUESS_SUPPLIED;
		options->guess = guess;
		dhash->retrieve(keyID, DHASH_NOAUTH, wrap(fetch_cb), sigdata, options);
	} else {
		dhash->retrieve(keyID, DHASH_NOAUTH, wrap(fetch_cb), sigdata);
	}
	//double retrieveBegin = getgtod();
	int numTries = 0;
	while (out == 0) {
		acheck();
		/*double retrieveEnd = getgtod();
		if (retrieveEnd - retrieveBegin > MAXWAIT) {
		    retrieveError = true;
            break;
        }*/
#ifdef _LIVE_
        if (numTries == MAXRETRIEVERETRIES) {
#else
		if (numTries == 20) {
#endif
			retrieveError = true;
			break;
		}
		numTries++;
	}
	double endTime = getgtod();
	std::cerr << "Retrieve time: " << endTime - beginTime << std::endl;

	// Extra check
	if (!retrieveError && nodeEntries.size() == 0) {
		warnx << "EMPTY contents...\n";
		retrieveError = true;
	}
	//warnx << "# of node entries: " << nodeEntries.size() << "\n";
}

// copied from psi.C
void
readValues(FILE *fp, std::multimap<POLY, std::pair<std::string, enum OPTYPE> >&valList)
{
    if (!fp) return;

    int num;
    if (fread(&num, sizeof(num), 1, fp) != 1) {
        assert(0);
    }

    for (int i = 0; i < num; i++) {
        POLY p;
        if (fread(&p, sizeof(p), 1, fp) != 1) {
            assert(0);
        }

        int size;
        if (fread(&size, sizeof(size), 1, fp) != 1) {
            assert(0);
        }

        char predVal[128];
        if (fread(predVal, size, 1, fp) != 1) {
            assert(0);
        }
        predVal[size] = 0;

        enum OPTYPE OP;
        if (fread(&OP, sizeof(OP), 1, fp) != 1) {
            assert(0);
        }

        std::pair<std::string, enum OPTYPE> e(std::string(predVal), OP);
        valList.insert(std::pair<POLY, std::pair<std::string, enum OPTYPE> >(p, e));
    }
}

// deprecated: use make_randomID() instead
chordID
randomID(void)
{
	char buf[16];
	int j;
	strbuf s;
	chordID ID;

	srand(time(NULL));
	//warnx << "j:  ";
	for (int i = 0; i < 40; i++) {
		//j = randomNumGen();
		j = rand() % 16;
		sprintf(buf, "%x", j);
		//warnx << buf;
		s << buf;
	}
	//warnx << "\n";
	//warnx << "s:  " << s << "\n";
	str t(s);
	//warnx << "t:  " << t << "\n";
	//warnx << "len: " << t.len() << "\n";
	str2chordID(t, ID);
	return ID;
}

// verified
void
listengossip(void)
{
	unlink(gsock);
	int fd = unixsocket(gsock);
	if (fd < 0) fatal << "listen: error creating socket: " << strerror(errno) << "\n";

	// make socket non-blocking
	make_async(fd);

	if (listen(fd, MAXCONN) < 0) {
		// TODO: what's %m?
		fatal("listen: error listening: %m\n");
		close(fd);
		++closefd;
	} else {
		fdcb(fd, selread, wrap(acceptconn, fd));
	}
}

// verified
void
acceptconn(int lfd)
{
	sockaddr_un sun;
	bzero(&sun, sizeof(sun));
	socklen_t sunlen = sizeof(sun);

	//int cs = accept(lfd, (struct sockaddr *) &sin, &sinlen);
	int cs = accept(lfd, reinterpret_cast<sockaddr *> (&sun), &sunlen);
	if (cs >= 0) {
		warnx << "accept: connection on local socket: cs=" << cs << "\n";
		++openfd;
	//} else if (errno != EAGAIN) {
	} else {
		warnx << "accept: error accepting: " << strerror(errno) << "\n";
		// disable readability callback?
		fdcb(lfd, selread, NULL);
		return;
	}
	
	fdcb(cs, selread, wrap(readgossip, cs));
}

// TODO: verify xgossip part
void
readgossip(int fd)
{
	strbuf buf;
	strbuf totalbuf;
	str key;
	str keyteamid;
	str dtdstr;
	str sigbuf;
	chordID ID;
	chordID teamID;
	std::vector<std::vector<POLY> > sigList;
	std::vector<double> freqList;
	std::vector<double> weightList;
	InsertType msgtype;
	std::vector<POLY> sig;
	std::vector<POLY> querysig;
	std::vector<POLY> compressedList;
	std::vector<std::vector<unsigned char> > outBitmap;
	double freq, weight, totalavg, minsim, avgsim;
	int n, msglen, recvlen, nothing, tind, ninter, qid, sigmatches;
	int ret, seq;
	int numSigs;
	bool multi;

	ninter = msglen = recvlen = nothing = 0;
	minsim = avgsim = 0;
	multi = 0;
	qid = -1;
	warnx << "reading from socket:\n";

	do {
		n = buf.tosuio()->input(fd);

		if (n < 0) {
			warnx << "readgossip: read failed\n";
			fdcb(fd, selread, NULL);
			close(fd);
			++closefd;
			return;
		}

		// EOF
		if (n == 0) {
			warnx << "readgossip: recvlen=" << recvlen << "\n";
			warnx << "readgossip: nothing received\n";
			fdcb(fd, selread, NULL);
			return;
			/*
			++nothing;
			if (nothing == 5) {
				warnx << "readgossip: giving up\n";
				fdcb(fd, selread, NULL);
				close(fd);
				++closefd;
				return;
			}
			continue;
			*/
		}

		// run 1st time only
		if (msglen == 0) {
			str gbuf = buf;
			msglen = getKeyValueLen(gbuf);
			warnx << "rxmsglen: " << msglen;
		}

		recvlen += n;

#ifdef _DEBUG_
		warnx << "\nreadgossip: n=" << n << "\n";
		warnx << "readgossip: recvlen=" << recvlen << "\n";
#endif

		totalbuf << buf;
		buf.tosuio()->clear();

	} while (recvlen < msglen);

	str gmsg(totalbuf);
	sigList.clear();
	freqList.clear();
	weightList.clear();

	msgtype = getKeyValueType(gmsg.cstr());
	warnx << " type: ";
	if (msgtype == VXGOSSIP || msgtype == VXGOSSIPC || msgtype == XGOSSIP || msgtype == XGOSSIPC || msgtype == BCAST || msgtype == BCASTC) {
		// discard msg if in init phase
		if (initphase == true) {
			warnx << "warning: phase=init, msgtype=" << msgtype << "\n";
			warnx << "warning: msg discarded\n";
			return;
		} else if (msgtype == BCAST) {
			warnx << "BCAST";
			ret = getKeyValue(gmsg.cstr(), key, keyteamid, sigList, freqList, weightList, seq, recvlen);
		} else if (msgtype == BCASTC) {
			warnx << "BCASTC";
			ret = getKeyValue(gmsg.cstr(), key, keyteamid, compressedList, outBitmap, numSigs, freqList, weightList, seq, recvlen);
			uncompressSignatures(sigList, compressedList, outBitmap, numSigs);
		} else if (msgtype == VXGOSSIP) {
			warnx << "VXGOSSIP";
			ret = getKeyValue(gmsg.cstr(), key, keyteamid, sigList, freqList, weightList, seq, recvlen);
		} else if (msgtype == VXGOSSIPC) {
			warnx << "VXGOSSIPC";
			ret = getKeyValue(gmsg.cstr(), key, keyteamid, compressedList, outBitmap, numSigs, freqList, weightList, seq, recvlen);
			uncompressSignatures(sigList, compressedList, outBitmap, numSigs);
		} else if (msgtype == XGOSSIP) {
			warnx << "XGOSSIP";
			ret = getKeyValue(gmsg.cstr(), key, keyteamid, sigList, freqList, weightList, seq, recvlen);
		} else {
			warnx << "XGOSSIPC";
			ret = getKeyValue(gmsg.cstr(), key, keyteamid, compressedList, outBitmap, numSigs, freqList, weightList, seq, recvlen);
			uncompressSignatures(sigList, compressedList, outBitmap, numSigs);
		}

		if (ret == -1) {
			warnx << "error: getKeyValue failed\n";
			fdcb(fd, selread, NULL);
			close(fd);
			++closefd;
			return;
		}

		warnx << " rxlistlen: " << sigList.size()
		      << " rxseq: " << seq
		      << " txseq-cur: " << txseq.back()
		      << " rxID: " << key;

		if (msgtype == BCAST || msgtype == BCASTC || msgtype == XGOSSIP || msgtype == XGOSSIPC) warnx << " teamID: " << keyteamid;

		warnx  << "\n";

		warnx << "freqList.size(): " << freqList.size() << "\n";;
		warnx << "weightList.size(): " << weightList.size() << "\n";

		// count rounds off by one
		n = seq - txseq.back();
		if (n < 0) {
			warnx << "warning: rxseq<txseq n: " << abs(n) << "\n";
			if (discardmsg == 1) {
				if (abs(n) != 1) {
					warnx << "warning: msg discarded\n";
					return;
				}
			}
		} else if (n > 0) {
			warnx << "warning: rxseq>txseq n: " << n << "\n";
			if (discardmsg == 1) {
				if (n != 1) {
					warnx << "warning: msg discarded\n";
					return;
				}
			}
		}

#ifdef _DEBUG_
		for (int i = 0; i < (int) sigList.size(); i++) {
			sig2str(sigList[i], sigbuf);
			//if (validsig(sigList[i]) == false) warnx << "warning: invalid signature\n";
			warnx << "sig[" << i << "]: " << sigbuf << "\n";
		}
		for (int i = 0; i < (int) freqList.size(); i++) {
			warnx << "freq[" << i << "]: ";
			printdouble("", freqList[i]);
			warnx << "\n";
		}
		for (int i = 0; i < (int) weightList.size(); i++) {
			warnx << "weight[" << i << "]: ";
			printdouble("", weightList[i]);
			warnx << "\n";
		}
#endif

		rxseq.push_back(seq);
		str2chordID(keyteamid, teamID);
		if (msgtype == VXGOSSIP || msgtype == VXGOSSIPC) {
			add2vecomapv(sigList, freqList, weightList);
		} else if (msgtype == BCAST || msgtype == BCASTC) {
			// TODO: addvecomapx() and merge
		// both XGossip and Broadcast use teamID
		} else {
			add2vecomapx(sigList, freqList, weightList, teamID);
		}
	} else if (msgtype == INITGOSSIP || msgtype == INFORMTEAM) {
		// discard msg if not in init phase
		if (initphase == false) {
			warnx << "warning: phase=exec, msgtype=" << msgtype << "\n";
			warnx << "warning: msg discarded\n";
			return;
		} else if (msgtype == INITGOSSIP) {
			warnx << "INITGOSSIP";
		} else {
			warnx << "INFORMTEAM";
		}

		sig.clear();
		ret = getKeyValue(gmsg.cstr(), key, keyteamid, sig, freq, weight, recvlen);
		if (ret == -1) {
			warnx << "error: getKeyValue failed\n";
			fdcb(fd, selread, NULL);
			close(fd);
			++closefd;
			return;
		}

		warnx << " rxID: " << key << "\n";
		warnx << " teamID: " << keyteamid << "\n";
		sig2str(sig, sigbuf);
		warnx << "rxsig: " << sigbuf;
		printdouble(" ", freq);
		printdouble(" ", weight);
		warnx << "\n";
		str2chordID(key, ID);
		str2chordID(keyteamid, teamID);
		initgossiprecv(ID, teamID, sig, freq, weight);
	} else if (msgtype == QUERYS || msgtype == QUERYX || msgtype == QUERYXP) {
		querysig.clear();
		if (msgtype == QUERYS) {
			warnx << "QUERYS";
			// TODO: do we need the freq/weight of the query sig?
			// TODO: add dtd
			ret = getKeyValue(gmsg.cstr(), key, keyteamid, querysig, freq, weight, recvlen);
		} else if (msgtype == QUERYX) {
			warnx << "QUERYX";
			ret = getKeyValue(gmsg.cstr(), key, keyteamid, dtdstr, querysig, qid, recvlen);
		} else {
			warnx << "QUERYXP";
			ret = getKeyValue(gmsg.cstr(), key, keyteamid, dtdstr, querysig, qid, recvlen);
		}

		if (ret == -1) {
			warnx << "error: getKeyValue failed\n";
			fdcb(fd, selread, NULL);
			close(fd);
			++closefd;
			return;
		}

		warnx << " rxID: " << key;
		warnx << " teamID: " << keyteamid << "\n";
		sig2str(querysig, sigbuf);

		// VanillaXGgossip
		if (vanilla == true) {
			warnx << "queryresult:";
			warnx << " vanilla"; 
			warnx << " qid: " << qid << " querysig: " << sigbuf;
			warnx << " DTD: " << dtdstr;
			warnx << " teamID: " << teamID << "\n";
			sigmatches = 0;
			totalavg = 0;
			// Vanilla uses index 0
			tind = 0;
			run_query(tind, querysig, sigmatches, totalavg, minsim, avgsim, msgtype);
			warnx << "queryresultend:";
			warnx << " rxqseq: " << rxqseq.back();
			warnx << " sigmatches: " << sigmatches;
			printdouble(" totalavg: ", totalavg);
			warnx << "\n";
			rxqseq.push_back(rxqseq.back() + 1);
		// XGossip
		} else {
			// find if list for team exists
			str2chordID(keyteamid, teamID);
			teamid2totalT::iterator teamitr = teamindex.find(teamID);
			if (teamitr != teamindex.end()) {
				tind = teamitr->second[0];
				warnx << "queryresult:";
				warnx << " teamID-found"; 
				//warnx << "teamID found at teamindex[" << tind << "]";
				warnx << " qid: " << qid << " querysig: " << sigbuf;
				warnx << " DTD: " << dtdstr;
				warnx << " teamID: " << teamID << "\n";
				sigmatches = 0;
				totalavg = 0;
				run_query(tind, querysig, sigmatches, totalavg, minsim, avgsim, msgtype);
				warnx << "queryresultend:";
				warnx << " rxqseq: " << rxqseq.back();
				warnx << " sigmatches: " << sigmatches;
				printdouble(" totalavg: ", totalavg);
				warnx << "\n";
				rxqseq.push_back(rxqseq.back() + 1);
			} else {
				// don't run query if this peer is not a part of the team
				/*
				warnx << "queryresult:";
				warnx << " teamID NOT found";
				warnx << " qid: " << qid << " querysig: " << sigbuf;
				warnx << " teamID: " << teamID << "\n";
				*/

				// run query even if this peer is not a part of the team
				warnx << "queryresult: ";
				warnx << "teamID-NOT-found";
				warnx << " qid: " << qid << " querysig: " << sigbuf;
				warnx << " DTD: " << dtdstr;
				warnx << " teamID: " << teamID << "\n";
				sigmatches = 0;
				totalavg = 0;
				for (int i = 0; i < (int)totalT.size(); i++) {
					teamID = findteamid(i);
					run_query(i, querysig, sigmatches, totalavg, minsim, avgsim, msgtype, teamID);
				}

				warnx << "queryresultend:";
				warnx << " rxqseq: " << rxqseq.back();
				warnx << " sigmatches: " << sigmatches;
				printdouble(" totalavg: ", totalavg);
				warnx << "\n";
				rxqseq.push_back(rxqseq.back() + 1);
			}

			// TODO: search other lists (not yet merged) for other sigs?
			/*
			mapType::iterator itr = allT[0].find(sig);
			if (itr != allT[0].end()) {
				freq = itr->second[0];
				weight = itr->second[1];
				warnx << " found\n";
				printdouble("f: ", freq);
				printdouble(", w: ", weight);
				printdouble(", avg: ", freq/weight);
				warnx << "\n";
			} else {
				warnx << " NOT found\n";
			}
			*/
		}
	} else {
		warnx << "error: invalid msgtype\n";
	}

	// always disable readability callback before closing a f*cking fd!
	warnx << "readgossip: done reading\n";
	fdcb(fd, selread, NULL);
	close(fd);
	++closefd;
}

// don't init sigmatches and totalavg!
int
run_query(int tind, std::vector<POLY> querysig, int &sigmatches, double &totalavg, double &minsim, double &avgsim, InsertType msgtype, chordID teamID, bool useproxy)
{
	bool multi;
	int ninter;
	double cursim;
	str sigbuf;

	// init to max value possible!
	minsim = 1;
	proxyminsim = 1;

	avgsim = 0;
	proxyavgsim = 0;

	// search for exact sig match
	if (msgtype == QUERYS) {
		mapType::iterator sigitr = totalT[tind][0].find(querysig);
		// exact signature found
		if (sigitr != totalT[tind][0].end()) {
			++sigmatches;
			totalavg += (sigitr->second[0]/sigitr->second[1]);
			if (plist == 1) {
				sig2str(sigitr->first, sigbuf);
				warnx << "exactsig: " << sigbuf;
				printdouble(" f: ", sigitr->second[0]);
				printdouble(" w: ", sigitr->second[1]);
				printdouble(" avg: ", sigitr->second[0]/sigitr->second[1]);
				// teamID is set only when running queries for "teamID-NOT-found"
				if (teamID != 0) warnx << " teamID: " << teamID;
				warnx << "\n";
			}
		}
	// search for superset
	} else if (msgtype == QUERYX || msgtype == QUERYXP) {
		// find if the query sig is a subset of any of the sigs
		for (mapType::iterator itr = totalT[tind][0].begin(); itr != totalT[tind][0].end(); itr++) {
			ninter = set_inter_noskip(querysig, itr->first, multi);
			//warnx << "ninter: " << ninter << ", querysig.size(): " << querysig.size() << "\n";
			if (ninter == (int)querysig.size()) {
				++sigmatches;
				totalavg += (itr->second[0]/itr->second[1]);

				// find minimum similarity b/w query and results
				cursim = signcmp(querysig, itr->first, multi);
				avgsim += cursim;
				if (minsim > cursim)
					minsim = cursim;

				// find minimum similarity b/w proxy sig and results
				if (useproxy == true) {
					cursim = signcmp(gproxysig, itr->first, multi);
					proxyavgsim += cursim;
					if (proxyminsim > cursim)
						proxyminsim = cursim;
				}

				if (plist == 1) {
					sig2str(itr->first, sigbuf);
					warnx << "supersetsig: " << sigbuf;
					printdouble(" f: ", itr->second[0]);
					printdouble(" w: ", itr->second[1]);
					printdouble(" avg: ", itr->second[0]/itr->second[1]);
					// teamID is set only when running queries for "teamID-NOT-found"
					if (teamID != 0) warnx << " teamID: " << teamID;
					warnx << "\n";
					//if (multi == 1) warnx << "superset sig is a multiset\n";
				}
			}
		}
	} else {
		warnx << "invalid msgtype: " << msgtype << "\n";
		return -1;
	}


	avgsim /= sigmatches;
	proxyavgsim /= sigmatches;

	return 0;
}

std::vector<chordID>
run_lsh(std::vector<POLY> sig)
{
	int col = 0;
	//int range, randcol;
	double beginTime, endTime;
	std::vector<POLY> lshsig;
	std::vector<chordID> minhash;

	beginTime = getgtod();    
	lsh *myLSH = new lsh(sig.size(), lfuncs, mgroups, lshseed, col, irrnums, hasha, hashb);
	endTime = getgtod();    
	//printdouble("run_lsh: lsh time: ", endTime - beginTime);
	//warnx << "\n";
	// convert multiset to set
	if (uflag == 1) {
		//sig2str(sig, sigbuf);
		//warnx << "multiset: " << sigbuf << "\n";
		lshsig = myLSH->getUniqueSet(sig);
		//sig2str(lshsig, sigbuf);
		//warnx << "set: " << sigbuf << "\n";
		minhash = myLSH->getHashCode(lshsig);
	} else {
		minhash = myLSH->getHashCode(sig);
	}

	sort(minhash.begin(), minhash.end());

	//warnx << "minhash.size(): " << minhash.size() << "\n";
	/*
	if (plist == 1) {
		warnx << "sig" << n << ": ";
		warnx << "minhash IDs: " << "\n";
		for (int i = 0; i < (int)minhash.size(); i++) {
			warnx << minhash[i] << "\n";
		}
	}
	*/

	//calcteamids(minhash);

	/*
	std::vector<chordID> team;
	chordID teamID, ID;
	team.clear();
	for (int i = 0; i < (int)minhash.size(); i++) {
		teamID = minhash[i];
		lshIDs.push_back(teamID);
		//warnx << "teamID: " << teamID << "\n";
		// TODO: check return status
		make_team(NULL, teamID, team);
		range = team.size();
		// randomness verified
		//randcol = randomNumGenZ(range-1);
		randcol = randomNumGenZ(range);
		ID = team[randcol];
		//warnx << "ID in randcol " << randcol << ": " << ID << "\n";
		lshIDs.push_back(ID);
	}
	*/

	delete myLSH;
	return minhash;
}

void
addqid(int qid, std::vector<POLY> querysig)
{
	// map querysig to qid:
	// store querysig in 1st position
	id2sigs::iterator qitr = qid2querysig.find(qid);
	if (qitr != qid2querysig.end()) {
		if (samesig(querysig, qitr->second[0]) != 1)
			warnx << "loadresults: different querysigs for the same qid\n";
	} else {
		qid2querysig[qid].push_back(querysig);
	}
}

bool
addteamID(int qid, chordID teamID)
{
	bool teamIDfound = 0;

	// map teamID to qid
	id2chordIDs::iterator titr = qid2teamIDs.find(qid);
	if (titr != qid2teamIDs.end()) {
		for (int i = 0; i < (int)titr->second.size(); i++) {
			if (teamID == titr->second[i]) {
				warnx << "loadresults: teamID already present\n";
				teamIDfound = 1;
				break;
			}
		}
		if (teamIDfound != 1) titr->second.push_back(teamID);
		teamIDfound = 0;
	} else {
		qid2teamIDs[qid].push_back(teamID);
	}

	return teamIDfound;
}

int
loadresults(FILE *initfp, InsertType &msgtype)
{
	chordID teamID;
	std::vector<POLY> sig;
	std::vector<POLY> querysig;
	std::vector<std::string> tokens;
	mapType sig2avg;
	std::string linestr;
	std::string dtd;
	str sigbuf;
	bool sigfound = 0;
	int listnum = 0;
	int n = 0;
	int sigmatches, qid, avgid;
	char *line = NULL;
	size_t len = 0;
	ssize_t read;
	double freq, weight, avg, totalavg;

	qid = 0;
	while ((read = getline(&line, &len, initfp)) != -1) {
		// skip 1st line
		/*
		if (n == 0) {
			++n;
			continue;
		}
		*/
		linestr.clear();
		linestr.assign(line);
		tokens.clear();
		tokenize(linestr, tokens, ": ");
		sig.clear();
		int toksize = tokens.size();
		if (strcmp(tokens[0].c_str(), "rxmsglen") == 0) {
			// TODO: record other fields?
			if (strcmp(tokens[3].c_str(), "QUERYS") == 0) {
				msgtype = QUERYS;
			} else if (strcmp(tokens[3].c_str(), "QUERYX") == 0) {
				msgtype = QUERYX;
			} else if (strcmp(tokens[3].c_str(), "QUERYXP") == 0) {
				msgtype = QUERYXP;
			} else {
				warnx << "loadresults: error parsing\n";
				return -1;
			}
		} else if (strcmp(tokens[0].c_str(), "queryresult") == 0) {
			qid = strtol(tokens[3].c_str(), NULL, 10);
			querysig.clear();
			string2sig(tokens[5], querysig);
			dtd = tokens[7];
			// strip "\n" from teamID
			std::string t = tokens[toksize-1].substr(0,tokens[toksize-1].size()-1);
			str z(t.c_str());
			str2chordID(z, teamID);
			sig2str(querysig, sigbuf);
			//warnx << "qid: " << qid << " querysig: " << sigbuf << " DTD: " << dtd.c_str() << " teamID: " << teamID << "\n";
			if (msgtype == QUERYX || msgtype == QUERYXP) {
				addqid(qid, querysig);
				// TODO: check return
				addteamID(qid, teamID);
				// add DTD
				id2strings::iterator itr = qid2dtd.find(qid);
				if (itr != qid2dtd.end()) {
					//warnx << "loadresults: qid already exists\n";
				} else {
					qid2dtd[qid].push_back(dtd);
				}
			} else if (msgtype == QUERYS) {
				// TODO: associate querysig with an id
			}
		// only found in QUERYX msgs
		} else if (strcmp(tokens[0].c_str(), "supersetsig") == 0) {
			sig.clear();
			string2sig(tokens[1], sig);
			freq = strtod(tokens[3].c_str(), NULL);
			weight = strtod(tokens[5].c_str(), NULL);
			avg = strtod(tokens[7].c_str(), NULL);
			sig2str(sig, sigbuf);

			//addqid2id(qid, sig, avg);

			// XXX: assume that qid is still valid?
			id2id::iterator iditr = qid2id.find(qid);
			if (iditr != qid2id.end()) {
				avgid = iditr->second;
				// add sig and avg OR add avg to existing sig
				mapType::iterator saitr = allsig2avg[avgid].find(sig);
				if (saitr != allsig2avg[avgid].end()) {
					saitr->second.push_back(avg);
				} else {
					allsig2avg[avgid][sig].push_back(avg);
				}

			} else {
				// TODO: verfiy that it's the correct index
				avgid = allsig2avg.size();
				qid2id[qid] = avgid;
				sig2avg[sig].push_back(avg);
				allsig2avg.push_back(sig2avg);
			}

			// map sig to qid
			id2sigs::iterator sitr = qid2sigs.find(qid);
			if (sitr != qid2sigs.end()) {
				for (int i = 0; i < (int)sitr->second.size(); i++) {
					if (samesig(sig, sitr->second[i]) == 1) {
						//warnx << "loadresults: sig already present\n";
						sigfound = 1;
						break;
					}
				}
				if (sigfound != 1)
					sitr->second.push_back(sig);
				sigfound = 0;
			} else {
				qid2sigs[qid].push_back(sig);
			}
		// only found in QUERYS msgs
		} else if (strcmp(tokens[0].c_str(), "exactsig") == 0) {
			sig.clear();
			// TODO: don't strip "," in future versions
			std::string exst = tokens[1].substr(0,tokens[1].size()-1);
			string2sig(exst, sig);
			exst = tokens[3].substr(0,tokens[3].size()-1);
			freq = strtod(exst.c_str(), NULL);
			exst = tokens[5].substr(0,tokens[5].size()-1);
			weight = strtod(exst.c_str(), NULL);
			// TODO: discard avg?
			// avg doesn't have trailing ","
			avg = strtod(tokens[7].c_str(), NULL);
			sig2str(sig, sigbuf);

			mapType::iterator itr = allT[listnum].find(sig);
			if (itr != allT[listnum].end()) {
				itr->second[0] += freq;
				itr->second[1] += weight;
			} else {
				allT[listnum][sig].push_back(freq);
				allT[listnum][sig].push_back(weight);
			}
		// TODO: record queryresultend data?
		} else if (strcmp(tokens[0].c_str(), "queryresultend") == 0) {
			sigmatches = strtol(tokens[4].c_str(), NULL, 10);
			totalavg = strtod(tokens[6].c_str(), NULL);
			//warnx << "queryresultend: sigmatches: " << sigmatches;
			//printdouble(" totalavg: ", totalavg);
			//warnx << "\n";
		} else {
			warnx << "loadresults: error parsing\n";
			return -1;
		}
		++n;
	}
			/*
			// list index
			tind = strtol(tokens[1].c_str(), NULL, 10);
			// strip "\n" from chordID
			std::string t = tokens[toksize-1].substr(0,tokens[toksize-1].size()-1);
			str z(t.c_str());
			str2chordID(z, teamID);
			warnx << "teamID(" << tind << ":" << tsize + tind << "): "
			      << teamID << "\n";
			teamindex[teamID].push_back(tsize + tind);
			// done with previous team, add its vecomap
			// (but don't do it for the very first index line)
			if (n != 0) {
				tmpvecomap.push_back(uniqueSigList);
				totalT.push_back(tmpvecomap);
				uniqueSigList.clear();
				tmpvecomap.clear();
			}
			++n;
			continue;
		}
		string2sig(tokens[0], sig);
		freq = strtod(tokens[1].c_str(), NULL);
		weight = strtod(tokens[2].c_str(), NULL);
		uniqueSigList[sig].push_back(freq);
		uniqueSigList[sig].push_back(weight);
	}

	if (n != 0) {
		tmpvecomap.push_back(uniqueSigList);
		totalT.push_back(tmpvecomap);
	}
	*/

	if (line) free(line);
	//warnx << "loadresults: teams added: " << n << "\n";

	return n;
}

int
loadinitstate(FILE *initfp)
{
	mapType uniqueSigList;
	vecomap tmpvecomap;
	chordID teamID;
	std::vector<POLY> sig;
	std::vector<std::string> tokens;
	std::string linestr;
	int tind, tsize;
	int n = 0;
	char *line = NULL;
	size_t len = 0;
	ssize_t read;
	double freq, weight;

	uniqueSigList.clear();
	tmpvecomap.clear();
	tsize = totalT.size();
	while ((read = getline(&line, &len, initfp)) != -1) {
		linestr.clear();
		linestr.assign(line);
		tokens.clear();
		tokenize(linestr, tokens, ":");
		sig.clear();
		int toksize = tokens.size();
		if (strcmp(tokens[0].c_str(), "index") == 0) {
			// list index
			tind = strtol(tokens[1].c_str(), NULL, 10);
			// strip "\n" from chordID
			std::string t = tokens[toksize-1].substr(0,tokens[toksize-1].size()-1);
			str z(t.c_str());
			str2chordID(z, teamID);
			warnx << "teamID(" << tind << ":" << tsize + tind << "): "
			      << teamID << "\n";
			teamindex[teamID].push_back(tsize + tind);
			// done with previous team, add its vecomap
			// (but don't do it for the very first index line)
			if (n != 0) {
				tmpvecomap.push_back(uniqueSigList);
				totalT.push_back(tmpvecomap);
				uniqueSigList.clear();
				tmpvecomap.clear();
			}
			++n;
			continue;
		}
		string2sig(tokens[0], sig);
		freq = strtod(tokens[1].c_str(), NULL);
		weight = strtod(tokens[2].c_str(), NULL);
		uniqueSigList[sig].push_back(freq);
		uniqueSigList[sig].push_back(weight);
	}

	if (n != 0) {
		tmpvecomap.push_back(uniqueSigList);
		totalT.push_back(tmpvecomap);
	}

	if (line) free(line);
	warnx << "loadinitstate: teams added: " << n << "\n";

	return n;
}

void
loginitstate(FILE *initfp)
{
	std::vector<POLY> sig;
	sig.clear();
	str sigbuf;
	chordID ID;
	// merged list is first
	int listnum = 0;
	double freq, weight;

	for (int i = 0; i < (int)totalT.size(); i++) {
		ID = findteamid(i);
		if (ID == NULL) {
			warnx << "loginitstate: teamID is NULL\n";
			continue;
		}
		strbuf z;
		z << ID;
		str teamID(z);
		fprintf(initfp, "index:%d:listsize:%d:teamID:%s\n", i, totalT[i][listnum].size(), teamID.cstr());
		for (mapType::iterator itr = totalT[i][listnum].begin();
		     itr != totalT[i][listnum].end(); itr++) {
			sig = itr->first;
			freq = itr->second[0];
			weight = itr->second[1];
			sig2str(sig, sigbuf);
			fprintf(initfp, "%s:", sigbuf.cstr());
			fprintf(initfp, "%f:", freq);
			fprintf(initfp, "%f\n", weight);
		}
	}
}

char *
netstring_decode(FILE *f)
{
	int n, len;
	char *buf;

	/* FIXME: invalid length edge case */
	if (fscanf(f, "%d", &len) < 1) {
		return NULL;
	}

	if (fgetc(f) != ':') {
		warnx << "bad format\n";
		warnx << "bad format\n";
		return NULL;
	}

	if ((buf = (char *)malloc(len + 1)) == NULL) {
		warnx << "out of memory\n";
		exit(1);
	}

	if (!buf) {
		warnx << "can't allocate memory\n";
		return NULL;
	}

	/* fread: is this the best way? */
	if ((n = fread(buf, 1, len, f)) < len) {
		warnx << "error reading value\n";
		return NULL;
	}

	if (fgetc(f) != ',') {
		warnx << "bad format\n";
		return NULL;
	}

	return buf;
}

void
netstring_encode(const char *buf, FILE *f)
{
	int len;

	len = strlen(buf);
	if (fprintf(f, "%d:", len) < 0) warnx << "invalid length\n";
	if (fwrite(buf, 1, len, f) < (unsigned int)len) warnx << "can't write to stream\n";
	if (fputc(',', f) < 0) warnx << "can't write to stream\n";
}

// based on:
// http://www.linuxquestions.org/questions/programming-9/c-list-files-in-directory-379323/
// verified
int
getdir(std::string dir, std::vector<std::string> &files)
{
	DIR *dp;
	struct dirent *dirp;

	if ((dp = opendir(dir.c_str())) == NULL) {
		fatal("can't read dir\n");
		return errno;
	}
	while ((dirp = readdir(dp)) != NULL) {
		if (strcmp(dirp->d_name, ".") == 0 || strcmp(dirp->d_name, "..") == 0) continue;
		// separate by / in case dir arg doesn't have a trailing slash
		files.push_back(dir + "/" + std::string(dirp->d_name));
	}
	closedir(dp);
	return 0;
}

// copied from psi.C
void
readquery(std::string queryfile, std::vector<std::vector <POLY> > &queryList, std::vector<std::string> &dtdList)
{
	std::vector<std::string> tokens;
	double startTime, finishTime;
	FILE *qfp;

	startTime = getgtod();
	// open queries
	warnx << "queryfile: " << queryfile.c_str() << "\n";
        qfp = fopen(queryfile.c_str(), "r");
        assert(qfp);
	tokens.clear();
	tokenize(queryfile, tokens, "/");
	// remove ".qry" extension
	std::string file = tokens.back();
	tokens.clear();
	tokenize(file, tokens, ".");
	std::string dtd;
	for (unsigned int i = 0; i < tokens.size() - 1; i++) {
		dtd += tokens[i];
		// don't put a dot at the end of the DTD name
		if (i != tokens.size() - 2)
			dtd += ".";
	} 

	while (1) {
		// DON'T use readData to retrieve signatures from input files...
		// since the size filed uses POLY as a basic unit and not byte...
		// Format is <n = # of sigs><sig size><sig>... n times...
		int numSigs;
		if (fread(&numSigs, sizeof(numSigs), 1, qfp) != 1) {
			warnx << "numSigs: " << numSigs << "\n";
			break;
		}
		warnx << "NUM sigs: " << numSigs << "\n";
		assert(numSigs > 0);

		for (int t = 0; t < numSigs; t++) {
			POLY *buf;
			int size;
			if (fread(&size, sizeof(int), 1, qfp) != 1) {
				assert(0);
			}
			warnx << "Signature size: " << size * sizeof(POLY) << " bytes\n";
				
			buf = new POLY[size];
			assert(buf);
			if (fread(buf, sizeof(POLY), size, qfp) != (size_t) size) {
				assert(0);
			}
					
			std::vector<POLY> sig;
			sig.clear();
			warnx << "Query signature (sorted): ";
			for (int i = 0; i < size; i++) {
				// XXX: discard "1"s
				if (buf[i] == 1) continue;
				sig.push_back(buf[i]);
			}
			sort(sig.begin(), sig.end());
			str sigbuf;
			sig2str(sig, sigbuf);
			warnx << sigbuf << "\n";
			queryList.push_back(sig);
			dtdList.push_back(dtd);

			// free the allocated memory
			delete[] buf;
		}
			
		/*
		warnx << "******* Processing query " << count << " ********\n";
		numReads = numWrites = dataReadSize = cacheHits = 0;
		strbuf s;
		s << rootNodeID;
		str rootID(s);

		//if ((int) listOfSigs.size() > MAXSIGSPERQUERY) {
		if (0) {
			warnx << "Skipping this query...\n";
		} else {
			numDocs = 0;
			listOfVisitedNodes.clear();
					
			double beginQueryTime = getgtod();
			str junk("");
			queryProcess(rootID, listOfSigs, junk);


			double endQueryTime = getgtod();

			std::cerr << "Query time: " << endQueryTime - beginQueryTime << " secs\n";
			totalTime += (endQueryTime - beginQueryTime);
			warnx << "Num docs: " << numDocs << "\n";
		}
			
			#ifdef _DEBUG_
				
			#endif
			warnx << "Data read in bytes: " << dataFetched << "\n";
			warnx << "Data written in bytes: " << dataStored << "\n";
			warnx << "Number of DHT lookups: " << numReads << "\n";
			//warnx << " num writes: " << numWrites << "\n";
			warnx << "Cache hits: " << cacheHits << "\n";
			warnx << "******** Finished query processing *********\n\n\n";
			count++;

			if (count != maxCount + 1) {
				warnx << "Sleeping...\n";
				//sleep(1);
				//sleep(1 + (int) ((double) randDelay * (rand() / (RAND_MAX + 1.0))));
			}
		}
		*/
	}

	fclose(qfp);
	warnx << "readquery: Size of query list: " << queryList.size() << "\n";
	finishTime = getgtod();
}

// TODO: work w/ 0-sized sigs
void
readsig(std::string sigfile, std::vector<std::vector <POLY> > &sigList, bool useproxy)
{
	std::vector<std::string> tokens;
	double startTime, finishTime;
	FILE *sigfp;

	startTime = getgtod();
	// open signatures
	//warnx << "sigfile: " << sigfile.c_str() << "\n";
	sigfp = fopen(sigfile.c_str(), "r");
	// change to if?
	assert(sigfp);
	tokenize(sigfile, tokens, "/");
	// remove ".$NUM.sig" extension
	std::string file = tokens.back();
	tokens.clear();
	tokenize(file, tokens, ".");
	std::string dtd;
	for (unsigned int i = 0; i < tokens.size() - 2; i++) {
		dtd += tokens[i];
		// don't put a dot at the end of the DTD name
		if (i != tokens.size() - 3)
			dtd += ".";
	}
	// TODO: add maxcount arg?

	// DONT use readData to retrieve signatures from input files...
	// since the size filed uses POLY as a basic unit and not byte...
	// Read numSigs <it should be 1> for data signatures...
	int numSigs;
	if (fread(&numSigs, sizeof(int), 1, sigfp) != 1) {
		//warnx << "numSigs: " << numSigs << "\n";
	}
	//warnx << "NUM sigs: " << numSigs;
	assert(numSigs == 1);

	int size;

	if (fread(&size, sizeof(int), 1, sigfp) != 1) {
		assert(0);
		warnx << "\ninvalid signature\n";
	}
	//warnx << ", Signature size: " << size * sizeof(POLY) << " bytes\n";

	std::vector<POLY> sig;
	sig.clear();
	POLY e;
	//warnx << "Document signature (sorted): ";
	for (int i = 0; i < size; i++) {
		if (fread(&e, sizeof(POLY), 1, sigfp) != 1) {
			assert(0);
		}
		sig.push_back(e);
	}
	sort(sig.begin(), sig.end());
	str buf;
	sig2str(sig, buf);
	//warnx << buf << "\n";
	sigList.push_back(sig);
	// map dtd to sig
	if (useproxy == false) {
		string2sigs::iterator itr = dtd2sigs.find(dtd);
		if (itr != dtd2sigs.end()) {
			itr->second.push_back(sig);
		} else {
			dtd2sigs[dtd].push_back(sig);
		}
	} else {
		string2sigs::iterator itr = dtd2proxysigs.find(dtd);
		if (itr != dtd2proxysigs.end()) {
			itr->second.push_back(sig);
		} else {
			dtd2proxysigs[dtd].push_back(sig);
		}
	}

	//warnx << "readsig: Size of sig list: " << sigList.size() << "\n";
	finishTime = getgtod();
	fclose(sigfp);
}

// TODO: verify
void
initgossiprecv(chordID ID, chordID teamID, std::vector<POLY> sig, double freq, double weight)
{
	int tind;
	// init phase uses 1st vecomap only
	int listnum = 0;
	std::vector<POLY> hldsig;
	mapType uniqueSigList;
	vecomap tmpveco;
	str sigbuf;

	dummysig.clear();
	dummysig.push_back(1);
	hldsig.clear();
	hldsig.push_back(0);

	// find if list for team exists
	teamid2totalT::iterator teamitr = teamindex.find(teamID);
	if (teamitr != teamindex.end()) {
		warnx << "teamID found\n";
		tind = teamitr->second[0];
	} else {
		warnx << "teamID NOT found: adding new vecomap\n";
		warnx << "totalT.size() [before]: " << totalT.size() << "\n";
		tind = totalT.size();
		// don't add 1, since it's 0-based
		teamindex[teamID].push_back(tind);
		// add empty vecomap otherwise a push_back() below will fail
		totalT.push_back(tmpveco);
	}
	warnx << "tind: " << tind << "\n";
	warnx << "totalT.size(): " << totalT.size() << "\n";
	warnx << "teamindex.size(): " << teamindex.size() << "\n";
	warnx << "totalT[tind].size(): " << totalT[tind].size() << "\n";

	if (totalT[tind].size() == 0) {
		uniqueSigList[hldsig].push_back(0);
		uniqueSigList[hldsig].push_back(1);
		totalT[tind].push_back(uniqueSigList);
	}

	mapType::iterator sigitr = totalT[tind][listnum].find(sig);
	mapType::iterator dummysigitr = totalT[tind][listnum].find(dummysig);

	// s is regular and T_h[s] exists
	if ((sig != dummysig) && (sigitr != totalT[tind][listnum].end())) {
		warnx << "initgossiprecv: update freq\n";
		sig2str(sig, sigbuf);
		warnx << "initgossiprecv: sig: " << sigbuf;
		printdouble(" cur-f: ", sigitr->second[0]);
		printdouble(" cur-w: ", sigitr->second[1]);
		warnx << "\n";
		sigitr->second[0] += freq;
	// s is regular and T_h[s] does not exist
	} else if ((sig != dummysig) && (sigitr == totalT[tind][listnum].end())) {
		warnx << "initgossiprecv: inserting sig\n";
		totalT[tind][0][sig].push_back(freq);
		totalT[tind][0][sig].push_back(weight);

		if (dummysigitr == totalT[tind][listnum].end()) {
			totalT[tind][listnum][dummysig].push_back(0);
			totalT[tind][listnum][dummysig].push_back(1);
			warnx << "initgossiprecv: inform team\n";
			informteam(ID, teamID, dummysig);
		}
	// s is a special multiset
	} else {
		warnx << "s is a special multiset\n";
		if (sigitr == totalT[tind][listnum].end()) {
			warnx << "initgossiprecv: inserting sig\n";
			totalT[tind][listnum][sig].push_back(freq);
			totalT[tind][listnum][sig].push_back(weight);
			warnx << "initgossiprecv: inform team\n";
			informteam(ID, teamID, sig);
		}
	}
}

// TODO: verify
void
informteam(chordID myID, chordID teamID, std::vector<POLY> sig)
{
	DHTStatus status;
	std::vector<chordID> team;
	chordID nextID;
	char *value;
	int valLen;
	int idindex;
	double instime = 0;

	warnx << "teamID: " << teamID << "\n";
	idindex = make_team(myID, teamID, team);
	
	if (idindex == -1) {
		warnx << "myID not in team\n";
		return;
	} else if (idindex == ((int)team.size() - 1)) {
		warnx << "i am last, wrap around to first\n";
		nextID = team[0];
		// don't exit if last
		//return;
	} else {
		// is this addition always safe?
		nextID = team[idindex+1];
	}

	strbuf z;
	z << nextID;
	str key(z);
	strbuf y;
	y << teamID;
	str teamidstr(y);
	double freq = 0;
	double weight = 1;
	makeKeyValue(&value, valLen, key, teamidstr, sig, freq, weight, INFORMTEAM);
	totaltxmsglen += valLen;
	warnx << "inserting INFORMTEAM:\n";
	warnx << "myID: " << myID << " nextID: " << nextID << " teamID: " << teamID << "\n";
	status = insertDHT(nextID, value, valLen, instime, MAXRETRIES);
	cleanup(value);

	if (status != SUCC) {
		// TODO: do I care?
		warnx << "error: insert FAILed\n";
	} else {
		warnx << "insert SUCCeeded\n";
	}
}

// add teamIDs generated by LSH to teamidminhash
void
calcteamids(std::vector<chordID> minhash)
{
	teamidfreq::iterator teamitr;

	for (int i = 0; i < (int)minhash.size(); i++) {
		teamitr = teamidminhash.find(minhash[i]);
		if (teamitr != teamidminhash.end()) {
			warnx << "teamID found in teamidminhash\n";
			teamitr->second += 1;
		} else {
			warnx << "teamID NOT found in teamidminhash\n";
			teamidminhash[minhash[i]] = 1;
		}
	}
}

// find teamID of totalT[tix]
// TODO: inefficient?
chordID
findteamid(int tix)
{
	teamid2totalT::iterator itr;
	for (itr = teamindex.begin(); itr != teamindex.end(); itr++) {
		for (int i = 0; i < (int)itr->second.size(); i++) {
			if (itr->second[i] == tix) {
				return itr->first;
			}
		}
	}
	
	return NULL;
}

// return -1 if myID is not in team
// verify
int
make_team(chordID myID, chordID teamID, std::vector<chordID> &team)
{
	int idindex = -1;
	chordID curID;

	if (myID == teamID) {
		//warnx << "myID == teamID, index = 0\n";
		idindex = 0;
	}

	// size of ring
	bigint rngmax = (bigint (1) << 160)  - 1;
	bigint arclen = rngmax / teamsize;
	//warnx << "arclen: " << arclen << "\n";
	chordID b = 1;
	b <<= NBIT;
	team.clear();
	team.push_back(teamID);
	curID = teamID;
	//warnx << "ID_0: " << teamID << "\n";
	// start at 1 because of team id
	for (int j = 1; j < teamsize; j++) {
		curID += arclen;
		// wraparound
		if (curID >= b) curID -= b;
		//warnx << "ID_" << j << ": " << curID << "\n";
		if (myID == curID) {
			//warnx << "myID == curID, index = " << j << "\n";
			idindex = j;
		}
		team.push_back(curID);
	}
	//warnx << "team.size(): " << team.size() << "\n";

	return idindex;
}

// obsolete
std::vector<POLY>
inverse(std::vector<POLY> sig)
{
	std::vector<POLY> isig;
	isig.clear();

	if (sig[0] == 0) {
		// convert to regular multiset
		for (int i = 1; i < (int) sig.size(); i++)
			isig.push_back(sig[i]);
		return isig;
	} else {
		// convert to special multiset
		// TODO: what's faster?
		sig.insert(sig.begin(), 1, 0);
		//isig.push_back(0);
		//for (int i = 0; i < (int) sig.size(); i++)
		//	isig.push_back(sig[i]);
		return sig;
	}
}

// copied from http://oopweb.com/CPP/Documents/CPPHOWTO/Volume/C++Programming-HOWTO-7.html
void
tokenize(const std::string& str, std::vector<std::string>& tokens, const std::string &delimiters = " ")
{
	// Skip delimiters at beginning.
	std::string::size_type lastPos = str.find_first_not_of(delimiters, 0);
	// Find first "non-delimiter".
	std::string::size_type pos = str.find_first_of(delimiters, lastPos);

	while (std::string::npos != pos || std::string::npos != lastPos) {
		// Found a token, add it to the vector.
		tokens.push_back(str.substr(lastPos, pos - lastPos));
		// Skip delimiters.  Note the "not_of"
		lastPos = str.find_first_not_of(delimiters, pos);
		// Find next "non-delimiter"
		pos = str.find_first_of(delimiters, lastPos);
	}
}
 
bool
string2sig(std::string buf, std::vector<POLY> &sig)
{
	std::vector<std::string> tokens;

	if (buf.length() == 0) return false;

	tokenize(buf, tokens, "-");
	for (int i = 0; i < (int)tokens.size(); i++)
		sig.push_back(strtol(tokens[i].c_str(), NULL, 10));

	return true;
}

// verified
bool
sig2str(std::vector<POLY> sig, str &buf)
{
	strbuf s;

	if (sig.size() <= 0) return false;

	for (int i = 0; i < (int)sig.size(); i++)
		s << sig[i] << "-";

	buf = s;
	return true;
}

bool
validsig(std::vector<POLY> sig)
{
	if (sig.size() <= 0) return false;

	for (int i = 0; i < (int)sig.size(); i++)
		if (sig[i] == 0)
			return false;

	return true;
}

void
add2querymap(std::vector<std::vector<POLY> > queryList, std::vector<std::string> dtdList)
{
	int qid = 0;
	assert(queryList.size() == dtdList.size());

	for (int i = 0; i < (int)queryList.size(); i++) {
		queryMap.insert(std::pair<std::vector<POLY>, int>(queryList[i], qid));
		id2strings::iterator itr = qid2dtd.find(qid);
		if (itr != qid2dtd.end()) {
			warnx << "add2querymap: qid already exists\n";
		} else {
			qid2dtd[qid].push_back(dtdList[i]);
		}
		++qid;
	}
	warnx << "queries added: " << qid << "\n";
}

// verified
// use allT only in init phases
void
calcfreq(std::vector<std::vector<POLY> > sigList, bool usedummy, bool proxysigs)
{
	mapType uniqueSigList;
	int i = 0;

	if (usedummy == 1) {
		// dummy's freq is 0 and weight is 1
		uniqueSigList[sigList[0]].push_back(0);
		uniqueSigList[sigList[0]].push_back(1);
		// skip dummy
		i = 1;
	}

	for (; i < (int)sigList.size(); i++) {
		mapType::iterator itr = uniqueSigList.find(sigList[i]);
		if (itr != uniqueSigList.end()) {
			// do not increment weight when sig has duplicates!
			// increment only freq
			itr->second[0] += 1;
		} else {
			// set freq
			uniqueSigList[sigList[i]].push_back(1);
			// set weight
			uniqueSigList[sigList[i]].push_back(1);
		}
	}
	if (proxysigs == false) {
		allT.push_back(uniqueSigList);
		warnx << "calcfreq: setsize: " << allT[0].size() << "\n";
	} else {
		// XXX: ugly!
		if (allT.size() == 0) {
			mapType tmpSigList;
			allT.push_back(tmpSigList);
		}
		allT.push_back(uniqueSigList);
		warnx << "calcfreq: setsize: " << allT[1].size() << "\n";
	}
}

// verified
// use allT only in init phases
void
lcalcfreq(std::vector<std::vector<POLY> > sigList, bool usedummy, bool proxysigs)
{
	lmapType uniqueSigList;
	int i = 0;

	if (usedummy == 1) {
		// dummy's freq is 0 and weight is 1
		uniqueSigList[sigList[0]].push_back(0);
		uniqueSigList[sigList[0]].push_back(1);
		// skip dummy
		i = 1;
	}

	for (; i < (int)sigList.size(); i++) {
		lmapType::iterator itr = uniqueSigList.find(sigList[i]);
		if (itr != uniqueSigList.end()) {
			// do not increment weight when sig has duplicates!
			// increment only freq
			itr->second[0] += 1;
		} else {
			// set freq
			uniqueSigList[sigList[i]].push_back(1);
			// set weight
			uniqueSigList[sigList[i]].push_back(1);
		}
	}
	if (proxysigs == false) {
		lallT.push_back(uniqueSigList);
		warnx << "calcfreq: setsize: " << lallT[0].size() << "\n";
	} else {
		// XXX: ugly!
		if (lallT.size() == 0) {
			lmapType tmpSigList;
			lallT.push_back(tmpSigList);
		}
		lallT.push_back(uniqueSigList);
		warnx << "calcfreq: setsize: " << lallT[1].size() << "\n";
	}
}

// deprecated: use mergelists() instead
void
calcfreqM(std::vector<std::vector<POLY> > sigList, std::vector<double> freqList, std::vector<double> weightList)
{
	//int deg;

	// skip dummy
	for (int i = 1; i < (int) sigList.size(); i++) {
		mapType::iterator itr = allT[0].find(sigList[i]);
		if (itr != allT[0].end()) {
			itr->second[0] += freqList[i];
			itr->second[1] += weightList[i];
		} else {
			allT[0][sigList[i]].push_back(freqList[i]);
			allT[0][sigList[i]].push_back(weightList[i]);
		}
	}
	warnx << "calcfreqM: Size of unique sig list: " << allT[0].size() << "\n";
}

// xgossip
void
add2vecomapx(std::vector<std::vector<POLY> > sigList, std::vector<double> freqList, std::vector<double> weightList, chordID teamID)
{
	int tind;
	mapType uniqueSigList;
	vecomap tmpvecomap;
	tind = 0;

	warnx << "add2vecomap\n";

	for (int i = 0; i < (int) sigList.size(); i++) {
		uniqueSigList[sigList[i]].push_back(freqList[i]);
		uniqueSigList[sigList[i]].push_back(weightList[i]);
	}

	// find if list for team exists
	teamid2totalT::iterator teamitr = teamindex.find(teamID);
	if (teamitr != teamindex.end()) {
		tind = teamitr->second[0];
		warnx << "teamID found at teamindex[" << tind << "]\n";
		totalT[tind].push_back(uniqueSigList);
		warnx << "totalT[tind].size(): " << totalT[tind].size() << "\n";
	} else {
		warnx << "warning: teamID NOT found: " << teamID << "\n";

		// Broadcast only
		if (bcast == true) {
			warnx << "teamID NOT found: adding new vecomap\n";
			warnx << "totalT.size() [before]: " << totalT.size() << "\n";
			tmpvecomap.push_back(uniqueSigList);
			totalT.push_back(tmpvecomap);
			tind = totalT.size() - 1;
			teamindex[teamID].push_back(tind);
		}
	}

	warnx << "tind: " << tind << "\n";
	warnx << "totalT.size(): " << totalT.size() << "\n";
	warnx << "teamindex.size(): " << teamindex.size() << "\n";
}

// vanillaxgossip
void
add2vecomapv(std::vector<std::vector<POLY> > sigList, std::vector<double> freqList, std::vector<double> weightList)
{
        mapType uniqueSigList;

	warnx << "add2vecomap\n";

        for (int i = 0; i < (int) sigList.size(); i++) {
                uniqueSigList[sigList[i]].push_back(freqList[i]);
                uniqueSigList[sigList[i]].push_back(weightList[i]);
        }

	totalT[0].push_back(uniqueSigList);
	warnx << "totalT[0].size(): " << totalT[0].size() << "\n";
}

// if nan or inf, init num to 1st operand
// (i.e. don't perform operation)
bool
fixnan(double num, double op1)
{
	if (isnan(num)) {
		printdouble("isnan: ", num);
		printdouble(", ", op1);
		warnx << "\n";
		num = op1;
		return true;
	} else if (isinf(num)) {
		printdouble("isinf: ", num);
		printdouble(", ", op1);
		warnx << "\n";
		num = op1;
		return true;
	}

	return false;
}

// s1 and s2 are assumed to be sorted
bool
samesig(std::vector<POLY> s1, std::vector<POLY> s2)
{
	if (s1.size() != s2.size()) {
		return false;
	} else {
		for (int i = 0; i < (int) s1.size(); i++)
			if (s1[i] != s2[i]) return false;
	}

	return true;
}

// copied from psi.C
// return TRUE if s1 < s2
bool
sigcmp(std::vector<POLY> s1, std::vector<POLY> s2)
{
	if (s1.size() < s2.size()) {
		return true;
	} else if (s1.size() == s2.size()) {
		for (int i = 0; i < (int) s1.size(); i++) {
			if (s1[i] < s2[i])
				return true;
			else if (s1[i] > s2[i])
				return false;
		}
		return false;
	} else {
		return false;
	}
}

// return number of elements in the intersection of s1 and s2
// s1 and s2 are assumed to be sorted
// logic copied from set_intersection() in <algorithm>
// works with multisets (DOES NOT skip duplicates)
// complexity:
// at most, performs 2*(count1+count2)-1 comparisons or applications of comp
// (where countX is the distance between firstX and lastX)
int
set_inter_noskip(std::vector<POLY> s1, std::vector<POLY> s2, bool &multi)
{
	std::vector<POLY>::iterator s1itr = s1.begin();
	std::vector<POLY>::iterator s2itr = s2.begin();
	POLY s1prev, s2prev;
	int n, s1skip, s2skip;

	//warnx << "\n";
	s1prev = s2prev = n = s1skip = s2skip = 0;
	while (s1itr != s1.end() && s2itr != s2.end()) {
		// DON'T skip duplicates, just count them
		if (s1prev == *s1itr) {
			//warnx << "skipping duplicate\n";
			++s1skip;
			//s1prev = *s1itr;
			//++s1itr;
		} else if (s2prev == *s2itr) {
			//warnx << "skipping duplicate\n";
			++s2skip;
			//s2prev = *s2itr;
			//++s2itr;
		}

		if (*s1itr < *s2itr) {
			s1prev = *s1itr;
			++s1itr;
		} else if (*s2itr < *s1itr) {
			s2prev = *s2itr;
			++s2itr;
		} else {
			//warnx << "both: " << *s1itr << "\n";
			s1prev = *s1itr;
			s2prev = *s2itr;
			++s1itr;
			++s2itr;
			// count only same elements
			++n;
		}
	}
	//warnx << "s1skip(inter): " << s1skip << "\n";
	//warnx << "s2skip(inter): " << s2skip << "\n";
	// TODO: if s1 is multi (s1 is prevsig, s2 is cursig)
	if (s2skip != 0)
		multi = 1;
	else
		multi = 0;

	return n;
}
// return number of elements in the intersection of s1 and s2
// s1 and s2 are assumed to be sorted
// logic copied from set_intersection() in <algorithm>
// works with multisets (skips duplicates)
// complexity:
// at most, performs 2*(count1+count2)-1 comparisons or applications of comp
// (where countX is the distance between firstX and lastX)
int
set_inter(std::vector<POLY> s1, std::vector<POLY> s2, bool &multi)
{
	std::vector<POLY>::iterator s1itr = s1.begin();
	std::vector<POLY>::iterator s2itr = s2.begin();
	POLY s1prev, s2prev;
	int n, s1skip, s2skip;

	//warnx << "\n";
	s1prev = s2prev = n = s1skip = s2skip = 0;
	while (s1itr != s1.end() && s2itr != s2.end()) {
		// don't count duplicates
		if (s1prev == *s1itr) {
			//warnx << "skipping duplicate\n";
			++s1skip;
			s1prev = *s1itr;
			++s1itr;
		} else if (s2prev == *s2itr) {
			//warnx << "skipping duplicate\n";
			++s2skip;
			s2prev = *s2itr;
			++s2itr;
		} else if (*s1itr < *s2itr) {
			s1prev = *s1itr;
			++s1itr;
		} else if (*s2itr < *s1itr) {
			s2prev = *s2itr;
			++s2itr;
		} else {
			//warnx << "both: " << *s1itr << "\n";
			s1prev = *s1itr;
			s2prev = *s2itr;
			++s1itr;
			++s2itr;
			// count only same elements
			++n;
		}
	}
	//warnx << "s1skip(inter): " << s1skip << "\n";
	//warnx << "s2skip(inter): " << s2skip << "\n";
	// TODO: if s1 is multi (s1 is prevsig, s2 is cursig)
	if (s2skip != 0)
		multi = 1;
	else
		multi = 0;

	return n;
}

// TODO: implement using templates (to handle both vectors of POLYs and vectors of chordIDs)
// return number of elements in the intersection of s1 and s2
// s1 and s2 are assumed to be sorted
// logic copied from set_intersection() in <algorithm>
// works with multisets (skips duplicates)
// complexity:
// at most, performs 2*(count1+count2)-1 comparisons or applications of comp
// (where countX is the distance between firstX and lastX)
int
set_inter(std::vector<chordID> s1, std::vector<chordID> s2, bool &multi)
{
	std::vector<chordID>::iterator s1itr = s1.begin();
	std::vector<chordID>::iterator s2itr = s2.begin();
	chordID s1prev, s2prev;
	int n, s1skip, s2skip;

	//warnx << "\n";
	s1prev = s2prev = n = s1skip = s2skip = 0;
	while (s1itr != s1.end() && s2itr != s2.end()) {
		// don't count duplicates
		if (s1prev == *s1itr) {
			//warnx << "skipping duplicate\n";
			++s1skip;
			s1prev = *s1itr;
			++s1itr;
		} else if (s2prev == *s2itr) {
			//warnx << "skipping duplicate\n";
			++s2skip;
			s2prev = *s2itr;
			++s2itr;
		} else if (*s1itr < *s2itr) {
			s1prev = *s1itr;
			++s1itr;
		} else if (*s2itr < *s1itr) {
			s2prev = *s2itr;
			++s2itr;
		} else {
			//warnx << "both: " << *s1itr << "\n";
			s1prev = *s1itr;
			s2prev = *s2itr;
			++s1itr;
			++s2itr;
			// count only same elements
			++n;
		}
	}
	//warnx << "s1skip(inter): " << s1skip << "\n";
	//warnx << "s2skip(inter): " << s2skip << "\n";
	// TODO: if s1 is multi (s1 is prevsig, s2 is cursig)
	if (s2skip != 0)
		multi = 1;
	else
		multi = 0;

	return n;
}

// return number of elements in the union of s1 and s2
// s1 and s2 are assumed to be sorted
// logic copied from set_union() in <algorithm>:
// works with multisets (skips duplicates)
// complexity:
// at most, performs 2*(count1+count2)-1 comparisons or applications of comp
// (where countX is the distance between firstX and lastX)
int
set_uni(std::vector<POLY> s1, std::vector<POLY> s2, bool &multi)
{
	std::vector<POLY>::iterator s1itr = s1.begin();
	std::vector<POLY>::iterator s2itr = s2.begin();
	POLY s1prev, s2prev;
	int n, s1skip, s2skip;

	s1prev = s2prev = n = s1skip = s2skip = 0;
	while (true) {
		// don't count duplicates
		if (s1prev == *s1itr) {
			//warnx << "skipping duplicate\n";
			++s1skip;
			++s1itr;
		} else if (s2prev == *s2itr) {
			//warnx << "skipping duplicate\n";
			++s2skip;
			++s2itr;
		} else if (*s1itr < *s2itr) {
			//warnx << "s1: " << *s1itr << "\n";
			s1prev = *s1itr;
			++s1itr;
			++n;
		} else if (*s2itr < *s1itr) {
			//warnx << "s2: " << *s2itr << "\n";
			s2prev = *s2itr;
			++s2itr;
			++n;
		} else {
			//warnx << "both: " << *s1itr << "\n";
			s1prev = *s1itr;
			s2prev = *s2itr;
			++s1itr;
			++s2itr;
			++n;
		}

		if (s1itr == s1.end()) {
			//warnx << "end of s1";
			//warnx << "n: " << n << "\n";
			while (s2itr != s2.end()) {
				//warnx << "s2: " << *s2itr << "\n";
				if (s2prev == *s2itr) {
					//warnx << "skipping duplicate\n";
					++s2skip;
					++s2itr;
					continue;
				}
				s2prev = *s2itr;
				++s2itr;
				++n;
			}
			break;
		}
		if (s2itr == s2.end()) {
			//warnx << "end of s2";
			//warnx << "n: " << n << "\n";
			while (s1itr != s1.end()) {
				//warnx << "s1: " << *s1itr << "\n";
				if (s1prev == *s1itr) {
					//warnx << "skipping duplicate\n";
					++s1skip;
					++s1itr;
					continue;
				}
				s1prev = *s1itr;
				++s1itr;
				++n;
			}
			break;
		}
	}

	//warnx << "s1skip(uni): " << s1skip << "\n";
	//warnx << "s2skip(uni): " << s2skip << "\n";
	// TODO: if s1 is multi (s1 is prevsig, s2 is cursig)
	if (s2skip != 0)
		multi = 1;
	else 
		multi = 0;

	return n;
}

// s1 and s2 are assumed to be sorted
double
signcmp(std::vector<POLY> s1, std::vector<POLY> s2, bool &multi)
{
	int ninter, nunion;

	ninter = set_inter(s1, s2, multi);
	//warnx << "intersection has " << ninter << " elements\n";

	nunion = set_uni(s1, s2, multi);
	//warnx << "union  has " << nunion << " elements\n";

	return (double)ninter/nunion;
}

// s1 and s2 are assumed to be sorted
double
signcmp_lib(std::vector<POLY> s1, std::vector<POLY> s2)
{
	std::vector<POLY> v;
	std::vector<POLY>::iterator itr;
	int ninter, nunion;

	set_intersection(s1.begin(), s1.end(), s2.end(), s2.end(), back_inserter(v));
	ninter = v.size();
	warnx << "intersection has " << ninter << " elements\n";

	v.clear();
	set_union(s1.begin(), s1.end(), s2.end(), s2.end(), back_inserter(v));
	nunion = v.size();
	warnx << "union has " << nunion << " elements\n";

	return double(ninter/nunion);
}

double
signcmp_bad(std::vector<POLY> s1, std::vector<POLY> s2)
{
	int same = 0;
	int total = 0;	

	for (int i = 0; i < (int) s1.size(); i++) {
		for (int j = 0; j < (int) s2.size(); j++) {
			if (s1[i] == s2[j])
				++same;
		}
	}

	// incorrect!
	if (s1.size() > s2.size())
		total = s1.size();
	else
		total = s2.size();

	//warnx << "\nsame: " << same << "\n";
	//warnx << "total: " << total << "\n";
	return (double)same/total;
}

void
mergebyteamid()
{
	std::vector<POLY> sig;
	int tix, tixsize, mergeix;
	int listnum = 0;

	sig.clear();
	mergeix = 0;
	for (teamid2totalT::iterator itr = teamindex.begin(); itr != teamindex.end(); itr++) {
		warnx << "teamID: " << itr->first;
		tixsize = itr->second.size();
		warnx << " tixsize: " << tixsize;
		for (int i = 0; i < tixsize; i++) {
			tix = itr->second[i];
			if (mergeix == 0) {
				mergeix = tix;
				warnx << " mergeix: " << mergeix;
			} else {
				for (mapType::iterator titr = totalT[tix][listnum].begin(); titr != totalT[tix][listnum].end(); titr++) {
					sig = titr->first;
					mapType::iterator mitr = totalT[mergeix][listnum].find(sig);
					if (mitr != totalT[mergeix][listnum].end()) {
						// update freq only!
						mitr->second[0] += titr->second[0];
						// don't touch weight (it's 1 already)
						//mitr->second[1] += titr->second[1];
					} else {
						totalT[mergeix][listnum][sig].push_back(titr->second[0]);
						// set weight to 1 because there is no gossiping
						totalT[mergeix][listnum][sig].push_back(1);
					}

				}
			}
		}
		itr->second.clear();
		itr->second.push_back(mergeix);
		mergeix = 0;
		warnx << "\n";
	}
	warnx << "teamindex.size(): " << teamindex.size() << "\n";
}

// put everything in allT[0]
void
mergeinit()
{
	mapType uniqueSigList;
	int listnum = 0;

	allT.clear();
	allT.push_back(uniqueSigList);

	for (int i = 0; i < (int)totalT.size(); i++) {
		// TODO: do we always store sigs in totalT[i][0]?
		for (mapType::iterator titr = totalT[i][listnum].begin(); titr != totalT[i][listnum].end(); titr++) {
			mapType::iterator aitr = allT[listnum].find(titr->first);
			if (aitr != allT[listnum].end()) {
				aitr->second[0] += titr->second[0];
				// don't touch weight
				//aitr->second[1] += titr->second[1];
			} else {
				allT[listnum][titr->first].push_back(titr->second[0]);
				// set weight to 1 because there is no gossiping
				allT[listnum][titr->first].push_back(1);
			}
		}
	}
}


// fixed: distinguishes b/w Vanilla and XGossip!
void
mergelists(vecomap &teamvecomap)
{
	double sumf, sumw, tmp;
	str sigbuf;
	std::vector<POLY> minsig;
	std::vector<POLY> tmpsig;
	minsig.clear();

	warnx << "merging:\n";
	
	if (vanilla == true) warnx << "vanilla: 1 dummy\n";
	else warnx << "xgossip: 2 dummies\n";

	int n = teamvecomap.size();
	warnx << "initial teamvecomap.size(): " << n << "\n";
	if (n == 1) {
		dividefreq(teamvecomap, 0, 2, 2);
		return;
	} else {
#ifdef _DEBUG_
		for (int i = 0; i < n; i++)
			printlist(teamvecomap, i, -1);
#endif
	}

	// init pointers to beginning of lists
	std::vector<mapType::iterator> citr;
	for (int i = 0; i < n; i++) {
		citr.push_back(teamvecomap[i].begin());
		//tmpsig = citr[i]->first;
		//sig2str(tmpsig, sigbuf);
		//warnx << "1st dummy: " << sigbuf << "\n";
		// SKIP 1ST DUMMY (both vanilla and xgossip)
		++citr[i];
		//tmpsig = citr[i]->first;
		//sig2str(tmpsig, sigbuf);
		//warnx << "2nd dummy: " << sigbuf << "\n";
		// SKIP 2ND DUMMY (only xgossip)
		if (vanilla == false) ++citr[i];
	}

	while (1) {
		int j = n;
		// check if at end of lists
		for (int i = 0; i < n; i++) {
			if (citr[i] == teamvecomap[i].end()) {
				//warnx << "end of T_" << i << "\n";
				--j;
			}
		}
		// done with all lists
		if (j == 0) {
			sumw = 0;
			for (int i = 0; i < n; i++) {
				tmp = sumw + teamvecomap[i][dummysig][1];
				fixnan(tmp, sumw);
				sumw = tmp;
			}
			//printdouble("new local dummy sumw/2: ", sumw/2);
			//warnx << "\n";
			tmp = sumw/2;
			fixnan(tmp, sumw);
			teamvecomap[0][dummysig][1] = tmp;
			//warnx << "mergelists: breaking from loop\n";
			break;
		}

		// find min sig
		int z = 0;
		for (int i = 0; i < n; i++) {
			// skip lists which are done
			if (citr[i] == teamvecomap[i].end()) {
				continue;
			} else if (z == 0){
				minsig = citr[i]->first;
#ifdef _DEBUG_
				sig2str(minsig, sigbuf);
				warnx << "initial minsig: "
				      << sigbuf << "\n";
#endif
				z = 1;

			}
			if (sigcmp(citr[i]->first, minsig) == 1)
				minsig = citr[i]->first;
		}

#ifdef _DEBUG_
		sig2str(minsig, sigbuf);
		warnx << "actual minsig: " << sigbuf << "\n";
#endif

		sumf = sumw = 0;
		// add all f's and w's for a particular sig
		for (int i = 0; i < n; i++) {
			// check for end of map first and then compare to minsig!
			if ((citr[i] != teamvecomap[i].end()) && (citr[i]->first == minsig)) {
				//warnx << "minsig found in T_" << i << "\n";
				tmp = sumf + citr[i]->second[0];
				fixnan(tmp, sumf);
				sumf = tmp;
				tmp = sumw + citr[i]->second[1];
				fixnan(tmp, sumw);
				sumw = tmp;
				// XXX: itr of T_0 will be incremented later
				if (i != 0) ++citr[i];
			} else {
#ifdef _DEBUG_
				warnx << "no minsig in T_" << i;
				if (citr[i] == teamvecomap[i].end()) {
					warnx << " (list ended)";
				}
				warnx << "\n";
#endif
				tmp = sumf + teamvecomap[i][dummysig][0];
				fixnan(tmp, sumf);
				sumf = tmp;
				tmp = sumw + teamvecomap[i][dummysig][1];
				fixnan(tmp, sumw);
				sumw = tmp;
			}
		}

#ifdef _DEBUG_
		printdouble("sumf: ", sumf);
		printdouble(", sumw: ", sumw);
		warnx << "\n";
#endif

		// update teamvecomap[0]
		// check for end of map first and then compare to minsig!
		if ((citr[0] != teamvecomap[0].end()) && (citr[0]->first == minsig)) {
			// update sums of existing sig
			//warnx << "T_0: updating sums of minsig\n";
			tmp = sumf/2;
			fixnan(tmp, sumf);
			teamvecomap[0][minsig][0] = tmp;
			tmp = sumw/2;
			fixnan(tmp, sumw);
			teamvecomap[0][minsig][1] = tmp;
			// XXX: see above XXX
			++citr[0];
		} else {
			/*
			warnx << "T_0: no minsig in T_0";
			if (citr[0] == teamvecomap[0].end()) {
				warnx << " (list ended)";
			}
			warnx << "\n";
			*/
			// insert new sig
			//warnx << "T_0: inserting minsig...\n";
			tmp = sumf/2;
			fixnan(tmp, sumf);
			teamvecomap[0][minsig].push_back(tmp);
			tmp = sumw/2;
			fixnan(tmp, sumw);
			teamvecomap[0][minsig].push_back(tmp);

			// not needed:
			// if the minsig was missing in T_i,
			// itr already points to the next sig
			//citr[0] = teamvecomap[0].find(minsig);
			//++citr[0];

		}
	}

	// delete all except first (doesn't free memory but it's O(1))
	while (teamvecomap.size() > 1) {
		//warnx << "teamvecomap.size(): " << teamvecomap.size() << "\n";
		teamvecomap.pop_back();
	}
	warnx << "teamvecomap.size() after pop: " << teamvecomap.size() << "\n";
	warnx << "totalT.size() after pop: " << totalT.size() << "\n";
}

// use only after gossiping is done!
void
mergelists_nogossip(vecomap &teamvecomap)
{
	double sumf, sumw;
	str sigbuf;
	std::vector<POLY> minsig;
	std::vector<POLY> tmpsig;
	minsig.clear();

	warnx << "merging (no gossip):\n";
	
	if (vanilla == true) warnx << "vanilla: 1 dummy\n";
	else warnx << "xgossip: 2 dummies\n";

	int n = teamvecomap.size();
	warnx << "initial teamvecomap.size(): " << n << "\n";
	if (n == 1) {
		// don't divide!
		//dividefreq(teamvecomap, 0, 2, 2);
		return;
	} else {
#ifdef _DEBUG_
		for (int i = 0; i < n; i++)
			printlist(teamvecomap, i, -1);
#endif
	}

	// init pointers to beginning of lists
	std::vector<mapType::iterator> citr;
	for (int i = 0; i < n; i++) {
		citr.push_back(teamvecomap[i].begin());
		//tmpsig = citr[i]->first;
		//sig2str(tmpsig, sigbuf);
		//warnx << "1st dummy: " << sigbuf << "\n";
		// SKIP 1ST DUMMY (both vanilla and xgossip)
		++citr[i];
		//tmpsig = citr[i]->first;
		//sig2str(tmpsig, sigbuf);
		//warnx << "2nd dummy: " << sigbuf << "\n";
		// SKIP 2ND DUMMY (only xgossip)
		if (vanilla == false) ++citr[i];
	}

	while (1) {
		int j = n;
		// check if at end of lists
		for (int i = 0; i < n; i++) {
			if (citr[i] == teamvecomap[i].end()) {
				//warnx << "end of T_" << i << "\n";
				--j;
			}
		}
		// done with all lists
		if (j == 0) {
			sumw = 0;
			for (int i = 0; i < n; i++) {
				sumw += teamvecomap[i][dummysig][1];
			}
			//printdouble("new local dummy sumw/2: ", sumw/2);
			//warnx << "\n";

			// don't divide!
			//teamvecomap[0][dummysig][1] = sumw/2;

			//warnx << "mergelists: breaking from loop\n";
			break;
		}

		// find min sig
		int z = 0;
		for (int i = 0; i < n; i++) {
			// skip lists which are done
			if (citr[i] == teamvecomap[i].end()) {
				continue;
			} else if (z == 0){
				minsig = citr[i]->first;
#ifdef _DEBUG_
				sig2str(minsig, sigbuf);
				warnx << "initial minsig: "
				      << sigbuf << "\n";
#endif
				z = 1;

			}
			if (sigcmp(citr[i]->first, minsig) == 1)
				minsig = citr[i]->first;
		}

#ifdef _DEBUG_
		sig2str(minsig, sigbuf);
		warnx << "actual minsig: " << sigbuf << "\n";
#endif

		sumf = sumw = 0;
		// add all f's and w's for a particular sig
		for (int i = 0; i < n; i++) {
			// check for end of map first and then compare to minsig!
			if ((citr[i] != teamvecomap[i].end()) && (citr[i]->first == minsig)) {
				//warnx << "minsig found in T_" << i << "\n";
				sumf += citr[i]->second[0];
				sumw += citr[i]->second[1];
				// XXX: itr of T_0 will be incremented later
				if (i != 0) ++citr[i];
			} else {
#ifdef _DEBUG_
				warnx << "no minsig in T_" << i;
				if (citr[i] == teamvecomap[i].end()) {
					warnx << " (list ended)";
				}
				warnx << "\n";
#endif
				sumf += teamvecomap[i][dummysig][0];
				sumw += teamvecomap[i][dummysig][1];
			}
		}

#ifdef _DEBUG_
		printdouble("sumf: ", sumf);
		printdouble(", sumw: ", sumw);
		warnx << "\n";
#endif

		// update teamvecomap[0]
		// check for end of map first and then compare to minsig!
		if ((citr[0] != teamvecomap[0].end()) && (citr[0]->first == minsig)) {
			// update sums of existing sig
			//warnx << "T_0: updating sums of minsig\n";

			// don't divide!
			//teamvecomap[0][minsig][0] = sumf/2;
			//teamvecomap[0][minsig][1] = sumw/2;

			// XXX: see above XXX
			++citr[0];
		} else {
			/*
			warnx << "T_0: no minsig in T_0";
			if (citr[0] == teamvecomap[0].end()) {
				warnx << " (list ended)";
			}
			warnx << "\n";
			*/
			// insert new sig
			//warnx << "T_0: inserting minsig...\n";

			// don't divide!
			//teamvecomap[0][minsig].push_back(sumf/2);
			//teamvecomap[0][minsig].push_back(sumw/2);

			// not needed:
			// if the minsig was missing in T_i,
			// itr already points to the next sig
			//citr[0] = teamvecomap[0].find(minsig);
			//++citr[0];

		}
	}

	// delete all except first (doesn't free memory but it's O(1))
	while (teamvecomap.size() > 1) {
		//warnx << "teamvecomap.size(): " << teamvecomap.size() << "\n";
		teamvecomap.pop_back();
	}
	warnx << "teamvecomap.size() after pop: " << teamvecomap.size() << "\n";
	warnx << "totalT.size() after pop: " << totalT.size() << "\n";
}



// obsolete
void
mergelistspold()
{
	double sumf, sumw;
	str sigbuf;
	std::vector<POLY> minsig;
	std::vector<POLY> isig;
	minsig.clear();
	isig.clear();

	warnx << "merging:\n";
	int n = allT.size();
	warnx << "initial allT.size(): " << n << "\n";
	if (n == 1) {
		dividefreq(allT, 0, 2, 2);
		return;
	} else {
#ifdef _DEBUG_
		//for (int i = 0; i < n; i++)
			//printlist(i, -1);
#endif
	}

	// init pointers to beginning of lists
	std::vector<mapType::iterator> citr;
	for (int i = 0; i < n; i++) {
		citr.push_back(allT[i].begin());
		// skip dummy
		//++citr[i];
	}

	while (1) {
		int j = n;
		// check if at end of lists
		for (int i = 0; i < n; i++) {
			if (citr[i] == allT[i].end()) {
				//warnx << "end of T_" << i << "\n";
				--j;
			}
		}
		// done with all lists
		if (j == 0) {
			/*
			sumw = 0;
			for (int i = 0; i < n; i++) {
				sumw += allT[i][dummysig][1];
			}
			printdouble("new local dummy sumw/2: ", sumw/2);
			warnx << "\n";
			allT[0][dummysig][1] = sumw/2;
			*/
			// TODO: split weight of all special multisets or is that done already?
			warnx << "done with all lists\n";
			break;
		}

		// find min sig
		int z = 0;
		for (int i = 0; i < n; i++) {
			// skip lists which are done
			if (citr[i] == allT[i].end()) {
				continue;
			// DO NOT skip special multisets
			/*
			} else if (citr[i]->first[0] == 0) {
				++citr[i];
				continue;
			*/
			} else if (z == 0) {
				minsig = citr[i]->first;
#ifdef _DEBUG_
				sig2str(minsig, sigbuf);
				warnx << "initial minsig: "
				      << sigbuf << "\n";
#endif
				z = 1;

			}

			if (sigcmp(citr[i]->first, minsig) == 1)
				minsig = citr[i]->first;
		}

#ifdef _DEBUG_
		sig2str(minsig, sigbuf);
		warnx << "actual minsig: " << sigbuf << "\n";

		if (minsig[0] == 0) {
			warnx << "minsig is a special multiset\n";
		}
#endif

		sumf = sumw = 0;
		// add all f's and w's for a particular sig
		for (int i = 0; i < n; i++) {
			if ((citr[i] != allT[i].end()) && (citr[i]->first == minsig)) {
				//warnx << "minsig found in T_" << i << "\n";
				sumf += citr[i]->second[0];
				sumw += citr[i]->second[1];
				// XXX: itr of T_0 will be incremented later
				if (i != 0) ++citr[i];
			} else if (minsig[0] != 0) {
#ifdef _DEBUG_
				warnx << "no minsig in T_" << i
				      << " (list ended)\n";
#endif
				isig.clear();
				isig = inverse(minsig);
				mapType::iterator itr = allT[i].find(isig);
				if (itr != allT[i].end()) {
#ifdef _DEBUG_
					warnx << "special minsig found in T_" << i << "\n";
#endif
					sumf += allT[i][isig][0];
					sumw += allT[i][isig][1];
				}
			}
			// DO NOT skip lists which are done:
			// use special multiset
		
			// DO NOT skip special multisets?
			/*
			} else if (citr[i]->first[0] == 0) {
				++citr[i];
				continue;
			} else if (minsig[0] != 0) {
				// use special multiset based on LSH (instead of isig)
				//tmpsig = minsig;
				//lsh *myLSH = new lsh(tmpsig.size(), lfuncs, mgroups, lshseed, irrpolyfile);
				// TODO: verify getUniqueSet works right
				//myLSH->getUniqueSet(tmpsig);
				//std::vector<chordID> minhash = myLSH->getHashCode(tmpsig);

				isig.clear();
				isig = inverse(minsig);
				mapType::iterator itr = allT[i].find(isig);
				if (itr != allT[i].end()) {
					warnx << "no minsig in T_" << i << "\n";
					sumf += allT[i][isig][0];
					sumw += allT[i][isig][1];
				}
			}
			*/
		}

#ifdef _DEBUG_
		printdouble("sumf: ", sumf);
		printdouble(", sumw: ", sumw);
		warnx << "\n";
#endif

		// update allT[0]
		if (citr[0]->first == minsig) {
			// update sums of existing sig
			//warnx << "updating sums of minsig\n";
			allT[0][minsig][0] = sumf/2;
			allT[0][minsig][1] = sumw/2;
			// XXX: see above XXX
			++citr[0];
		} else {
			// insert new sig
			//warnx << "inserting minsig...\n";
			allT[0][minsig].push_back(sumf/2);
			allT[0][minsig].push_back(sumw/2);

			// not needed:
			// if the minsig was missing in T_i,
			// itr already points to the next sig
			//citr[0] = allT[0].find(minsig);
			//++citr[0];

		}
	}

	// delete all except first (doesn't free memory but it's O(1))
	while (allT.size() > 1) allT.pop_back();
	warnx << "allT.size() after pop: " << allT.size() << "\n";
}

// TODO: obsolete?
void
doublefreqgroup(int listnum, mapType groupbyid)
{
	double freq, weight;

	warnx << "doublefreqgroup: setsize: " << groupbyid.size() << "\n";
	for (mapType::iterator itr = groupbyid.begin(); itr != groupbyid.end(); itr++) {
		mapType::iterator jitr = allT[listnum].find(itr->first);
		if (jitr != allT[listnum].end()) {
			freq = itr->second[0];
			jitr->second[0] = freq * 2;
			weight = itr->second[1];
			jitr->second[1] = weight * 2;
		}
	}
}

void
multiplyfreq(vecomap &teamvecomap, int listnum, int fby, int wby)
{
	double freq, weight, tmp;

	mapType::iterator itr = teamvecomap[listnum].begin();
	// skip dummysig if multiplying freq to increase the total number of sigs
	// don't skip it if unsuccessful insert (fby == wby)
	if ((itr->first == dummysig) && (fby != wby)) {
		warnx << "multiplyfreq: skipping dummysig\n";
		++itr;
	}

	// TODO: will it bomb if teamvecomap only contains dummysig?
	for (; itr != teamvecomap[listnum].end(); itr++) {
		freq = itr->second[0];
		tmp = freq * fby;
		fixnan(tmp, freq);
		itr->second[0] = tmp;
		weight = itr->second[1];
		tmp = weight * wby;
		fixnan(tmp, weight);
		itr->second[1] = tmp;
	}
	warnx << "multiplyfreq(" << fby << ", " << wby << "): setsize: " << teamvecomap[listnum].size() << "\n";
}

void
dividefreq(vecomap &teamvecomap, int listnum, int fby, int wby)
{
	double freq, weight, tmp;

	for (mapType::iterator itr = teamvecomap[listnum].begin(); itr != teamvecomap[listnum].end(); itr++) {

		freq = itr->second[0];
		tmp = freq / fby;
		fixnan(tmp, freq);
		itr->second[0] = tmp;

		weight = itr->second[1];
		tmp = weight / wby;
		fixnan(tmp, weight);
		itr->second[1] = tmp;
	}
	warnx << "dividefreq(" << fby << ", " << wby << "): setsize: " << teamvecomap[listnum].size() << "\n";
}

// obsolete
void
delspecial(int listnum)
{
	std::vector<POLY> isig;
	isig.clear();

	warnx << "delspecial: setsize before: " << allT[listnum].size() << "\n";
	for (mapType::iterator itr = allT[listnum].begin(); itr != allT[listnum].end(); itr++) {
		if (itr->first[0] == 0) {
			isig = inverse(itr->first);
			mapType::iterator regitr = allT[listnum].find(isig);
			if (regitr != allT[listnum].end()) {
				// itr is special multiset
				allT[listnum].erase(itr);
			}
		}
	}
	warnx << "delspecial: setsize after: " << allT[listnum].size() << "\n";
}

void
vecomap2vec(vecomap teamvecomap, int listnum, std::vector<std::vector <POLY> >&sigList, std::vector<double> &freqList, std::vector<double> &weightList)
{
	for (mapType::iterator itr = teamvecomap[listnum].begin(); itr != teamvecomap[listnum].end(); itr++) {
		sigList.push_back(itr->first);
		freqList.push_back(itr->second[0]);
		weightList.push_back(itr->second[1]);
	}
}

void
lvecomap2vec(lvecomap teamvecomap, int listnum, std::vector<std::vector <POLY> >&sigList, std::vector<long double> &freqList, std::vector<long double> &weightList)
{
	for (lmapType::iterator itr = teamvecomap[listnum].begin(); itr != teamvecomap[listnum].end(); itr++) {
		sigList.push_back(itr->first);
		freqList.push_back(itr->second[0]);
		weightList.push_back(itr->second[1]);
	}
}

std::string
itostring(int num)
{
	std::ostringstream oss;
	oss << num;
	return oss.str();
}

// verified
void
printdouble(std::string fmt, double num)
{
	std::ostringstream oss;
	std::string ss;

	oss << num;
	ss = oss.str();
	warnx << fmt.c_str() << ss.c_str();
}

// verified
void
lprintdouble(std::string fmt, long double num)
{
	std::ostringstream oss;
	std::string ss;

	oss << num;
	ss = oss.str();
	warnx << fmt.c_str() << ss.c_str();
}

void
printteamidfreq()
{
	warnx << "printteamidfreq:\n";

	for (teamidfreq::iterator itr = teamidminhash.begin(); itr != teamidminhash.end(); itr++) {
		warnx << "teamID: " << itr->first;
		warnx << " freq: " << itr->second;
		warnx << "\n";
	}
	warnx << "teamidminhash.size(): " << teamidminhash.size() << "\n";
}

void
printteamids()
{
	double avglists, avgsigspteamid;
	int nlists, high, low, tixsize, sigspteamid, totalsigspteamid;

	totalsigspteamid = 0;
	nlists = 0;
	// set to extreme values
	high = 0;
	low = teamsize;

	warnx << "printteamids:\n";

	for (teamid2totalT::iterator itr = teamindex.begin(); itr != teamindex.end(); itr++) {
		warnx << "teamID: " << itr->first;
		tixsize = itr->second.size();
		nlists += tixsize;
		if (low > tixsize) low = tixsize;
		if (high < tixsize) high = tixsize;
		warnx << " tixsize: " << tixsize;
		warnx << " tix: ";
		sigspteamid = 0;
		for (int i = 0; i < tixsize; i++) {
			sigspteamid += totalT[itr->second[i]][0].size();
			warnx << itr->second[i] << ", ";
		}
		while (tixsize < teamsize) {
			warnx << "na, ";
			++tixsize;	
		}
		warnx << "\n";
		totalsigspteamid += sigspteamid;
		warnx << "sigspteamid: " << sigspteamid;
		warnx << " teamID: " << itr->first;
		warnx << "\n";
	}
	warnx << "teamindex.size(): " << teamindex.size() << "\n";
	warnx << "total sigs/teamID: " << totalsigspteamid << "\n";
	avgsigspteamid = (double)totalsigspteamid / (double)teamindex.size();
	printdouble("avg sigs/teamID: ", avgsigspteamid);
	warnx << "\n";
	avglists = (double)nlists / (double)teamindex.size();
	printdouble("avg lists/teamID: ", avglists);
	warnx << "\n";
	warnx << "lowest # of lists/teamID: " << low << "\n";
	warnx << "highest # of lists/teamID: " << high << "\n";
}

// print all lists and teamIDs
int
printlistall(int seq)
{
	chordID teamID;
	int totalsigs = 0;

	for (int i = 0; i < (int)totalT.size(); i++) {
		teamID = findteamid(i);
		if (teamID == NULL) {
			warnx << "printlistall: teamID is NULL\n";
			continue;
		}
		warnx << "list T_0: txseq: " << seq
		      << " teamID(i=" << i << "): " << teamID
		      << " len: " << totalT[i][0].size() << "\n";
		totalsigs += printlist(totalT[i], 0, seq, false);
	}

	warnx << "totalsigs: " << totalsigs << "\n";
	return totalsigs;
}

// print all lists and teamIDs
int
lprintlistall(int seq)
{
	chordID teamID;
	int totalsigs = 0;

	for (int i = 0; i < (int)totalT.size(); i++) {
		teamID = findteamid(i);
		if (teamID == NULL) {
			warnx << "lprintlistall: teamID is NULL\n";
			continue;
		}
		warnx << "list T_0: txseq: " << seq
		      << " teamID(i=" << i << "): " << teamID
		      << " len: " << totalT[i][0].size() << "\n";
		totalsigs += printlist(totalT[i], 0, seq, false);
		// TODO
		//totalsigs += lprintlist(totalT[i], 0, seq, false);
	}

	warnx << "totalsigs: " << totalsigs << "\n";
	return totalsigs;
}

int
printlist(vecomap teamvecomap, int listnum, int seq, bool hdr)
{
	bool multi;
	int n, nmulti, ixsim, setsize, totalsigs;
	double freq, weight, avg;
	double sumavg, sumsum;
	double avgsim, highsim, cursim;
	std::vector<POLY> sig;
	std::vector<POLY> prevsig;
	sig.clear();
	prevsig.clear();
	str sigbuf;

	sumavg = sumsum = 0;
	avgsim = highsim = cursim = 0;
	totalsigs = n = nmulti = ixsim = 0;

	// print header
	if (hdr == true) {
		warnx << "list T_" << listnum << ": txseq: " << seq
		      << " len: " << teamvecomap[listnum].size() << "\n";
	}

	warnx << "hdrB: sig freq weight avg avg*peers avg*teamsize cmp2prev multi size\n";
	for (mapType::iterator itr = teamvecomap[listnum].begin(); itr != teamvecomap[listnum].end(); itr++) {
		sig = itr->first;
		freq = itr->second[0];
		weight = itr->second[1];
		++totalsigs;
		avg = freq / weight;
		sumavg += avg;
		sumsum += (avg * peers);
		sig2str(sig, sigbuf);
		warnx << "sig" << n << ": " << sigbuf;
		printdouble(" ", freq);
		printdouble(" ", weight);
		printdouble(" ", avg);
		printdouble(" ", avg * peers);
		printdouble(" ", avg * teamsize);
		// only check if 1st sig is a multiset
		if (n == 0) {
			prevsig = sig;
			cursim = signcmp(prevsig, sig, multi);
			cursim = 0;
		} else {
			cursim = signcmp(prevsig, sig, multi);
		}
		avgsim += cursim;
		if (multi == 1) ++nmulti;
		if (highsim < cursim) {
			highsim = cursim;
			ixsim = n;
		}
		printdouble(" ", cursim);
		warnx << " " << multi;
		warnx << " " << sig.size() * sizeof(POLY) << "\n";
		++n;
		prevsig = sig;
	}
	warnx << "hdrE: sig freq weight avg avg*peers avg*teamsize cmp2prev multi size\n";
	printdouble("printlist: sumavg: ", sumavg);
	printdouble(" multisetsize: ", sumsum);
	// subtract dummy (what about 2 dummies?)
	setsize = teamvecomap[listnum].size() - 1;
	warnx << " setsize: " << setsize;
	warnx << " highsim@@sig" << ixsim;
	printdouble(": ", highsim);
	// 1st sig doesn't have sim
	if ((setsize - 1) == 0)
		avgsim = 0;
	else
		avgsim /= (setsize - 1);
	printdouble(" avgsim: ", avgsim);
	warnx << " multisets: " << nmulti << "\n";

	// subtract dummies
	return totalsigs - 2;
}

int
lprintlist(lvecomap teamvecomap, int listnum, int seq, bool hdr)
{
	bool multi;
	int n, nmulti, ixsim, setsize, totalsigs;
	long double freq, weight, avg;
	long double sumavg, sumsum;
	long double avgsim, highsim, cursim;
	std::vector<POLY> sig;
	std::vector<POLY> prevsig;
	sig.clear();
	prevsig.clear();
	str sigbuf;

	sumavg = sumsum = 0;
	avgsim = highsim = cursim = 0;
	totalsigs = n = nmulti = ixsim = 0;

	// print header
	if (hdr == true) {
		warnx << "list T_" << listnum << ": txseq: " << seq
		      << " len: " << teamvecomap[listnum].size() << "\n";
	}

	warnx << "hdrB: sig freq weight avg avg*peers avg*teamsize cmp2prev multi size\n";
	for (lmapType::iterator itr = teamvecomap[listnum].begin(); itr != teamvecomap[listnum].end(); itr++) {
		sig = itr->first;
		freq = itr->second[0];
		weight = itr->second[1];
		++totalsigs;
		avg = freq / weight;
		sumavg += avg;
		sumsum += (avg * peers);
		sig2str(sig, sigbuf);
		warnx << "sig" << n << ": " << sigbuf;
		lprintdouble(" ", freq);
		lprintdouble(" ", weight);
		lprintdouble(" ", avg);
		lprintdouble(" ", avg * peers);
		lprintdouble(" ", avg * teamsize);
		// only check if 1st sig is a multiset
		if (n == 0) {
			prevsig = sig;
			cursim = signcmp(prevsig, sig, multi);
			cursim = 0;
		} else {
			cursim = signcmp(prevsig, sig, multi);
		}
		avgsim += cursim;
		if (multi == 1) ++nmulti;
		if (highsim < cursim) {
			highsim = cursim;
			ixsim = n;
		}
		lprintdouble(" ", cursim);
		warnx << " " << multi;
		warnx << " " << sig.size() * sizeof(POLY) << "\n";
		++n;
		prevsig = sig;
	}
	warnx << "hdrE: sig freq weight avg avg*peers avg*teamsize cmp2prev multi size\n";
	lprintdouble("printlist: sumavg: ", sumavg);
	lprintdouble(" multisetsize: ", sumsum);
	// subtract dummy (what about 2 dummies?)
	setsize = teamvecomap[listnum].size() - 1;
	warnx << " setsize: " << setsize;
	warnx << " highsim@@sig" << ixsim;
	lprintdouble(": ", highsim);
	// 1st sig doesn't have sim
	if ((setsize - 1) == 0)
		avgsim = 0;
	else
		avgsim /= (setsize - 1);
	lprintdouble(" avgsim: ", avgsim);
	warnx << " multisets: " << nmulti << "\n";

	// subtract dummies
	return totalsigs - 2;
}

void
usage(void)
{
	warn << "Usage: " << __progname << " [-h] [actions...] [options...]\n\n";
	warn << "EXAMPLES:\n\n";
	warn << "Send signature query:\n";
	warn << "\t" << __progname << " -Q -S dhash-sock -s sigdir -F hashfile -d 1122941 -j irrpoly-deg9.dat -B 5 -R 10 -Z 4\n\n";
	warn << "Send xpath query:\n";
	warn << "\t" << __progname << " -Q -S dhash-sock -x xpathdir -F hashfile -d 1122941 -j irrpoly-deg9.dat -B 10 -R 16\n\n";
	warn << "LSH on sig dir:\n";
	warn << "\t" << __progname << " -H -I -s sigdir -F hashfile -d 1122941 -j irrpoly-deg9.dat -B 10 -R 16 -p\n\n";
	warn << "Generate init file for sigdir:\n";
	warn << "\t" << __progname << " -r -s sigdir -P initfile\n\n";
	warn << "VanillaXGossip:\n";
	warn << "\t" << __progname << " -S dhash-sock -G g-sock -L log.gpsi -s sigdir -g -t 120 -q 165 -p\n\n";
	warn << "XGossip:\n";
	warn << "\t" << __progname << " -S dhash-sock -G g-sock -L log.gpsi -s sigdir -g -t 120 -T 1 -w 900\n"
	     << "\t     -H -d 1122941 -j irrpoly-deg9.dat -B 50 -R 10 -I -E -P initfile -p\n\n";
	warn << "Broadcast:\n";
	warn << "[TODO]\n";
	warn << "XGossip exec (churn peers):\n";
	warnx << "\t" << __progname << " -c -L log.gpsi -t 240 -A 9555 -q 1000 -N 20 -o 20 -k 5 -W 300\n\n";
	warn << "OPTIONS:\n\n"
             << "\tACTIONS (optional):\n"
	     << "	-C		compress signatures (XGossip exec only)\n"
	     << "	-H		generate chordIDs/POLYs using LSH when gossiping\n"
					"\t\t\t(requires -g, -s, -d, -j, -I, -w, -F)\n"
	     << "      	-m		use findMod instead of compute_hash\n"
					"\t\t\t(vector of POLYs instead of chordIDs)\n"
	     << "      	-p		verbose (print list of signatures)\n"
	     << "(	-u		make POLYs unique (convert multiset to set))\n"
					"\t\t\t(don't use)\n\n"

             << "\tDIRECTORIES:\n"
	     << "	-D		<dir with files to be merged>\n"
	     << "	-O		<dir with proxy sig>\n"
	     << "	-s		<dir with sigs>\n"
	     << "	-x		<dir with xpath files>\n\n"

             << "\tFILES:\n"
	     << "      	-F		<hash funcs file>\n"
	     << "      	-f		<killed hosts file>\n"
	     << "      	-i		<chordIDs file>\n"
	     << "      	-j		<irrpoly file>\n"
	     << "	-L		<log file>\n"
	     << "      	-P		<init phase file>\n"
					"\t\t\t(after XGossip init state is complete)\n\n"

             << "\tNUMBERS:\n"
	     << "	-A		<bootstrap port>\n"
	     << "	-B		<bands for LSH>\n"
					"\t\t\t(a.k.a. m groups)\n"
	     << "	-d		<random prime number for LSH seed>\n"
	     << "	-K		<range of rounds to kill itself>\n"
	     << "	-k		<session rounds for churn peers>\n"
	     << "      	-N		<how many instances/nodes>\n"
	     << "      	-n		<how many chordIDs>\n"
	     << "      	-o		<how many rounds>\n"
	     << "      	-q		<estimate of # of peers in DHT>\n"
	     << "	-R		<rows for LSH>\n"
					"\t\t\t(a.k.a. l hash functions)\n"
	     << "	-U		<my chordID>\n"
	     << "	-X		<how many times>\n"
					"\t\t\t(multiply freq of sigs by)\n"
	     << "	-Z		<team size>\n\n"

             << "\tPHASES/TYPES:\n"
	     << "	-E		exec phase of XGossip (requires -H)\n"
	     << "	-I		init phase of XGossip (requires -H)\n"
	     << "	-y		<init | results>\n"
					"\t\t\t(type for merging)\n\n"

             << "\tSOCKETS:\n"
	     << "	-G		<gossip socket>\n"
	     << "	-S		<dhash socket>\n\n"

             << "\tTIMES:\n"
	     << "      	-T		<how often>\n"
					"\t\t\t(interval between inserts in XGossip)\n"
	     << "      	-t		<how often>\n"
					"\t\t\t(gossip interval)\n"
	     << "      	-W		<how long>\n"
                                        "\t\t\t(wait interval before init/exec phase starts)\n"
	     << "      	-w		<how long>\n"
					"\t\t\t(wait interval after XGossip init phase is done)\n\n"

	     << "ACTIONS:\n"
	     << "	-b		broadcast: no gossip\n"
					"\t\t\t(use baseline broadcast protocol instead)\n"
	     << "	-c		simulate churn: discard messages (requires -t, -A, -q, -N, -o, -W)\n"
	     << "	-g		gossip (requires -S, -G, -s, -t)\n"
	     << "	-H		generate chordIDs/POLYs using LSH (requires  -s, -d, -j, -F)\n"
					"\t\t\t(XGossip)\n"
	     << "	-l		listen for gossip (requires -S, -G, -s)\n"
	     << "	-M		merge {results | init states} (requires -D, -y, -Z)\n"
	     << "	-Q		send query (requires -S, -d, -j, -s or -x)\n"
	     << "	-r		read signatures (requires -s and/or -x)\n"
	     << "	-V		Vanilla (when querying)\n"
	     << "	-v		print version\n"
	     << "	-z		generate random chordID (requires -n)\n";
	exit(0);
}
@


1.130
log
@fixed 11 to 20 kill range
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.129 2012/12/20 18:47:54 vsfgd Exp vsfgd $	*/
d35 1
a35 1
static char rcsid[] = "$Id: gpsi.C,v 1.129 2012/12/20 18:47:54 vsfgd Exp vsfgd $";
d2651 1
@


1.129
log
@corrected kill round range random selection
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.128 2012/12/19 21:55:14 vsfgd Exp vsfgd $	*/
d35 1
a35 1
static char rcsid[] = "$Id: gpsi.C,v 1.128 2012/12/19 21:55:14 vsfgd Exp vsfgd $";
d1878 2
d1881 5
a1885 5
		if (killroundrange == 10) {
			range = killroundrange - 1 + 1;
		// b/w 10 and 20
		} else if (killroundrange == 20) {
			range = killroundrange - 10 + 1;
d1889 2
a1890 1
		killround = rand() % range + 1;
@


1.128
log
@added ability of peers to kill themselves (and their Chord procs)
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.127 2012/11/28 17:05:04 vsfgd Exp vsfgd $	*/
d35 1
a35 1
static char rcsid[] = "$Id: gpsi.C,v 1.127 2012/11/28 17:05:04 vsfgd Exp vsfgd $";
d1876 12
a1887 2
		// TODO: verify range
		killround = rand() % killroundrange + 1;
@


1.127
log
@paths modified for ec2
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.126 2012/11/28 06:37:20 vsfgd Exp vsfgd $	*/
d18 1
d35 1
a35 1
static char rcsid[] = "$Id: gpsi.C,v 1.126 2012/11/28 06:37:20 vsfgd Exp vsfgd $";
d52 1
d57 2
d89 1
d985 1
a985 1
	int Gflag, Lflag, lflag, rflag, Sflag, sflag, Oflag, zflag, vflag, Hflag, dflag, jflag, mflag, Iflag, Eflag, Pflag, Dflag, Mflag, Fflag, xflag, yflag, Zflag, Uflag, iflag;
d992 2
d1013 1
d1033 1
a1033 1
	Gflag = Lflag = lflag = rflag = Sflag = sflag = Oflag = zflag = vflag = Hflag = dflag = jflag = mflag = Eflag = Iflag = Pflag = Dflag = Mflag = Fflag = xflag = yflag = Zflag = Uflag = iflag = 0;
d1048 1
a1048 1
	while ((ch = getopt(argc, argv, "A:bB:CcD:d:EF:G:gHhIi:j:k:L:lMmN:n:O:o:P:pQq:R:rS:s:T:t:U:uVvW:w:X:x:y:Z:z")) != -1)
d1083 4
d1114 3
d1342 4
d1368 15
d1855 5
d1872 8
d1938 1
a1938 1
		std::string cmd = scripts + "/join_chord.sh " + sbport + " " + slport + " " + myroot;
d2463 13
d2561 1
d2571 1
d6195 1
d6207 1
@


1.126
log
@added churn
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.125 2012/10/25 22:11:57 vsfgd Exp vsfgd $	*/
d34 1
a34 1
static char rcsid[] = "$Id: gpsi.C,v 1.125 2012/10/25 22:11:57 vsfgd Exp vsfgd $";
d73 1
a73 1
int ninstances = 0;
d1849 1
a1849 1
		std::string myuser = "vsfgd";
d1852 1
a1852 1
		std::string churnlsdroot = myhome + "/tmp.churn.lsd";
@


1.125
log
@drop lists when receiving bcast msgs for now
print end broadcast time
print shuffled ids
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.124 2012/10/25 20:24:11 vsfgd Exp vsfgd $	*/
d34 1
a34 1
static char rcsid[] = "$Id: gpsi.C,v 1.124 2012/10/25 20:24:11 vsfgd Exp vsfgd $";
d67 1
d73 1
a73 1
int ninstances = 20;
d84 1
d179 1
d984 3
d1040 1
a1040 1
	while ((ch = getopt(argc, argv, "bB:CcD:d:EF:G:gHhIi:j:L:lMmN:n:O:o:P:pQq:R:rS:s:T:t:U:uVvW:w:X:x:y:Z:z")) != -1)
d1042 3
d1058 1
a1058 1
			discardmsg = 1;
d1102 3
d1279 1
a1279 1
	if (rflag == 0 && gflag == 0 && lflag == 0 && Hflag == 0 && Mflag == 0 && Qflag == 0) usage();
d1287 2
d1831 2
d1837 72
d1987 1
a1987 1
		warnx << "interval b/w inserts: " << initintval << "\n";
d2089 1
a2498 1
			/*
a2509 1
			*/
d2546 1
d2549 1
d2591 1
a2591 1
				warnx << "qid,querysig,sigmatches: est,sigmatches: true,sigmatches: rel error (%),freq (*teamsize): est,freq (*instances): true,freq: rel error (%),proxy lsh misses,query lsh misses,avg inter,query minsim,query avgsim,proxy minsim,proxy avgsim,query minsim > proxy minsim,teamIDs\n";
d2636 1
a2636 1
						for (int i = 0; i < (int)sitr->second.size(); i++ ) {
d2657 8
d2749 5
d2768 9
d2851 1
d3313 1
a3313 1
			warnx << "TODO: addvecomapx() and merge\n";
d5790 8
d6110 4
a6116 1
	     << "	-c		discard out-of-round messages\n"
d6140 1
d6144 1
d6179 1
@


1.124
log
@don't multiply freq if insert fails
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.123 2012/10/25 17:18:04 vsfgd Exp vsfgd $	*/
d34 1
a34 1
static char rcsid[] = "$Id: gpsi.C,v 1.123 2012/10/25 17:18:04 vsfgd Exp vsfgd $";
d1449 1
a1449 2
		/*
		warnx << "after shuffle:\n";
a1451 1
		*/
d1937 1
d1948 1
d1951 1
d1965 1
d2001 6
d3200 2
@


1.123
log
@added baseline broadcast algorithm (per VLDB revisions 1)
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.122 2012/07/11 13:53:13 vsfgd Exp vsfgd $	*/
d34 1
a34 1
static char rcsid[] = "$Id: gpsi.C,v 1.122 2012/07/11 13:53:13 vsfgd Exp vsfgd $";
a1978 3
				// to preserve mass conservation:
				// "send" msg to yourself (double freq)
				multiplyfreq(totalT[0], 0, 2, 2);
d1998 1
@


1.122
log
@merge by teamID (-M)
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.121 2012/05/10 03:03:14 vsfgd Exp vsfgd $	*/
d34 1
a34 1
static char rcsid[] = "$Id: gpsi.C,v 1.121 2012/05/10 03:03:14 vsfgd Exp vsfgd $";
d47 1
d51 1
d55 1
d80 1
d977 1
a977 1
	int Gflag, Lflag, lflag, rflag, Sflag, sflag, Oflag, zflag, vflag, Hflag, dflag, jflag, mflag, Iflag, Eflag, Pflag, Dflag, Mflag, Fflag, xflag, yflag, Zflag;
d1019 1
a1019 1
	Gflag = Lflag = lflag = rflag = Sflag = sflag = Oflag = zflag = vflag = Hflag = dflag = jflag = mflag = Eflag = Iflag = Pflag = Dflag = Mflag = Fflag = xflag = yflag = Zflag = 0;
d1034 1
a1034 1
	while ((ch = getopt(argc, argv, "B:CcD:d:EF:G:gHhIj:L:lMmN:n:O:o:P:pQq:R:rS:s:T:t:uVvW:w:X:x:y:Z:z")) != -1)
d1039 3
d1069 4
d1143 5
d1407 1
a1407 1
	// load irrpoly.dat polys in memory
d1422 34
d1819 1
d1897 104
d2002 1
a2002 1
	if (gflag == 1 && Hflag == 0) {
d2404 2
d2416 2
d3103 1
a3103 1
	if (msgtype == VXGOSSIP || msgtype == VXGOSSIPC || msgtype == XGOSSIP || msgtype == XGOSSIPC) {
d3109 7
d3145 1
a3145 1
		if (msgtype == XGOSSIP || msgtype == XGOSSIPC) warnx << " teamID: " << keyteamid;
d3194 1
d4553 9
a4561 8
		/*
		warnx << "teamID NOT found: adding new vecomap\n";
		warnx << "totalT.size() [before]: " << totalT.size() << "\n";
		tmpvecomap.push_back(uniqueSigList);
		totalT.push_back(tmpvecomap);
		tind = totalT.size() - 1;
		teamindex[teamID].push_back(tind);
		*/
d6002 1
d6018 1
d6044 2
@


1.121
log
@lfreq -> freq
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.120 2012/05/10 00:11:39 vsfgd Exp vsfgd $	*/
d34 1
a34 1
static char rcsid[] = "$Id: gpsi.C,v 1.120 2012/05/10 00:11:39 vsfgd Exp vsfgd $";
d136 1
d187 1
d2250 11
d4795 45
a4839 1
// put everything in allT
d5542 2
a5543 2
	double avglists;
	int nlists, high, low, tixsize;
d5545 1
d5561 8
a5568 6
		if (tixsize > 1) {
			for (int i = 0; i < tixsize; i++) {
				warnx << itr->second[i] << ", ";
			}
		} else {
			warnx << itr->second[0];
d5571 4
d5577 4
@


1.120
log
@fixed segfault (calling long double func)
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.119 2012/05/09 22:55:43 vsfgd Exp vsfgd $	*/
d34 1
a34 1
static char rcsid[] = "$Id: gpsi.C,v 1.119 2012/05/09 22:55:43 vsfgd Exp vsfgd $";
d1951 1
a1951 1
					makeKeyValue(&value, valLen, key, key, compressedList, outBitmap, lfreqList, lweightList, txseq.back(), VXGOSSIPC);
@


1.119
log
@added 'long double' versions of most functions and data structures
check for nan and inf in: mergelists, dividefreq, multiplyfreq
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.118 2012/04/30 21:45:45 vsfgd Exp vsfgd $	*/
d34 1
a34 1
static char rcsid[] = "$Id: gpsi.C,v 1.118 2012/04/30 21:45:45 vsfgd Exp vsfgd $";
d1493 1
d1598 1
@


1.118
log
@fix: don't divide freq,weight by 2 when merging after gossiping is done
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.117 2012/04/23 16:24:08 vsfgd Exp vsfgd $	*/
d14 2
d34 1
a34 1
static char rcsid[] = "$Id: gpsi.C,v 1.117 2012/04/23 16:24:08 vsfgd Exp vsfgd $";
d114 2
d118 1
d126 1
d161 1
d168 1
d190 1
d192 1
d194 1
d217 1
d1003 2
d1210 13
a1222 6
		double dtype = 0.0556211;
		long double ldtype = 0.0556211;

		printdouble("dtype: %f\n", dtype);
		printdouble("ldtype: %f\n", ldtype);
		for (int i = 0; i < 10; i++) {
d1225 17
a1241 6
			std::cout << "dtype: " << dtype << "\n";
			printdouble("pdtype: ", dtype);
			std::cout << "\n";
			std::cout << "ldtype: " << ldtype << "\n";
			printdouble("pldtype: ", ldtype);
			std::cout << "\n";
d1438 2
d1451 2
d1497 3
a1499 3
			freqList.clear();
			weightList.clear();
			vecomap2vec(allT, 0, sigList, freqList, weightList);
d1542 1
a1542 1
			warnx << "numSigs: " << freqList.size() << "\n";
d1544 1
a1544 1
			makeKeyValue(&value, valLen, key, teamID, compressedList, outBitmap, freqList, weightList, txseq.back(), XGOSSIPC);
d1555 2
a1556 2
			freqList.clear();
			weightList.clear();
d1558 1
a1558 1
			int ret = getKeyValue(value, newkey, newteamID, compressedList, outBitmap, numSigs, freqList, weightList, seq, valLen);
d1758 1
a1758 1
	warnx << "ninstances: " << ninstances << "\n";
d1857 3
a1859 2
			// by default, gossip indefinitely
			if (txseq.back() == rounds) {
d1863 1
d1868 1
d1872 2
a1873 2
				// stop gossiping, only listen
				break;
d1883 8
a1890 2
			// store everything in totalT[0]
			mergelists(totalT[0]);
d1895 3
a1897 1
			if (plist == 1) {
d1899 2
d1903 26
a1928 22
			warnx << "inserting ";
			if (compress == 1) warnx << "VXGOSSIPC:\n";
			else warnx << "VXGOSSIP:\n";

			warnx << "txseq: " << txseq.back() << "\n";
			warnx << "txID: " << ID << "\n";

			if (compress == 1) {
				compressedList.clear();
				outBitmap.clear();
				sigList.clear();
				freqList.clear();
				weightList.clear();
				vecomap2vec(totalT[0], 0, sigList, freqList, weightList);

				int sigbytesize = 0;
				warnx << "sigs before compression:\n";
				for (int i = 0; i < (int)sigList.size(); i++) {
					sigbytesize += (sigList[i].size() * sizeof(POLY));
					//sig2str(sigList[i], sigbuf);
					//warnx << "sig[" << i << "]: " << sigbuf << "\n";
				}
d1930 12
a1941 12
				warnx << "sigList size (bytes): " << sigbytesize << "\n";
				warnx << "sigList.size() (unique): " << sigList.size() << "\n";
				compressSignatures(sigList, compressedList, outBitmap);

				int compressedsize = compressedList.size() * sizeof(POLY);
				warnx << "compressedList size (bytes): " << compressedsize << "\n";
				warnx << "compressedList.size(): " << compressedList.size() << "\n";

				int bitmapsize = 0;
				for (int i = 0; i < (int)outBitmap.size(); i++) {
					bitmapsize += (outBitmap[i].size() * sizeof(unsigned char));
				}
d1943 2
a1944 2
				warnx << "outBitmap size (bytes): " << bitmapsize << "\n";
				warnx << "outBitmap.size(): " << outBitmap.size() << "\n";
d1946 1
a1946 1
				warnx << "total compressed size (list+bitmap): " << compressedsize + bitmapsize << "\n";
d1948 5
a1952 5
				// after merging, everything is stored in totalT[0][0]
				makeKeyValue(&value, valLen, key, key, compressedList, outBitmap, freqList, weightList, txseq.back(), VXGOSSIPC);
			} else {
				makeKeyValue(&value, valLen, key, key, totalT[0][0], txseq.back(), VXGOSSIP);
			}
d1954 4
a1957 4
			totaltxmsglen += valLen;
			roundtxmsglen += valLen;
			status = insertDHT(ID, value, valLen, instime, MAXRETRIES);
			cleanup(value);
d1959 9
a1967 8
			// do not exit if insert FAILs!
			if (status != SUCC) {
				warnx << "error: insert FAILed\n";
				// to preserve mass conservation:
				// "send" msg to yourself (double freq)
				multiplyfreq(totalT[0], 0, 2, 2);
			} else {
				warnx << "insert SUCCeeded\n";
a1968 1
			txseq.push_back(txseq.back() + 1);
d1972 1
a1973 1
			//sleep(gintval);
d2051 5
a2055 5
			if (mflag == 1) {
				fatal << "not implemented\n";
			// use compute_hash()
			} else {
				if (gossipdone == false) {
a2156 8
				warnx << "roundtxmsglen: " << roundtxmsglen;
				warnx << " txseq: " << txseq.back() << "\n";
				roundtxmsglen = 0;
				txseq.push_back(txseq.back() + 1);
				warnx << "sleeping (xgossip)...\n";
				gossipsleep = 0;
				delaycb(gintval, 0, wrap(gossipsleepnow));
				while (gossipsleep == 0) acheck();
d2158 8
d2209 1
a2209 1
		warnx << "merging ";
d2218 1
d2230 4
d2257 1
d2259 1
a2259 1
			printdouble("merge lists time: ", endTime - beginTime);
a2260 1
			*/
a2269 2
			warnx << "results files...\n";
			warnx << "loading files...\n";
d2298 3
d2310 4
d2321 1
a2321 1
				warnx << "xpath query results...\n";
d4282 43
d4403 22
d4807 1
d4812 1
a4812 1
	double sumf, sumw;
d4864 3
a4866 1
				sumw += teamvecomap[i][dummysig][1];
d4870 3
a4872 1
			teamvecomap[0][dummysig][1] = sumw/2;
d4908 6
a4913 2
				sumf += citr[i]->second[0];
				sumw += citr[i]->second[1];
d4924 6
a4929 2
				sumf += teamvecomap[i][dummysig][0];
				sumw += teamvecomap[i][dummysig][1];
d4944 6
a4949 2
			teamvecomap[0][minsig][0] = sumf/2;
			teamvecomap[0][minsig][1] = sumw/2;
d4962 6
a4967 2
			teamvecomap[0][minsig].push_back(sumf/2);
			teamvecomap[0][minsig].push_back(sumw/2);
d5358 1
a5358 1
	double freq, weight;
d5371 3
a5373 1
		itr->second[0] = freq * fby;
d5375 3
a5377 1
		itr->second[1] = weight * wby;
d5385 1
a5385 1
	double freq, weight;
d5390 4
a5393 1
		itr->second[0] = freq / fby;
d5395 3
a5397 1
		itr->second[1] = weight / wby;
d5433 10
d5455 12
d5541 25
d5646 80
@


1.117
log
@don't log so much data after done gossiping
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.116 2012/04/20 16:49:58 vsfgd Exp vsfgd $	*/
d32 1
a32 1
static char rcsid[] = "$Id: gpsi.C,v 1.116 2012/04/20 16:49:58 vsfgd Exp vsfgd $";
d175 2
a176 1
void mergelists(vecomap&);
d1956 1
a1956 16
			beginTime = getgtod();    
			warnx << "totalT.size(): " << totalT.size() << "\n";
			for (int i = 0; i < (int)totalT.size(); i++) {
				warnx << "merging totalT[" << i << "]\n";
				mergelists(totalT[i]);
			}
			endTime = getgtod();    
			printdouble("merge lists time: ", endTime - beginTime);
			warnx << "\n";
			//delspecial(0);
			// don't print lists after gossip is done
			if (plist == 1 && gossipdone == false) {
				printlistall(txseq.back());
			}

			// by default, gossip indefinitely
d1977 21
d4739 1
a4739 1
			teamvecomap[0][dummysig][1] = sumw / 2;
d4838 170
d5058 1
a5058 1
			allT[0][dummysig][1] = sumw / 2;
@


1.116
log
@logic fix: keep merging lists after done gossiping
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.115 2012/04/02 05:39:11 vsfgd Exp vsfgd $	*/
d32 1
a32 1
static char rcsid[] = "$Id: gpsi.C,v 1.115 2012/04/02 05:39:11 vsfgd Exp vsfgd $";
d1965 2
a1966 1
			if (plist == 1) {
d1971 2
a1972 1
			if (txseq.back() == rounds) {
@


1.115
log
@fixed mergelists (distinguishes b/w vanilla and xgossip)
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.114 2012/03/29 23:16:11 vsfgd Exp vsfgd $	*/
d32 1
a32 1
static char rcsid[] = "$Id: gpsi.C,v 1.114 2012/03/29 23:16:11 vsfgd Exp vsfgd $";
d76 1
d1194 17
d1955 14
d1974 1
d1979 1
d1983 3
a1985 3
				// stop gossiping, only listen
				break;
				// don't exit since each peer will reach a particular round at a different time
a1988 14
			beginTime = getgtod();    
			warnx << "totalT.size(): " << totalT.size() << "\n";
			for (int i = 0; i < (int)totalT.size(); i++) {
				warnx << "merging totalT[" << i << "]\n";
				mergelists(totalT[i]);
			}
			endTime = getgtod();    
			printdouble("merge lists time: ", endTime - beginTime);
			warnx << "\n";
			//delspecial(0);
			if (plist == 1) {
				printlistall(txseq.back());
			}

d1993 49
a2041 15
				for (int i = 0; i < (int)totalT.size(); i++) {
					// TODO: needed?
					if (gflag == 1) {
						warnx << "inserting ";
						if (compress == 1) warnx << "XGOSSIPC:\n";
						else warnx << "XGOSSIP:\n";

						warnx << "txseq: " << txseq.back() << "\n";

						teamID = findteamid(i);
						if (teamID == NULL) {
							warnx << "xgossip: teamID is NULL\n";
							continue;
						}
						warnx << "teamID(" << i << "): " << teamID << "\n";
d2043 12
a2054 32
						// TODO: check return status
						make_team(NULL, teamID, team);
						int range = team.size();
						// randomness verified
						int randcol = randomNumGenZ(range);
						ID = team[randcol];
						// TODO: check if p is succ(ID)
						//ID = (matrix.back())[randcol];
						warnx << "ID in randcol " << randcol << ": " << ID << "\n";
						strbuf t;
						strbuf p;
						t << ID;
						p << team[0];
						str key(t);
						str teamID(p);
						warnx << "txID: " << ID << "\n";

						if (compress == 1) {
							compressedList.clear();
							outBitmap.clear();
							sigList.clear();
							freqList.clear();
							weightList.clear();
							vecomap2vec(totalT[i], 0, sigList, freqList, weightList);

							int sigbytesize = 0;
							warnx << "sigs before compression:\n";
							for (int i = 0; i < (int)sigList.size(); i++) {
								sigbytesize += (sigList[i].size() * sizeof(POLY));
								//sig2str(sigList[i], sigbuf);
								//warnx << "sig[" << i << "]: " << sigbuf << "\n";
							}
d2056 2
a2057 12
							warnx << "sigList size (bytes): " << sigbytesize << "\n";
							warnx << "sigList.size() (unique): " << sigList.size() << "\n";
							compressSignatures(sigList, compressedList, outBitmap);

							int compressedsize = compressedList.size() * sizeof(POLY);
							warnx << "compressedList size (bytes): " << compressedsize << "\n";
							warnx << "compressedList.size(): " << compressedList.size() << "\n";

							int bitmapsize = 0;
							for (int i = 0; i < (int)outBitmap.size(); i++) {
								bitmapsize += (outBitmap[i].size() * sizeof(unsigned char));
							}
d2059 1
a2059 2
							warnx << "outBitmap size (bytes): " << bitmapsize << "\n";
							warnx << "outBitmap.size(): " << outBitmap.size() << "\n";
d2061 4
a2064 1
							warnx << "total compressed size (list+bitmap): " << compressedsize + bitmapsize << "\n";
d2066 2
a2067 4
							makeKeyValue(&value, valLen, key, teamID, compressedList, outBitmap, freqList, weightList, txseq.back(), XGOSSIPC);
						} else {
							makeKeyValue(&value, valLen, key, teamID, totalT[i][0], txseq.back(), XGOSSIP);
						}
d2069 15
a2083 2
						totaltxmsglen += valLen;
						roundtxmsglen += valLen;
d2085 5
a2089 12
						status = insertDHT(ID, value, valLen, instime, MAXRETRIES);
						cleanup(value);
						// don't forget to clear team list!
						team.clear();

						// do not exit if insert FAILs!
						if (status != SUCC) {
							warnx << "error: insert FAILed\n";
							// to preserve mass conservation:
							// "send" msg to yourself
							// (double freq)
							multiplyfreq(totalT[i], 0, 2, 2);
d2091 1
a2091 1
							warnx << "insert SUCCeeded\n";
a2092 8

						warnx << "sleeping (groups)...\n";
						//sleep(initintval);
						groupsleep = 0;
						delaycb(initintval, 0, wrap(groupsleepnow));
						while (groupsleep == 0) acheck();
					} else {
						return 0;
d2157 1
a2157 1
				warnx << "file: " << initfiles[i].c_str() << "\n";
d2234 1
a2234 1
				warnx << "file: " << initfiles[i].c_str() << "\n";
d3351 1
a3351 1
					warnx << "loadresults: qid already exists\n";
d3394 1
a3394 1
						warnx << "loadresults: sig already present\n";
@


1.114
log
@implemented compression for VanillaXGossip
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.113 2012/03/29 16:26:16 vsfgd Exp vsfgd $	*/
d32 1
a32 1
static char rcsid[] = "$Id: gpsi.C,v 1.113 2012/03/29 16:26:16 vsfgd Exp vsfgd $";
a1436 1
		/*
a1541 1
		*/
d1911 1
d4648 1
a4648 1
// TODO: verify
d4659 3
a4678 1
		// skip dummy
d4682 1
a4683 2
		// skip 2nd dummy only for xgossip(+)
		// TODO: distinguisth b/w xgossip and vanilla gossip
d4687 2
a4688 1
		++citr[i];
@


1.113
log
@fixed VanillaXGossip to work with the new data structures
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.112 2012/03/27 15:54:10 vsfgd Exp vsfgd $	*/
d32 1
a32 1
static char rcsid[] = "$Id: gpsi.C,v 1.112 2012/03/27 15:54:10 vsfgd Exp vsfgd $";
d963 1
a963 1
	double endTime, endreadTime, instime;
d1004 1
a1004 1
	// init txseq: txseq.back() segfaults!
d1437 2
d1471 7
a1477 9
			/*
			for (int i = 0; i < (int) compressedList.size(); i++) {
				printf("%u\n", compressedList[i]);
				for (int j = 0; j < ceil(sigList.size() / 8.0); j++) {
					//warnx << "--> " << outBitmap[i][j] << "\n";
					printf("--> %x\n", outBitmap[i][j]);
				}
			}
			*/
d1492 4
d1543 1
d1798 1
a1798 1
		double begingossipTime = getgtod();    
d1812 1
a1812 1
				double endgossipTime = getgtod();    
d1832 1
a1832 3
			warnx << "inserting VXGOSSIP:\n"
			      << "txseq: " << txseq.back()
			      << " txID: " << ID << "\n";
d1836 48
a1883 2
			// after merging, everything is stored in totalT[0][0]
			makeKeyValue(&value, valLen, key, key, totalT[0][0], txseq.back(), VXGOSSIP);
d1902 1
a1902 1
			warnx << "sleeping (gossip)...\n";
d1932 1
a1932 1
		double begingossipTime = getgtod();    
d1946 1
a1946 1
				double endgossipTime = getgtod();    
a2015 1
							/*
d2019 2
a2020 2
								sig2str(sigList[i], sigbuf);
								warnx << "sig[" << i << "]: " << sigbuf << "\n";
a2021 1
							*/
d2836 1
a2836 1
	if (msgtype == VXGOSSIP || msgtype == XGOSSIP || msgtype == XGOSSIPC) {
d2845 4
d2918 1
a2918 1
		if (msgtype == VXGOSSIP) {
@


1.112
log
@calculate minsim when merging results
reduced useless logging
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.111 2012/03/15 16:51:23 vsfgd Exp vsfgd $	*/
d32 1
a32 1
static char rcsid[] = "$Id: gpsi.C,v 1.111 2012/03/15 16:51:23 vsfgd Exp vsfgd $";
d75 1
d172 1
d595 1
a595 1
				str teamID(p);
d598 1
a598 1
				makeKeyValue(&value, valLen, key, teamID, dtdstr, querysig, qid, msgtype);
d616 1
a616 1
			printdouble("lshquerysig: insert time (only): ", totalinstime);
d619 1
a619 1
			printdouble("lshquerysig: insert time (+others): ", endTime - beginTime);
d632 2
d635 64
d1012 1
a1012 1
	while ((ch = getopt(argc, argv, "B:CcD:d:EF:G:gHhIj:L:lMmN:n:O:o:P:pQq:R:rS:s:T:t:uvW:w:X:x:y:Z:z")) != -1)
d1141 3
d1225 1
a1225 1
	if ((Hflag == 1 || Qflag == 1) && (dflag == 0 || jflag == 0 || Fflag == 0)) usage();
d1713 9
d1788 1
d1793 1
a1793 2
		// from now on, work only with totalT
		totalT.push_back(allT);
d1795 1
d1804 7
d2042 13
a2054 9
		// xpath: LSH(proxysig)
		if (xflag == 1 && Oflag == 1) {
			warnx << "using xpath, LSH(proxysig)...\n";
			lshquery(queryMap, initintval, QUERYXP);
		// xpath: LSH(querysig)
		} else if (xflag == 1 && Oflag == 0) {
			warnx << "using xpath, LSH(querysig)...\n";
			lshquery(queryMap, initintval, QUERYX);
		// sig: LSH(regularsig)
d2056 13
a2068 2
			warnx << "using sig, LSH(sig)...\n";
			lshsig(allT, initintval, QUERYS);
d2931 2
a2932 5
		// find if list for team exists
		str2chordID(keyteamid, teamID);
		teamid2totalT::iterator teamitr = teamindex.find(teamID);
		if (teamitr != teamindex.end()) {
			tind = teamitr->second[0];
d2934 1
a2934 2
			warnx << " teamID-found"; 
			//warnx << "teamID found at teamindex[" << tind << "]";
d2940 2
d2949 1
d2951 41
a2991 7
 			// don't run query if this peer is not a part of the team
			/*
			warnx << "queryresult:";
			warnx << " teamID NOT found";
			warnx << " qid: " << qid << " querysig: " << sigbuf;
			warnx << " teamID: " << teamID << "\n";
			*/
d2993 6
a2998 11
			// run query even if this peer is not a part of the team
			warnx << "queryresult: ";
			warnx << "teamID-NOT-found";
			warnx << " qid: " << qid << " querysig: " << sigbuf;
			warnx << " DTD: " << dtdstr;
			warnx << " teamID: " << teamID << "\n";
			sigmatches = 0;
			totalavg = 0;
			for (int i = 0; i < (int)totalT.size(); i++) {
				teamID = findteamid(i);
				run_query(i, querysig, sigmatches, totalavg, minsim, avgsim, msgtype, teamID);
d3001 15
a3015 21
			warnx << "queryresultend:";
			warnx << " rxqseq: " << rxqseq.back();
			warnx << " sigmatches: " << sigmatches;
			printdouble(" totalavg: ", totalavg);
			warnx << "\n";
			rxqseq.push_back(rxqseq.back() + 1);
		}

		// TODO: search other lists (not yet merged) for other sigs?
		/*
		mapType::iterator itr = allT[0].find(sig);
		if (itr != allT[0].end()) {
			freq = itr->second[0];
			weight = itr->second[1];
			warnx << " found\n";
			printdouble("f: ", freq);
			printdouble(", w: ", weight);
			printdouble(", avg: ", freq/weight);
			warnx << "\n";
		} else {
			warnx << " NOT found\n";
a3016 1
		*/
d5273 1
@


1.111
log
@many changes:
- separate xpath querying w/ and w/o proxy sigs (QUERYX v. QUERYXP)
- load both proxy and regular sigs in diff data structs
- when merging results, run lsh on results and query/proxy sigs to find
  misses
- ?
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.110 2012/03/08 17:19:46 vsfgd Exp vsfgd $	*/
d32 1
a32 1
static char rcsid[] = "$Id: gpsi.C,v 1.110 2012/03/08 17:19:46 vsfgd Exp vsfgd $";
d54 3
a56 1
std::vector<chordID> lshIDs;
d68 1
d188 1
a188 1
int run_query(int, std::vector<POLY>, int &, double &, InsertType, chordID = 0);
d887 2
d892 1
d906 1
d923 2
d944 1
a944 1
	while ((ch = getopt(argc, argv, "B:CcD:d:EF:G:gHhIj:L:lMmn:O:o:P:pQq:R:rS:s:T:t:uvW:w:X:x:y:Z:z")) != -1)
d1009 3
d1291 2
a1292 2
		bool usedummy = false;
		bool useproxy = false;
d1505 5
a1509 4
			int qid;
			std::string dtd;
			for (sig2idmulti::iterator itr = queryMap.begin(); itr != queryMap.end(); itr++) {
				qid = itr->second;
d1519 1
a1519 1
				sig2str(itr->first, sigbuf);
d1537 2
d1552 1
d1554 3
d1558 1
a1558 1
			run_query(tind, qitr->first, sigmatches, totalfreq, QUERYX);
d1588 24
a1611 1
			sig2str(qitr->first, sigbuf);
d1616 2
d1619 1
d1629 3
d1879 1
d1886 1
d2041 1
d2044 5
a2048 1
			double relerror;
a2052 2
			std::vector<POLY> proxysig;
			std::vector<POLY> querysig;
d2079 1
a2079 1
				warnx << "qid,querysig,sigmatches (*teamsize): est,sigmatches (*instances): true,sigmatches: rel error (%),freq (*teamsize): est,freq (*instances): true,freq: rel error (%),proxy lsh misses,query lsh misses,teamIDs\n";
d2092 1
d2105 1
d2113 1
d2122 1
d2129 1
d2138 1
d2151 7
d2166 2
d2169 1
a2169 1
										warnx << "lsh proxy sig miss\n";
d2174 1
d2176 1
a2176 1
										warnx << "lsh query sig miss\n";
d2196 10
a2205 2
					// don't run lsh on input data sigs
					run_query(tind, querysig, truesigmatches, truefreq, QUERYX);
d2249 30
d2291 24
d2319 5
d2618 1
a2618 1
	double freq, weight, totalavg;
d2625 1
d2841 1
a2841 1
			run_query(tind, querysig, sigmatches, totalavg, msgtype);
d2867 1
a2867 1
				run_query(i, querysig, sigmatches, totalavg, msgtype, teamID);
d2904 1
d2906 1
a2906 1
run_query(int tind, std::vector<POLY> querysig, int &sigmatches, double &totalavg, InsertType msgtype, chordID teamID)
d2908 1
d2910 1
a2910 1
	bool multi;
d2913 7
d2948 14
d2980 4
d3147 1
a3147 1
			warnx << "qid: " << qid << " querysig: " << sigbuf << " DTD: " << dtd.c_str() << " teamID: " << teamID << "\n";
d3591 1
a3591 1
	warnx << "sigfile: " << sigfile.c_str() << "\n";
d3614 1
a3614 1
		warnx << "numSigs: " << numSigs << "\n";
d3616 1
a3616 1
	warnx << "NUM sigs: " << numSigs;
d3625 1
a3625 1
	warnx << ", Signature size: " << size * sizeof(POLY) << " bytes\n";
d3630 1
a3630 1
	warnx << "Document signature (sorted): ";
d3640 1
a3640 1
	warnx << buf << "\n";
d3659 1
a3659 1
	warnx << "readsig: Size of sig list: " << sigList.size() << "\n";
d3838 1
a3838 1
		warnx << "myID == teamID, index = 0\n";
d3845 1
a3845 1
	warnx << "arclen: " << arclen << "\n";
d3851 1
a3851 1
	warnx << "ID_0: " << teamID << "\n";
d3857 1
a3857 1
		warnx << "ID_" << j << ": " << curID << "\n";
d3859 1
a3859 1
			warnx << "myID == curID, index = " << j << "\n";
d5111 1
d5148 1
a5148 1
	     << "	-r		read signatures (requires -s or -x)\n"
@


1.110
log
@calculate query error when merging results
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.109 2012/02/17 20:01:18 vsfgd Exp vsfgd $	*/
d32 1
a32 1
static char rcsid[] = "$Id: gpsi.C,v 1.109 2012/02/17 20:01:18 vsfgd Exp vsfgd $";
d54 1
d71 1
a71 1
bool initphase = 0;
d103 1
d110 5
a114 1
// during init phases and when querying
d149 1
a149 1
void calcfreq(std::vector<std::vector <POLY> >, bool);
d167 1
a167 1
int lshquery(sig2idmulti, int, InsertType, int, bool);
d182 1
a182 1
void readsig(std::string, std::vector<std::vector <POLY> > &);
d184 1
d191 1
a445 1
// by default, run lsh on regular sig, not query sig
d447 1
a447 1
lshquery(sig2idmulti queryMap, int intval = -1, InsertType msgtype = INVALID, int col = 0, bool lshonqsig = 0)
d457 1
a457 1
	lsh *myLSH;
d486 2
a487 12
		// get regularsig to generate the right timeIDs using LSH
		string2sigs::iterator sitr = dtd2sigs.find(dtd);
		if (sitr != dtd2sigs.end()) {
			// TODO: assume 1 sig per DTD
			regularsig = sitr->second.back();
		} else {
			warnx << "lshquery: no sig found for DTD: " << dtd.c_str() << "\n";
		}


		// use query sig to generate teamIDs
		if (lshonqsig == 1) {
d525 10
a534 2
		// use regular sig to generate teamIDs
		} else {
d591 1
d593 1
a593 1
				makeKeyValue(&value, valLen, key, teamID, querysig, qid, msgtype);
d884 1
a884 1
	int Gflag, Lflag, lflag, rflag, Sflag, sflag, zflag, vflag, Hflag, dflag, jflag, mflag, Iflag, Eflag, Pflag, Dflag, Mflag, Fflag, xflag, yflag, Zflag;
d887 3
a889 1
	double beginTime, beginreadTime, endTime, endreadTime, instime;
d901 1
d906 1
d910 1
d920 1
a920 1
	Gflag = Lflag = lflag = rflag = Sflag = sflag = zflag = vflag = Hflag = dflag = jflag = mflag = Eflag = Iflag = Pflag = Dflag = Mflag = Fflag = xflag = yflag = Zflag = 0;
d935 1
a935 1
	while ((ch = getopt(argc, argv, "B:CcD:d:EF:G:gHhIj:L:lMmn:o:P:pQq:R:rS:s:T:t:uvW:w:X:x:y:Z:z")) != -1)
d1003 4
d1089 2
d1151 1
d1278 45
a1322 17
	if ((rflag == 1 || gflag == 1 || Hflag == 1 || lflag == 1 || Qflag == 1 || Mflag == 1) && sflag == 1) {
		beginreadTime = getgtod();    
		getdir(sigdir, sigfiles);
		sigList.clear();

		// insert dummy
		// the polynomial "1" has a degree 0
		// don't add dummy when querying, gossiping using LSH, or merging results?
		bool usedummy = 0;
		if (Hflag == 0 && Qflag == 0 && Mflag == 0) {
			usedummy = 1;
			sigList.push_back(dummysig);
		}

		warnx << "reading signatures from files...\n";
		for (unsigned int i = 0; i < sigfiles.size(); i++) {
			readsig(sigfiles[i], sigList);
d1324 26
a1349 20
		warnx << "calculating frequencies...\n";
		beginTime = getgtod();    
		warnx << "sigList.size() (all): " << sigList.size() << "\n";
		calcfreq(sigList, usedummy);
		endTime = getgtod();    
		printdouble("calcfreq time (+sorting): ", endTime - beginTime);
		warnx << "\n";
		if (freqbyx > 1) {
			// don't multiply weight
			multiplyfreq(allT, 0, freqbyx, 1);
		}
		if (plist == 1) {
			// both init phases use allT
			printlist(allT, 0, -1);
			// print DTD names and how many sigs/DTD
			for (string2sigs::iterator itr = dtd2sigs.begin(); itr != dtd2sigs.end(); itr++) {
				warnx << "DTD: " << itr->first.c_str();
				warnx << " sigs: " << itr->second.size() << "\n";
				//sig2str(itr->second.back(), sigbuf);
				//warnx << " sig: " << sigbuf << "\n";
d1351 1
d1538 1
a1538 1

d1600 1
a1600 1
		if (Iflag == 1) initphase = 1;
d1653 1
a1653 1
		initphase = 0;
d1904 7
a1910 2
		if (xflag == 1) {
			warnx << "using xpath...\n";
d1912 1
d1914 1
a1914 1
			warnx << "using sig...\n";
d1984 1
d1987 4
d1994 11
d2018 1
a2018 2
			if (msgtype == QUERYX) {

d2022 2
d2026 1
a2026 1
				warnx << "qid,querysig,sigmatches (*teamsize): est,sigmatches (*instances): true,sigmatches: rel error (%),freq (*teamsize): est,freq (*instances): true,freq: rel error (%),teamIDs\n";
d2031 32
d2064 1
a2064 1
					id2sigs::iterator sitr = qid2sigs.find(qitr->first);
d2069 1
a2069 1
							id2id::iterator iditr = qid2id.find(qitr->first);
d2073 1
a2073 1
								warnx << "qid2id: can't find qid: " << qitr->first << "\n";
d2091 21
d2114 1
a2114 1
						//warnx << "qid2sigs: can't find sigs for qid: " << qitr->first << "\n";
a2116 5
					// get true result
					truesigmatches = 0;
					truefreq = 0;
					run_query(tind, qitr->second[0], truesigmatches, truefreq, QUERYX);

d2118 1
a2118 1
					warnx << qitr->first << ",";
d2121 1
a2121 1
					sig2str(qitr->second[0], sigbuf);
d2124 6
d2138 1
a2138 1
					// rel error
d2157 1
a2157 1
					// rel error
d2166 6
d2173 1
a2173 1
					id2chordIDs::iterator titr = qid2teamIDs.find(qitr->first);
d2175 1
a2175 1
						//warnx << "qid2teamIDs: qid: " << qitr->first << " teamIDs: " << titr->second.size() << "\n";
d2180 1
a2180 1
						warnx << "qid2teamIDs: can't find teamIDs for qid: " << qitr->first << "\n";
d2186 2
d2470 1
d2551 1
a2551 1
		if (initphase == 1) {
d2559 1
a2559 1
		warnx << "XGOSSIP";
d2634 1
a2634 1
		if (initphase == 0) {
d2664 1
a2664 1
	} else if (msgtype == QUERYS || msgtype == QUERYX) {
d2669 1
d2671 3
d2675 2
a2676 2
			warnx << "QUERYX";
			ret = getKeyValue(gmsg.cstr(), key, keyteamid, querysig, qid, recvlen);
d2700 1
d2724 1
d2793 1
a2793 1
	} else if (msgtype == QUERYX) {
d2801 1
d2823 65
d2935 1
d2963 1
a2963 1
			if (strcmp(tokens[3].c_str(), "QUERYS") == 0)
d2965 1
a2965 1
			else if (strcmp(tokens[3].c_str(), "QUERYX") == 0)
d2967 3
a2969 1
			else {
d2977 1
d2983 2
a2984 2
			//warnx << "qid: " << qid << " querysig: " << sigbuf << " teamID: " << teamID << "\n";
			if (msgtype == QUERYX) {
d2988 7
d3417 1
a3417 1
// TODO: work w/ 0-sized sigs and path w/o trailing slash
d3419 1
a3419 1
readsig(std::string sigfile, std::vector<std::vector <POLY> > &sigList)
d3479 7
a3485 3
	string2sigs::iterator itr = dtd2sigs.find(dtd);
	if (itr != dtd2sigs.end()) {
		itr->second.push_back(sig);
d3487 6
a3492 1
		dtd2sigs[dtd].push_back(sig);
d3810 1
a3810 1
calcfreq(std::vector<std::vector<POLY> > sigList, bool usedummy)
d3836 12
a3847 2
	allT.push_back(uniqueSigList);
	warnx << "calcfreq: setsize: " << allT[0].size() << "\n";
d4075 57
d4931 2
a4932 1
	     << "	-D		<dir with init files>\n"
@


1.109
log
@choose if regular or query sig is used to generate teamIDS when running lshquery by setting lshonqsig
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.108 2012/02/06 19:43:20 vsfgd Exp vsfgd $	*/
d32 1
a32 1
static char rcsid[] = "$Id: gpsi.C,v 1.108 2012/02/06 19:43:20 vsfgd Exp vsfgd $";
d63 2
d1260 1
a1260 1
	if ((rflag == 1 || gflag == 1 || Hflag == 1 || lflag == 1 || Qflag == 1) && sflag == 1) {
d1267 1
a1267 1
		// don't add dummy when querying and when gossiping using LSH
d1269 1
a1269 1
		if (Hflag == 0 && Qflag == 0) {
d1316 1
d1333 10
d1383 17
a1399 20
				printdouble("sim: ", simi);
				warnx << " ";
				sig2str(newsigList[i], sigbuf);
				warnx << "sig[" << i << "]: " << sigbuf << "\n";
			}

			/*
			newsigList.clear();
			freqList.clear();
			weightList.clear();

			makeKeyValue(&value, valLen, key, teamID, allT[0], txseq.back(), XGOSSIP);
			ret = getKeyValue(value, newkey, newteamID, newsigList, freqList, weightList, seq, recvlen);
			*/

			/*
			for (int i = 0; i < (int)compressedList.size(); i++) {
				warnx << compressedList[i] << "\n";
				for (int j = 0; j < ceil(sigList.size() / 8.0); j++) {
					warnx << "--> " << outBitmap[i][j] << "\n";
a1401 1
			*/
a1467 1
		int ninter;
d1470 3
a1472 1
		bool multi;
d1474 1
a1474 1
		int allnum = 0;
d1479 4
d1485 4
d1494 4
a1497 6
					/*
					if (Qflag == 1) {
						allT[resultsnum][qitr->first][0] += sitr->second[0];
						allT[resultsnum][qitr->first][1] += sitr->second[1];
					}
					*/
d1514 2
a1865 1
		int totalmatches = 0;
a1866 1
		double totalavg = 0;
d1925 9
a1933 3
			mapType uniqueSigList;
			allT.clear();
			allT.push_back(uniqueSigList);
d1937 1
a1937 1
					warnx << "can't open init file" << initfiles[i].c_str() << "\n";
d1944 5
d1950 1
a1950 1
				warnx << "qid,querysig,sigmatches (*teamsize),totalavg (*teamsize),teamIDs\n";
d1977 2
a1978 2
								totalavg += saitr->second[randcol];
								++totalmatches;
d1988 5
d1995 1
d1999 35
a2033 2
					warnx << totalmatches * teamsize << ",";
					printdouble("", totalavg * teamsize);
d2048 2
a2049 2
					totalmatches = 0;
					totalavg = 0;
d2051 3
d2058 1
a2058 1
				warnx << "id,querysig,totalavg,totalavg (*teamsize)\n";
d2063 2
a2064 2
					totalavg = itr->second[0]/itr->second[1];
					printdouble("", totalavg);
d2066 1
a2066 1
					printdouble("", totalavg * teamsize);
d2636 10
a2645 8
			sig2str(sigitr->first, sigbuf);
			warnx << "exactsig: " << sigbuf;
			printdouble(" f: ", sigitr->second[0]);
			printdouble(" w: ", sigitr->second[1]);
			printdouble(" avg: ", sigitr->second[0]/sigitr->second[1]);
			// teamID is set only when running queries for "teamID-NOT-found"
			if (teamID != 0) warnx << " teamID: " << teamID;
			warnx << "\n";
d2656 11
a2666 9
				sig2str(itr->first, sigbuf);
				warnx << "supersetsig: " << sigbuf;
				printdouble(" f: ", itr->second[0]);
				printdouble(" w: ", itr->second[1]);
				printdouble(" avg: ", itr->second[0]/itr->second[1]);
				// teamID is set only when running queries for "teamID-NOT-found"
				if (teamID != 0) warnx << " teamID: " << teamID;
				warnx << "\n";
				//if (multi == 1) warnx << "superset sig is a multiset\n";
d3065 2
a3066 1
		files.push_back(dir + std::string(dirp->d_name));
@


1.108
log
@consistent start/stop time msgs
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.107 2012/02/03 18:39:13 vsfgd Exp vsfgd $	*/
d32 1
a32 1
static char rcsid[] = "$Id: gpsi.C,v 1.107 2012/02/03 18:39:13 vsfgd Exp vsfgd $";
d159 1
a159 1
int lshquery(sig2idmulti, int, InsertType, int);
d436 1
a436 1
// TODO: verify
d438 1
a438 1
lshquery(sig2idmulti queryMap, int intval = -1, InsertType msgtype = INVALID, int col = 0)
d446 1
d448 1
d463 1
d477 1
d486 41
a526 15
		sig2str(querysig, sigbuf);
		warnx << "running LSH on querysig: " << sigbuf << "\n";
		beginTime = getgtod();    
		lsh *queryLSH = new lsh(querysig.size(), lfuncs, mgroups, lshseed, col, irrnums, hasha, hashb);
		endTime = getgtod();    
		printdouble("lshquery: lsh time: ", endTime - beginTime);
		warnx << "\n";
		// convert multiset to set
		if (uflag == 1) {
			//sig2str(querysig, sigbuf);
			//warnx << "multiset: " << sigbuf << "\n";
			lshquerysig = queryLSH->getUniqueSet(querysig);
			//sig2str(lshsig, sigbuf);
			//warnx << "set: " << sigbuf << "\n";
			minhash = queryLSH->getHashCode(lshquerysig);
d528 7
a534 2
			minhash = queryLSH->getHashCode(querysig);
		}
d536 11
a546 1
		sort(minhash.begin(), minhash.end());
d548 1
a548 12
		team.clear();
		for (int i = 0; i < (int)minhash.size(); i++) {
			teamID = minhash[i];
			warnx << "teamID: " << teamID << "\n";
			// TODO: check return status
			make_team(NULL, teamID, team);
			range = team.size();
			// randomness verified
			//randcol = randomNumGenZ(range-1);
			randcol = randomNumGenZ(range);
			ID = team[randcol];
			warnx << "ID in randcol " << randcol << ": " << ID << "\n";
a550 12
		sig2str(regularsig, sigbuf);
		warnx << "running LSH on regularsig: " << sigbuf << "\n";
		beginTime = getgtod();    
		lsh *sigLSH = new lsh(regularsig.size(), lfuncs, mgroups, lshseed, col, irrnums, hasha, hashb);
		endTime = getgtod();    
		printdouble("lshquery: lsh time: ", endTime - beginTime);
		warnx << "\n";
		minhash.clear();
		minhash = sigLSH->getHashCode(regularsig);

		sort(minhash.begin(), minhash.end());

d616 1
a616 2
		delete sigLSH;
		delete queryLSH;
d1829 1
a1829 1
		initintval = 1;
@


1.107
log
@test make/getKeyValue when doing local compression (just reading sigs)
measure exact exec time
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.106 2012/02/02 16:15:34 vsfgd Exp vsfgd $	*/
d32 1
a32 1
static char rcsid[] = "$Id: gpsi.C,v 1.106 2012/02/02 16:15:34 vsfgd Exp vsfgd $";
d1569 2
a1570 2
		warnx << "exec ctime: " << ctime(&rawtime);
		warnx << "exec sincepoch: " << time(&rawtime) << "\n";
d1652 2
a1653 2
		warnx << "start gossip ctime: " << ctime(&rawtime);
		warnx << "start gossip sincepoch: " << time(&rawtime) << "\n";
d1667 2
a1668 2
				warnx << "stop gossip ctime: " << ctime(&rawtime);
				warnx << "stop gossip sincepoch: " << time(&rawtime) << "\n";
d2378 1
a2378 1
//#ifdef _DEBUG_
d2394 1
a2394 1
//#endif
@


1.106
log
@interval b/w inserts in exec phase
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.105 2012/01/24 18:41:09 vsfgd Exp vsfgd $	*/
d32 1
a32 1
static char rcsid[] = "$Id: gpsi.C,v 1.105 2012/01/24 18:41:09 vsfgd Exp vsfgd $";
d187 1
d1309 30
a1340 2

			int numSigs = sigList.size();
d1343 4
a1346 1
			warnx << "after uncompress:";
d1348 3
d1356 9
d1652 4
a1655 2
		warnx << "exec ctime: " << ctime(&rawtime);
		warnx << "exec sincepoch: " << time(&rawtime) << "\n";
d1666 7
d2330 1
a2330 1
			warnx << "XGOSSIP";
d2381 1
d3450 12
@


1.105
log
@measure time to read sigs in memory
added start and listen ctime
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.104 2012/01/23 16:43:05 vsfgd Exp vsfgd $	*/
d32 1
a32 1
static char rcsid[] = "$Id: gpsi.C,v 1.104 2012/01/23 16:43:05 vsfgd Exp vsfgd $";
d1606 1
d1756 1
@


1.104
log
@added a listen interval
grouped command line arguments by type
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.103 2012/01/17 21:12:07 vsfgd Exp vsfgd $	*/
d32 1
a32 1
static char rcsid[] = "$Id: gpsi.C,v 1.103 2012/01/17 21:12:07 vsfgd Exp vsfgd $";
d857 1
a857 1
	double beginTime, endTime, instime;
d1121 4
d1237 1
d1338 3
a1443 3
	time(&rawtime);
	warnx << "init ctime: " << ctime(&rawtime);
	warnx << "init sincepoch: " << time(&rawtime) << "\n";
d1460 3
d1524 3
d1606 1
a1609 1

@


1.103
log
@print # of sigs/DTD instead of sig
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.102 2012/01/17 18:58:45 vsfgd Exp vsfgd $	*/
d32 1
a32 1
static char rcsid[] = "$Id: gpsi.C,v 1.102 2012/01/17 18:58:45 vsfgd Exp vsfgd $";
d855 1
a855 1
	int ch, gintval, initintval, waitintval, nids, rounds, valLen, logfd;
d886 1
a886 1
	gintval = waitintval = nids = 0;
d900 1
a900 1
	while ((ch = getopt(argc, argv, "B:CcD:d:EF:G:gHhIj:L:lMmn:o:P:pQq:R:rS:s:T:t:uvw:X:x:y:Z:z")) != -1)
d998 3
d1460 1
a1460 2
		int listensleep = 30;
		warnx << "waiting " << listensleep << " sec for others to start listening\n";
d1462 1
a1462 1
		delaycb(listensleep, 0, wrap(initsleepnow));
d1469 1
a1469 1
		warnx << "init interval: " << initintval << "\n";
d4432 1
a4432 1
	warn << "Examples:\n\n";
d4446 2
a4447 2
	warn << "Options:\n"
	     << "	-B		bands for LSH (a.k.a. m groups)\n"
d4450 9
d4460 4
a4463 2
	     << "	-d		<random prime number for LSH seed>\n"
	     << "	-E		exec phase of XGossip (requires -H)\n"
a4464 4
	     << "	-G		<gossip socket>\n"
	     << "	-H		generate chordIDs/POLYs using LSH when gossiping\n"
					"\t\t\t(requires -g, -s, -d, -j, -I, -w, -F)\n"
	     << "	-I		init phase of XGossip (requires -H)\n"
d4467 7
a4473 2
	     << "      	-m		use findMod instead of compute_hash\n"
					"\t\t\t(vector of POLYs instead of chordIDs)\n"
d4476 18
a4493 7
	     << "      	-P		<init phase file>\n"
					"\t\t\t(after XGossip init state is complete)\n"
	     << "      	-p		verbose (print list of signatures)\n"
	     << "      	-q		<initial estimate of # of peers in DHT>\n"
	     << "	-R		rows for LSH (a.k.a. l hash functions)\n"
	     << "	-S		<dhash socket>\n"
	     << "	-s		<dir with sigs>\n"
d4498 2
a4499 2
	     << "(	-u		make POLYs unique (convert multiset to set))\n"
					"\t\t\t(don't use)\n"
d4501 3
a4503 8
					"\t\t\t(wait interval after XGossip init phase is done)\n"
	     << "	-X		<how many times>\n"
					"\t\t\t(multiply freq of sigs by)\n"
	     << "	-x		<dir with xpath files>\n"
	     << "	-y		<init | results>\n"
					"\t\t\t(type for merging)\n"
	     << "	-Z		<team size>\n\n"
	     << "Actions:\n"
@


1.102
log
@compression debugging
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.101 2011/11/25 21:23:35 vsfgd Exp vsfgd $	*/
d32 1
a32 1
static char rcsid[] = "$Id: gpsi.C,v 1.101 2011/11/25 21:23:35 vsfgd Exp vsfgd $";
d1260 1
d1263 3
a1265 2
				sig2str(itr->second.back(), sigbuf);
				warnx << " sig: " << sigbuf << "\n";
@


1.101
log
@calculate round/total msglen when compressing
fixed vecomap2vec to use totalT instead of allT
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.100 2011/11/23 20:37:16 vsfgd Exp vsfgd $	*/
d32 1
a32 1
static char rcsid[] = "$Id: gpsi.C,v 1.100 2011/11/23 20:37:16 vsfgd Exp vsfgd $";
d1297 13
d1442 4
d1450 3
d1456 1
a1456 1
		warnx << "waiting " << listensleep << "s for others to start listening\n";
a1466 2
		// enter init phase
		initphase = 1;
d1670 1
d1673 2
d2285 3
d2308 1
a2308 1
#ifdef _DEBUG_
d2314 2
a2315 1
			printdouble("freq[i]: ", freqList[i]);
d2319 2
a2320 1
			printdouble("weight[i]: ", weightList[i]);
d2323 1
a2323 1
#endif
d4224 1
a4224 1
	warnx << "divideferq(" << fby << ", " << wby << "): setsize: " << teamvecomap[listnum].size() << "\n";
@


1.100
log
@integrated compression
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.99 2011/10/02 15:33:41 vsfgd Exp vsfgd $	*/
d32 1
a32 1
static char rcsid[] = "$Id: gpsi.C,v 1.99 2011/10/02 15:33:41 vsfgd Exp vsfgd $";
d1613 5
a1617 2
						warnx << "inserting XGOSSIP:\n"
						      << "txseq: " << txseq.back() << "\n";
d1649 1
a1649 1
							vecomap2vec(allT, 0, sigList, freqList, weightList);
a1676 2
							totaltxmsglen += valLen;
							roundtxmsglen += valLen;
d1679 3
@


1.99
log
@lsh on sig even when xpath
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.98 2011/09/23 17:05:24 vsfgd Exp vsfgd $	*/
d32 1
a32 1
static char rcsid[] = "$Id: gpsi.C,v 1.98 2011/09/23 17:05:24 vsfgd Exp vsfgd $";
d60 1
a60 1
int compact = 0;
d187 1
a187 1
void vecomap2vec(vecomap teamvecomap, int listnum, std::vector<std::vector <POLY> > &);
d877 2
d909 1
a909 1
			compact = 1;
d1267 1
a1267 1
		if (compact == 1) {
d1271 3
a1273 1
			vecomap2vec(allT, 0, sigList);
d1640 1
a1640 1
						if (compact == 1) {
d1643 29
a1671 2
							//compressSignatures(totalT[i][0], compressedList, outBitmap);
							//makeKeyValue(&value, valLen, key, teamID, compressedList, outputBitmap, txseq.back(), XGOSSIP);
d2156 2
d2161 1
d2225 1
a2225 1
	if (msgtype == VXGOSSIP || msgtype == XGOSSIP) {
d2233 4
d2238 3
a2240 1
			warnx << "XGOSSIP";
a2242 1
		ret = getKeyValue(gmsg.cstr(), key, keyteamid, sigList, freqList, weightList, seq, recvlen);
d2256 1
a2256 1
		if (msgtype == XGOSSIP) warnx << " teamID: " << keyteamid;
d4219 1
a4219 1
vecomap2vec(vecomap teamvecomap, int listnum, std::vector<std::vector <POLY> >&sigList)
d4223 2
d4414 1
a4414 1
	     << "	-C		compact signatures\n"
@


1.98
log
@merge init files in allT[0]
sleep after all k inserts (not every k insert) for both lshquery and lshsig
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.97 2011/09/22 14:08:20 vsfgd Exp vsfgd $	*/
d32 1
a32 1
static char rcsid[] = "$Id: gpsi.C,v 1.97 2011/09/22 14:08:20 vsfgd Exp vsfgd $";
d93 8
d133 3
a135 1
void add2querymap(std::vector<std::vector<POLY> > queryList);
d157 1
a157 1
int loadresults(FILE *);
d160 1
a160 1
int make_team(chordID, chordID, std::vector<chordID>&);
d173 3
a175 3
void readquery(std::string, std::vector<std::vector <POLY> >&);
void readsig(std::string, std::vector<std::vector <POLY> >&);
void readValues(FILE *, std::multimap<POLY, std::pair<std::string, enum OPTYPE> >&);
d177 2
a178 2
bool sig2str(std::vector<POLY>, str&);
bool string2sig(std::string, std::vector<POLY>&);
d181 5
a185 5
int set_inter(std::vector<POLY> s1, std::vector<POLY> s2, bool &multi);
int set_inter_noskip(std::vector<POLY> s1, std::vector<POLY> s2, bool &multi);
int set_uni(std::vector<POLY> s1, std::vector<POLY> s2, bool &multi);
double signcmp(std::vector<POLY>, std::vector<POLY>, bool&);
void tokenize(const std::string&, std::vector<std::string>&, const std::string&);
d187 1
a187 1
void vecomap2vec(vecomap teamvecomap, int listnum, std::vector<std::vector <POLY> >&sigList);
d444 2
d448 2
d459 1
d465 7
d473 10
d484 1
a484 1
		lsh *myLSH = new lsh(querysig.size(), lfuncs, mgroups, lshseed, col, irrnums, hasha, hashb);
d492 1
a492 1
			lshquerysig = myLSH->getUniqueSet(querysig);
d495 1
a495 1
			minhash = myLSH->getHashCode(lshquerysig);
d497 1
a497 1
			minhash = myLSH->getHashCode(querysig);
d502 26
a541 2
			std::vector<chordID> team;
			chordID teamID;
d593 2
a594 1
		delete myLSH;
d856 1
d865 1
d875 1
d1258 5
d1317 1
d1321 1
a1321 1
			readquery(xpathfiles[i], queryList);
d1323 1
a1323 1
		add2querymap(queryList);
d1336 2
d1339 10
d1350 1
a1350 1
				warnx << "QID: " << itr->second << " QUERYSIG: " << sigbuf << "\n";
d1362 1
d1368 6
d1377 1
a1377 1
			for (mapType::iterator sitr = allT[0].begin(); sitr != allT[0].end(); sitr++) {
d1381 6
d1762 3
d1771 1
a1771 1
				if (loadresults(initfp) == -1) warnx << "loadresults failed\n";
d1774 35
a1808 17
			warnx << "qid,querysig,sigmatches (*teamsize),totalavg (*teamsize),teamIDs\n";
			for (id2sigs::iterator qitr = qid2querysig.begin(); qitr != qid2querysig.end(); qitr++) {
				if (qitr->second.size() > 1)
					warnx << "multiple queries for the same qid\n";

				// find sigs which match this qid
				id2sigs::iterator sitr = qid2sigs.find(qitr->first);
				if (sitr != qid2sigs.end()) {
					// add up avg of different sigs and pick a random avg for same one
					for (int i = 0; i < (int)sitr->second.size(); i++ ) {
						// find id corresponding to this qid in allsig2avg
						id2id::iterator iditr = qid2id.find(qitr->first);
						if (iditr != qid2id.end()) {
							avgid = iditr->second;
						} else {
							warnx << "qid2id: can't find qid: " << qitr->first << "\n";
							continue;
d1810 3
d1814 15
a1828 12
						// find vector<avg> of the sig in the sig2avg map for this qid
						mapType::iterator saitr = allsig2avg[avgid].find(sitr->second[i]);
						if (saitr != allsig2avg[avgid].end()) {
							range = saitr->second.size();
							// TODO: verify range
							randcol = randomNumGenZ(range);
							//warnx << "sig2avg: range: " << range << " randcol: " << randcol << "\n";
							totalavg += saitr->second[randcol];
							++totalmatches;
						} else {
							warnx << "allsig2avg: where is the sig\n";
							continue;
d1830 2
d1833 4
a1836 2
				} else {
					//warnx << "qid2sigs: can't find sigs for qid: " << qitr->first << "\n";
d1838 15
a1852 19

				sig2str(qitr->second[0], sigbuf);
				// qid
				warnx << qitr->first << ",";
				// querysig
				warnx << sigbuf << ",";
				warnx << totalmatches * teamsize << ",";
				printdouble("", totalavg * teamsize);
				warnx << ",";

				// print teamIDs
				id2chordIDs::iterator titr = qid2teamIDs.find(qitr->first);
				if (titr != qid2teamIDs.end()) {
					//warnx << "qid2teamIDs: qid: " << qitr->first << " teamIDs: " << titr->second.size() << "\n";
					for (int i = 0; i < (int)titr->second.size(); i++ ) {
						warnx << titr->second[i] << ",";
					}
				} else {
					warnx << "qid2teamIDs: can't find teamIDs for qid: " << qitr->first << "\n";
d1854 2
a1855 4

				warnx << "\n";
				totalmatches = 0;
				totalavg = 0;
d2408 3
a2410 3
			printdouble(", f: ", sigitr->second[0]);
			printdouble(", w: ", sigitr->second[1]);
			printdouble(", avg: ", sigitr->second[0]/sigitr->second[1]);
d2443 38
d2482 1
a2482 1
loadresults(FILE *initfp)
d2492 1
a2492 1
	bool teamIDfound = 0;
d2503 1
d2508 1
d2515 11
a2525 1
		if (strcmp(tokens[0].c_str(), "queryresult") == 0) {
d2535 6
a2540 8
			// map querysig to qid:
			// store querysig in 1st position
			id2sigs::iterator qitr = qid2querysig.find(qid);
			if (qitr != qid2querysig.end()) {
				if (samesig(querysig, qitr->second[0]) != 1)
					warnx << "loadresults: different querysigs for the same qid\n";
			} else {
				qid2querysig[qid].push_back(querysig);
d2542 1
a2542 28

			// map teamID to qid
			id2chordIDs::iterator titr = qid2teamIDs.find(qid);
			if (titr != qid2teamIDs.end()) {
				for (int i = 0; i < (int)titr->second.size(); i++) {
					if (teamID == titr->second[i]) {
						warnx << "loadresults: teamID already present\n";
						teamIDfound = 1;
						break;
					}
				}
				if (teamIDfound != 1) titr->second.push_back(teamID);
				teamIDfound = 0;
			} else {
				qid2teamIDs[qid].push_back(teamID);
			}

			/*
			// map qid to querysig
			sig2ids::iterator qitr = querysig2qids.find(querysig);
			if (qitr != querysig2qids.end()) {
				// store qid in 0 only
				if (qitr->second[0] != qid)
					warnx << "loadresults: multiple qids for the same query\n";
			} else {
				querysig2qids[querysig].push_back(qid);
			}
			*/
d2551 2
d2589 14
d2604 4
a2607 5
			/*
			// add sig and qid OR add qid to existing sig
			sig2ids::iterator siitr = sig2qids.find(sig);
			if (siitr != sig2qids.end()) {
				siitr->second.push_back(qid);
d2609 2
a2610 1
				sig2qids[sig].push_back(qid);
d2612 1
a2612 6
			warnx << "supersetsig: " << sigbuf;
			printdouble(" f: ", freq);
			printdouble(" w: ", weight);
			printdouble(" avg: ", avg);
			warnx << "\n";
			*/
d2621 1
d2839 1
a2839 1
readquery(std::string queryfile, std::vector<std::vector <POLY> > &queryList)
d2841 1
d2850 13
d2865 39
d2905 2
a2906 16
	// DON'T use readData to retrieve signatures from input files...
	// since the size filed uses POLY as a basic unit and not byte...
	// Format is <n = # of sigs><sig size><sig>... n times...
	int numSigs;
	if (fread(&numSigs, sizeof(numSigs), 1, qfp) != 1) {
		warnx << "numSigs: " << numSigs << "\n";
		break;
	}
	warnx << "NUM sigs: " << numSigs << "\n";
	assert(numSigs > 0);

	for (int t = 0; t < numSigs; t++) {
		POLY *buf;
		int size;
		if (fread(&size, sizeof(int), 1, qfp) != 1) {
			assert(0);
a2907 1
		warnx << "Signature size: " << size * sizeof(POLY) << " bytes\n";
d2909 17
a2925 19
		buf = new POLY[size];
		assert(buf);
		if (fread(buf, sizeof(POLY), size, qfp) != (size_t) size) {
			assert(0);
		}
				
		std::vector<POLY> sig;
		sig.clear();
		warnx << "Query signature (sorted): ";
		for (int i = 0; i < size; i++) {
			// XXX: discard "1"s
			if (buf[i] == 1) continue;
			sig.push_back(buf[i]);
		}
		sort(sig.begin(), sig.end());
		str sigbuf;
		sig2str(sig, sigbuf);
		warnx << sigbuf << "\n";
		queryList.push_back(sig);
a2926 10
		// free the allocated memory
		delete[] buf;
	}
		
	/*
	warnx << "******* Processing query " << count << " ********\n";
	numReads = numWrites = dataReadSize = cacheHits = 0;
	strbuf s;
	s << rootNodeID;
	str rootID(s);
d2928 1
a2928 10
	//if ((int) listOfSigs.size() > MAXSIGSPERQUERY) {
	if (0) {
		warnx << "Skipping this query...\n";
	} else {
		numDocs = 0;
		listOfVisitedNodes.clear();
				
		double beginQueryTime = getgtod();
		str junk("");
		queryProcess(rootID, listOfSigs, junk);
d2930 4
a2933 9

		double endQueryTime = getgtod();

		std::cerr << "Query time: " << endQueryTime - beginQueryTime << " secs\n";
		totalTime += (endQueryTime - beginQueryTime);
		warnx << "Num docs: " << numDocs << "\n";
	}
		
		#ifdef _DEBUG_
d2935 16
a2950 13
		#endif
		warnx << "Data read in bytes: " << dataFetched << "\n";
		warnx << "Data written in bytes: " << dataStored << "\n";
		warnx << "Number of DHT lookups: " << numReads << "\n";
		//warnx << " num writes: " << numWrites << "\n";
		warnx << "Cache hits: " << cacheHits << "\n";
		warnx << "******** Finished query processing *********\n\n\n";
		count++;

		if (count != maxCount + 1) {
			warnx << "Sleeping...\n";
			//sleep(1);
			//sleep(1 + (int) ((double) randDelay * (rand() / (RAND_MAX + 1.0))));
d2952 1
a2952 2
	}
	*/
d2964 1
d2974 12
a2985 1

d3021 7
d3311 1
a3311 1
add2querymap(std::vector<std::vector<POLY> > queryList)
d3314 1
d3318 6
d4401 1
d4415 1
a4415 1
	     << "	-M		test mergelists(p) (requires -D, -y, -Z)\n"
@


1.97
log
@wait after listening (before gossiping)
wait after lshquery insert
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.96 2011/09/21 18:36:39 vsfgd Exp vsfgd $	*/
d32 1
a32 1
static char rcsid[] = "$Id: gpsi.C,v 1.96 2011/09/21 18:36:39 vsfgd Exp vsfgd $";
d152 1
d519 1
a520 5
				warnx << "sleeping (lsh)...\n";
				initsleep = 0;
				delaycb(intval, 0, wrap(initsleepnow));
				while (initsleep == 0) acheck();
			}
d529 5
a653 5

				warnx << "sleeping (lsh)...\n";
				initsleep = 0;
				delaycb(intval, 0, wrap(initsleepnow));
				while (initsleep == 0) acheck();
d663 5
d1643 10
d1659 1
d3549 27
@


1.96
log
@fix dummysig bug in XGossip init phase
log more info in init phase
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.95 2011/09/20 17:41:12 vsfgd Exp vsfgd $	*/
d32 1
a32 1
static char rcsid[] = "$Id: gpsi.C,v 1.95 2011/09/20 17:41:12 vsfgd Exp vsfgd $";
d519 4
a522 6
				// TODO: how long (if at all)?
				//warnx << "sleeping (lsh)...\n";

				//initsleep = 0;
				//delaycb(intval, 0, wrap(initsleepnow));
				//while (initsleep == 0) acheck();
d1338 5
a1342 1
		//sleep(5);
@


1.95
log
@handle query sig (in addition to xpath queries) again
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.94 2011/09/19 18:15:42 vsfgd Exp vsfgd $	*/
d32 1
a32 1
static char rcsid[] = "$Id: gpsi.C,v 1.94 2011/09/19 18:15:42 vsfgd Exp vsfgd $";
d131 1
a131 1
void calcfreq(std::vector<std::vector <POLY> >);
d636 5
d655 4
a658 6
				// TODO: how long (if at all)?
				//warnx << "sleeping (lsh)...\n";

				//initsleep = 0;
				//delaycb(intval, 0, wrap(initsleepnow));
				//while (initsleep == 0) acheck();
d1174 1
d1176 1
d1187 1
a1187 1
		calcfreq(sigList);
d1378 1
d1382 1
d2156 5
a2160 5
		//sig2str(sig, sigbuf);
		//warnx << "sig: " << sigbuf;
		//printdouble(" ", freq);
		//printdouble(" ", weight);
		//warnx << "\n";
d2847 1
a2847 1
	str buf;
d2865 1
a2865 1
		// ?
a2873 1
		warnx << "totalT.size() == 0\n";
d2885 5
d3128 1
a3128 1
calcfreq(std::vector<std::vector<POLY> > sigList)
d3131 1
d3133 7
a3139 3
	// dummy's freq is 0 and weight is 1
	uniqueSigList[sigList[0]].push_back(0);
	uniqueSigList[sigList[0]].push_back(1);
d3141 1
a3141 2
	// skip dummy
	for (int i = 1; i < (int)sigList.size(); i++) {
d4171 1
a4171 1
					"\t\t\t(wait time after XGossip init phase is done)\n"
@


1.94
log
@major: merge results locally (after querying)
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.93 2011/09/15 16:16:54 vsfgd Exp vsfgd $	*/
d32 1
a32 1
static char rcsid[] = "$Id: gpsi.C,v 1.93 2011/09/15 16:16:54 vsfgd Exp vsfgd $";
d165 1
a165 1
void run_query(int, std::vector<POLY>, int &, double &, chordID = 0);
d1243 1
a1243 1
	// reading and querying using XPath files
d2192 1
a2192 1
			run_query(tind, querysig, sigmatches, totalavg);
d2217 1
a2217 1
				run_query(i, querysig, sigmatches, totalavg, teamID);
d2254 2
a2255 2
void
run_query(int tind, std::vector<POLY> querysig, int &sigmatches, double &totalavg, chordID teamID)
d2261 5
a2265 23
	// TODO: this is more efficient, but duplicates results of superset below
	/*
	mapType::iterator sigitr = totalT[tind][0].find(querysig);
	// exact signature found
	if (sigitr != totalT[tind][0].end()) {
		freq = sigitr->second[0];
		weight = sigitr->second[1];
		warnx << "exact sig found: ";
		warnx << "sig: " << sigbuf;
		sig2str(sig, sigbuf);
		printdouble(", f: ", freq);
		printdouble(", w: ", weight);
		printdouble(", avg: ", freq/weight);
		warnx << "\n";
		sigfound = 1;
	}
	*/

	// find if the query sig is a subset of any of the sigs
	for (mapType::iterator itr = totalT[tind][0].begin(); itr != totalT[tind][0].end(); itr++) {
		ninter = set_inter_noskip(querysig, itr->first, multi);
		//warnx << "ninter: " << ninter << ", querysig.size(): " << querysig.size() << "\n";
		if (ninter == (int)querysig.size()) {
d2267 6
a2272 6
			totalavg += (itr->second[0]/itr->second[1]);
			sig2str(itr->first, sigbuf);
			warnx << "supersetsig: " << sigbuf;
			printdouble(" f: ", itr->second[0]);
			printdouble(" w: ", itr->second[1]);
			printdouble(" avg: ", itr->second[0]/itr->second[1]);
a2275 1
			//if (multi == 1) warnx << "superset sig is a multiset\n";
d2277 23
d2301 2
d2338 1
a2338 1
			qid = strtol(tokens[4].c_str(), NULL, 10);
d2340 1
a2340 1
			string2sig(tokens[6], querysig);
@


1.93
log
@keep track of number of received queries
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.92 2011/09/14 19:31:32 vsfgd Exp vsfgd $	*/
d32 1
a32 1
static char rcsid[] = "$Id: gpsi.C,v 1.92 2011/09/14 19:31:32 vsfgd Exp vsfgd $";
d75 17
a91 3
// multimap for storing queries
typedef std::multimap<std::vector<POLY>, int, CompareSig> multimapType;
multimapType queryMap;
d93 1
a93 1
// map sigs to freq and weight
d95 1
d101 7
d147 1
d149 1
a149 1
int lshquery(multimapType, int, InsertType, int);
d165 1
a165 1
void run_query(int, std::vector<POLY>, int &, double &);
d169 1
d426 1
a426 1
lshquery(multimapType queryMap, int intval = -1, InsertType msgtype = INVALID, int col = 0)
d446 1
a446 1
	for (multimapType::iterator itr = queryMap.begin(); itr != queryMap.end(); itr++) {
d794 1
a794 1
	int Gflag, Lflag, lflag, rflag, Sflag, sflag, zflag, vflag, Hflag, dflag, jflag, mflag, Iflag, Eflag, Pflag, Dflag, Mflag, Fflag, xflag;
d804 1
d809 1
d820 1
a820 1
	Gflag = Lflag = lflag = rflag = Sflag = sflag = zflag = vflag = Hflag = dflag = jflag = mflag = Eflag = Iflag = Pflag = Dflag = Mflag = Fflag = xflag = 0;
d835 1
a835 1
	while ((ch = getopt(argc, argv, "B:CcD:d:EF:G:gHhIj:L:lMmn:o:P:pQq:R:rS:s:T:t:uvw:X:x:Z:z")) != -1)
d943 4
d948 1
d1020 11
a1030 1
	if (Mflag == 1 && Dflag == 0) usage();
d1265 1
a1265 1
			for (multimapType::iterator itr = queryMap.begin(); itr != queryMap.end(); itr++) {
d1278 1
a1278 1
	// run queries on sigs
d1285 1
a1285 1
		for (multimapType::iterator qitr = queryMap.begin(); qitr != queryMap.end(); qitr++) {
a1294 1
					/*
a1304 1
					*/
d1597 6
a1602 1
		warnx << "testing merging...\n";
d1605 113
a1717 9
		int nlists = 0;
		int zerofiles = 0;
		int totallists = 0;
		warnx << "loading lists from files...\n";
		for (unsigned int i = 0; i < initfiles.size(); i++) {
			warnx << "file: " << initfiles[i].c_str() << "\n";
			if ((initfp = fopen(initfiles[i].c_str(), acc.c_str())) == NULL) {
				warnx << "can't open init file" << initfiles[i].c_str() << "\n";
				continue;
a1718 27
			nlists = loadinitstate(initfp);
			if (nlists == 0) ++zerofiles;
			totallists += nlists;
			fclose(initfp);
		}
		beginTime = getgtod();    
		warnx << "total lists added: " << totallists << "\n";
		warnx << "total 0-sized init files: " << zerofiles << "\n";
		warnx << "totalT.size(): " << totalT.size() << "\n";
		if (plist == 1) {
			warnx << "teamids (before merging)\n";
			printteamids();
			warnx << "lists (before merging)\n";
			printlistall();
		}
		for (int i = 0; i < (int)totalT.size(); i++) {
			mergelists(totalT[i]);
		}
		endTime = getgtod();    
		printdouble("merge lists time: ", endTime - beginTime);
		warnx << "\n";
		/*
		if (plist == 1) {
			warnx << "teamids (after merging)\n";
			printteamids();
			warnx << "lists (after merging)\n";
			printlistall();
a1719 1
		*/
d1992 1
a1992 1
	sigmatches = ninter = msglen = recvlen = nothing = 0;
a1994 1
	totalavg = 0;
d2186 1
a2186 1
			warnx << " teamID found"; 
a2197 2
			sigmatches = 0;
			totalavg = 0;
d2200 2
d2206 1
d2208 7
a2214 2
			/*
			bool sigfound = 0;
a2215 10
				sigmatches = 0;
				totalavg = 0;
				run_query(i, querysig, sigmatches, totalavg);
				if (sigmatches == 0) {
					continue;
				}
				sigfound = 1;
				warnx << "queryresult: ";
				warnx << "teamID NOT found";
				warnx << " qid: " << qid << " querysig: " << sigbuf;
d2217 1
a2217 5
				warnx << " sigmatches: " << sigmatches;
				printdouble(" totalavg: ", totalavg);
				warnx << " teamID: " << teamID << "\n";
				sigmatches = 0;
				totalavg = 0;
d2220 6
a2225 9
			if (sigfound == 0) {
				warnx << "queryresult: ";
				warnx << "teamID NOT found";
				warnx << " qid: " << qid << " querysig: " << sigbuf;
				warnx << " sigmatches: " << sigmatches;
				printdouble(" totalavg: ", totalavg);
				warnx << " teamID: " << teamID << "\n";
			}
			*/
d2228 1
a2228 1
		// TODO: search other lists (not yet merged) and for other sigs?
d2255 1
a2255 1
run_query(int tind, std::vector<POLY> querysig, int &sigmatches, double &totalavg)
d2291 2
d2300 189
d3215 13
d4154 2
d4162 1
a4162 1
	     << "	-M		test mergelists(p) (requires -D)\n"
@


1.92
log
@output sigs which match
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.91 2011/09/14 14:42:20 vsfgd Exp vsfgd $	*/
d32 1
a32 1
static char rcsid[] = "$Id: gpsi.C,v 1.91 2011/09/14 14:42:20 vsfgd Exp vsfgd $";
d169 1
d798 1
d803 1
d2066 2
a2067 2
			warnx << "queryresult: ";
			warnx << "teamID found"; 
d2074 2
a2075 1
			warnx << "queryresultend: ";
d2081 1
d2083 2
a2084 2
			warnx << "queryresult: ";
			warnx << "teamID NOT found";
@


1.91
log
@handle duplicate teamID not founds better
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.90 2011/09/13 19:50:44 vsfgd Exp vsfgd $	*/
d32 1
a32 1
static char rcsid[] = "$Id: gpsi.C,v 1.90 2011/09/13 19:50:44 vsfgd Exp vsfgd $";
d2067 1
d2071 1
d2074 1
a2074 1
			warnx << " teamID: " << teamID << "\n";
a2077 1
			/*
d2082 2
a2083 1
			*/
d2112 1
d2146 1
a2172 4
			/*
			warnx << "superset sig found: ";
			sig2str(querysig, sigbuf);
			warnx << "query sig: " << sigbuf;
d2174 1
a2174 1
			warnx << " superset sig: " << sigbuf;
d2179 1
a2179 2
			if (multi == 1) warnx << "superset sig is a multiset\n";
			*/
@


1.90
log
@don't ignore a query if teamID not found
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.89 2011/09/13 16:20:55 vsfgd Exp vsfgd $	*/
d32 1
a32 1
static char rcsid[] = "$Id: gpsi.C,v 1.89 2011/09/13 16:20:55 vsfgd Exp vsfgd $";
d2082 1
d2084 7
a2093 3
				sigmatches = 0;
				totalavg = 0;
				run_query(i, querysig, sigmatches, totalavg);
d2101 9
@


1.89
log
@query result on one line for easier parsing
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.88 2011/09/12 18:26:06 vsfgd Exp vsfgd $	*/
d32 1
a32 1
static char rcsid[] = "$Id: gpsi.C,v 1.88 2011/09/12 18:26:06 vsfgd Exp vsfgd $";
d112 1
d142 1
a142 1
void delspecial(int);
d1223 1
a1223 1
				warnx << "qid: " << itr->second << " querysig: " << sigbuf << "\n";
d1238 1
a1238 1
		double totalavg = 0;
d1248 3
a1250 1
					totalavg += (sitr->second[0]/sitr->second[1]);
d1266 2
a1267 1
			warnx << "qid: " << qitr->second << " querysig: " << sigbuf;
d1269 1
a1269 1
			printdouble(" totalavg: ", totalavg);
d1272 1
a1272 1
			totalavg = 0;
a2036 1

a2056 1
		warnx << "queryresult: ";
d2063 2
a2065 1
			warnx << "teamID found"; 
d2067 3
a2069 42
			mapType::iterator sigitr = totalT[tind][0].find(querysig);
			// TODO: this is more efficient, but duplicates results of superset below
			// exact signature found
			/*
			if (sigitr != totalT[tind][0].end()) {
				freq = sigitr->second[0];
				weight = sigitr->second[1];
				warnx << "exact sig found: ";
				warnx << "sig: " << sigbuf;
				sig2str(sig, sigbuf);
				printdouble(", f: ", freq);
				printdouble(", w: ", weight);
				printdouble(", avg: ", freq/weight);
				warnx << "\n";
				sigfound = 1;
			}
			*/

			// find if the query sig is a subset of any of the sigs
			for (mapType::iterator itr = totalT[tind][0].begin(); itr != totalT[tind][0].end(); itr++) {
				ninter = set_inter_noskip(querysig, itr->first, multi);
				//warnx << "ninter: " << ninter << ", querysig.size(): " << querysig.size() << "\n";
				if (ninter == (int)querysig.size()) {
					++sigmatches;
					totalavg += (itr->second[0]/itr->second[1]);
					/*
					warnx << "superset sig found: ";
					sig2str(querysig, sigbuf);
					warnx << "query sig: " << sigbuf;
					sig2str(itr->first, sigbuf);
					warnx << " superset sig: " << sigbuf;
					printdouble(" f: ", itr->second[0]);
					printdouble(" w: ", itr->second[1]);
					printdouble(" avg: ", itr->second[0]/itr->second[1]);
					warnx << "\n";
					if (multi == 1) warnx << "superset sig is a multiset\n";
					*/
				}
			}

			sig2str(querysig, sigbuf);
			//warnx << "qid: " << qid << " querysig: " << sigbuf;
d2072 1
a2072 1
			warnx << "\n";
d2076 2
d2079 17
a2095 1
			warnx << " qid: " << qid << " querysig: " << sigbuf << "\n";
d2098 1
a2099 1
		// TODO: search other lists (not yet merged) and for other sigs?
d2124 47
@


1.88
log
@store queries in a multimap
rename lshchordID to lshsig
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.87 2011/09/10 21:36:43 vsfgd Exp vsfgd $	*/
d32 1
a32 1
static char rcsid[] = "$Id: gpsi.C,v 1.87 2011/09/10 21:36:43 vsfgd Exp vsfgd $";
d1222 1
a1222 1
				warnx << "qid: " << itr->second << " querysig" << sigbuf << "\n";
d1248 1
d1259 1
d1860 2
a1861 2
	double freq, weight;
	int n, msglen, recvlen, nothing, tind, ninter, qid;
d1865 1
a1865 1
	ninter = msglen = recvlen = nothing = 0;
d1868 1
d2054 1
a2054 3
		warnx << "qid: " << qid;
		warnx << " querysig: " << sigbuf << "\n";
		warnx << "query result: ";
a2059 1
			bool sigfound = 0;
d2061 3
a2063 1
			warnx << "teamID found at teamindex[" << tind << "]\n";
d2065 1
d2067 1
d2080 1
d2087 3
a2089 1
					sigfound = 1;
d2100 1
d2104 7
a2110 2
			if (sigfound == 0)
				warnx << "exact sig NOT found, superset sig NOT found\n";
d2112 2
a2113 1
			warnx << "teamID NOT found\n";
@


1.87
log
@run xpath queries locally
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.86 2011/09/08 20:52:29 vsfgd Exp vsfgd $	*/
d32 1
a32 1
static char rcsid[] = "$Id: gpsi.C,v 1.86 2011/09/08 20:52:29 vsfgd Exp vsfgd $";
a53 1
std::vector<std::vector<POLY> > queryList;
d75 4
d103 1
d124 2
a125 1
int lshchordID(vecomap, int, InsertType, int, int);
d400 121
a520 1
lshchordID(vecomap teamvecomap, int intval = -1, InsertType msgtype = INVALID, int listnum = 0, int col = 0)
d558 1
a558 1
		printdouble("lshchordID: lsh time: ", endTime - beginTime);
d634 1
a634 1
			printdouble("lshchordID: insert time (only): ", totalinstime);
d637 1
a637 1
			printdouble("lshchordID: insert time (+others): ", endTime - beginTime);
d677 1
a677 1
// TODO: allT -> totalT
a764 73
// obsolete: use lshchordID instead
int
querychordID(std::vector<std::vector<chordID> > &matrix, int intval = -1, InsertType msgtype = INVALID, int listnum = 0, int col = 0)
{
	std::vector<chordID> minhash;
	std::vector<POLY> sig;
	std::vector<POLY> lshsig;
	chordID ID;
	DHTStatus status;
	char *value;
	int valLen;
	double freq, weight, instime;

	minhash.clear();
	sig.clear();
	lshsig.clear();
	for (mapType::iterator itr = allT[listnum].begin(); itr != allT[listnum].end(); itr++) {
		sig = itr->first;
		freq = itr->second[0];
		weight = itr->second[1];

		lsh *myLSH = new lsh(sig.size(), lfuncs, mgroups, lshseed, col, irrnums, hasha, hashb);
		// convert multiset to set
		if (uflag == 1) {
			lshsig = myLSH->getUniqueSet(sig);
			minhash = myLSH->getHashCode(lshsig);
		} else {
			minhash = myLSH->getHashCode(sig);
		}

		//matrix.push_back(minhash);

		if (msgtype != INVALID) {
			std::vector<chordID> team;
			chordID teamID;
			team.clear();

			int range = (int)minhash.size();
			// randomness verified
			int randcol = randomNumGenZ(range);
			ID = (matrix.back())[randcol];
			//warnx << "ID in randcol " << randcol << ": " << ID << "\n";
			strbuf t;
			t << ID;
			str key(t);
			warnx << "inserting " << msgtype << ":\n";
			// TODO: generate teamID
			makeKeyValue(&value, valLen, key, key, sig, freq, weight, msgtype);
			totaltxmsglen += valLen;
			status = insertDHT(ID, value, valLen, instime, MAXRETRIES);
			cleanup(value);

			// do not exit if insert FAILs!
			if (status != SUCC) {
				// TODO: do I care?
				warnx << "error: insert FAILed\n";
			} else {
				warnx << "insert SUCCeeded\n";
			}

			// TODO: how long (if at all)?
			//sleep(intval);
			warnx << "sleeping (lsh)...\n";

			initsleep = 0;
			delaycb(intval, 0, wrap(initsleepnow));
			while (initsleep == 0) acheck();
		}
		delete myLSH;
	}
	return 0;
}

d786 1
d1207 1
a1207 2
		// store queries in a vector, not a map
		// (different xpath queries may transform into the same sig)
d1220 5
d1229 1
d1240 1
a1240 1
		for (unsigned int i = 0; i < queryList.size(); i++) {
d1242 2
a1243 2
			for (mapType::iterator itr = allT[0].begin(); itr != allT[0].end(); itr++) {
				ninter = set_inter_noskip(queryList[i], itr->first, multi);
d1245 1
a1245 1
				if (ninter == (int)queryList[i].size()) {
d1247 1
a1247 1
					totalavg += (itr->second[0]/itr->second[1]);
d1250 1
a1250 1
						sig2str(itr->first, sigbuf);
d1252 3
a1254 3
						printdouble(" f: ", itr->second[0]);
						printdouble(" w: ", itr->second[1]);
						printdouble(" avg: ", itr->second[0]/itr->second[1]);
d1260 2
a1261 2
			sig2str(queryList[i], sigbuf);
			warnx << "querysig" << i << ": " << sigbuf;
d1306 1
a1306 1
			lshchordID(allT, initintval, INITGOSSIP);
d1538 1
a1538 1
			lshchordID(allT, initintval, QUERYX);
d1541 1
a1541 1
			lshchordID(allT, initintval, QUERYS);
d1859 1
a1859 1
	int n, msglen, recvlen, nothing, tind, ninter;
d1865 1
d2029 2
d2033 2
a2035 1
			// TODO: handle Xpath queries
d2037 1
a2039 2
		querysig.clear();
		ret = getKeyValue(gmsg.cstr(), key, keyteamid, querysig, freq, weight, recvlen);
d2051 2
a2052 1
		warnx << "querysig: " << sigbuf << "\n";
d2080 1
a2080 1
				warnx << "ninter: " << ninter << ", querysig.size(): " << querysig.size() << "\n";
d2087 4
a2090 4
					warnx << ", superset sig: " << sigbuf;
					printdouble(", f: ", itr->second[0]);
					printdouble(", w: ", itr->second[1]);
					printdouble(", avg: ", itr->second[0]/itr->second[1]);
d2096 1
a2096 1
			if (sigfound == 0) {
a2097 3
			} else {
				// TODO: ?
			}
d2736 12
d2760 1
a2760 1
	for (int i = 1; i < (int) sigList.size(); i++) {
@


1.86
log
@when receiving a query, when calculating the set intersection, don't skip duplicates
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.85 2011/09/08 17:30:26 vsfgd Exp vsfgd $	*/
d32 1
a32 1
static char rcsid[] = "$Id: gpsi.C,v 1.85 2011/09/08 17:30:26 vsfgd Exp vsfgd $";
d54 1
a733 1
	std::vector<std::vector<POLY> > queryList;
a970 21
	// reading and querying using XPath files
	if ((rflag == 1 || Qflag == 1) && xflag == 1) {
		getdir(xpathdir, xpathfiles);
		queryList.clear();

		warnx << "reading queries from files...\n";
		for (unsigned int i = 0; i < xpathfiles.size(); i++) {
			readquery(xpathfiles[i], queryList);
		}
		warnx << "calculating frequencies...\n";
		beginTime = getgtod();    
		calcfreq(queryList);
		endTime = getgtod();    
		printdouble("calcfreq time (+sorting): ", endTime - beginTime);
		warnx << "\n";
		if (plist == 1) {
			// both init phases use allT
			printlist(allT, 0, -1);
		}
	}

d1145 67
d2254 2
d2262 1
a2262 1
		//break;
d2343 1
@


1.85
log
@discard "1"s from xpath queries
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.84 2011/09/07 17:14:52 vsfgd Exp vsfgd $	*/
d32 1
a32 1
static char rcsid[] = "$Id: gpsi.C,v 1.84 2011/09/07 17:14:52 vsfgd Exp vsfgd $";
d140 1
d1971 1
a1971 1
				ninter = set_inter(querysig, itr->first, multi);
d1991 1
d2759 57
@


1.84
log
@minor changes in logging
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.83 2011/09/06 00:51:55 vsfgd Exp vsfgd $	*/
d32 1
a32 1
static char rcsid[] = "$Id: gpsi.C,v 1.83 2011/09/06 00:51:55 vsfgd Exp vsfgd $";
d508 2
d2235 2
@


1.83
log
@calculate rx/tx bw per round
calculate lsh time
calculate actual insert time
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.82 2011/09/05 06:58:12 vsfgd Exp vsfgd $	*/
d32 1
a32 1
static char rcsid[] = "$Id: gpsi.C,v 1.82 2011/09/05 06:58:12 vsfgd Exp vsfgd $";
d1285 1
a1285 1
			warnx << ", txseq: " << txseq.back() << "\n";
d1416 1
a1416 1
				warnx << ", txseq: " << txseq.back() << "\n";
d1938 1
a1938 1
		warnx << " rxID: " << key << "\n";
@


1.82
log
@didn't compile
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.81 2011/09/05 06:56:42 vsfgd Exp vsfgd $	*/
d32 1
a32 1
static char rcsid[] = "$Id: gpsi.C,v 1.81 2011/09/05 06:56:42 vsfgd Exp vsfgd $";
d64 4
d112 1
a112 1
DHTStatus insertDHT(chordID, char *, int, int = MAXRETRIES, chordID = 0);
d406 1
a406 1
	double freq, weight, beginTime, endTime;
d414 1
d428 1
d430 3
d484 3
a486 1
				status = insertDHT(ID, value, valLen, MAXRETRIES);
d506 3
a508 2
			endTime = getgtod();    
			printdouble("lshchordID: insert time (full sig): ", endTime - beginTime);
d560 1
a560 1
	double freq, weight;
d615 2
a616 1
			status = insertDHT(ID, value, valLen, MAXRETRIES);
d647 1
a647 1
	double freq, weight;
d684 2
a685 1
			status = insertDHT(ID, value, valLen, MAXRETRIES);
d714 1
a714 1
	double beginTime, endTime;
d1243 1
d1269 3
a1271 1
			status = insertDHT(ID, value, valLen, MAXRETRIES);
d1284 3
d1323 1
d1386 2
d1390 1
a1390 1
						status = insertDHT(ID, value, valLen, MAXRETRIES);
d1415 3
d1500 1
a1500 1
insertDHT(chordID ID, char *value, int valLen, int STOPCOUNT, chordID guess)
d1540 2
a1541 1
		printdouble("key insert time: ", endTime - beginTime);
d2435 1
d2462 1
d2465 1
a2465 1
	status = insertDHT(nextID, value, valLen, MAXRETRIES);
@


1.81
log
@started integrating sig comptacting
stop gossiping after a particular round
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.80 2011/09/03 22:02:51 vsfgd Exp vsfgd $	*/
d32 1
a32 1
static char rcsid[] = "$Id: gpsi.C,v 1.80 2011/09/03 22:02:51 vsfgd Exp vsfgd $";
d1361 1
a1361 1
							compressSignatures(totalT[i][0], compressedList, outBitmap);
@


1.80
log
@process XPath queries
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.79 2011/06/08 05:35:00 vsfgd Exp vsfgd $	*/
d32 1
a32 1
static char rcsid[] = "$Id: gpsi.C,v 1.79 2011/06/08 05:35:00 vsfgd Exp vsfgd $";
d60 1
d140 1
d402 1
a402 1
	double freq, weight;
d455 1
d495 3
d699 1
a699 1
	int ch, gintval, initintval, waitintval, nids, valLen, logfd;
d718 3
d725 1
d735 1
a735 1
	while ((ch = getopt(argc, argv, "B:cD:d:EF:G:gHhIj:L:lMmn:P:pQq:R:rS:s:T:t:uvw:X:x:Z:z")) != -1)
d743 3
d803 3
d1087 1
d1101 38
a1224 1
		// gossip indefinitely
d1226 10
a1298 1
		// gossip indefinitely
d1300 10
d1357 10
a1366 1
						makeKeyValue(&value, valLen, key, teamID, totalT[i][0], txseq.back(), XGOSSIP);
d3342 8
d3460 1
a3460 1
	warnx << "hdrB: sig freq weight avg avg*peers avg*teamsize cmp2prev multi\n";
d3491 2
a3492 1
		warnx << " " << multi << "\n";
d3496 1
a3496 1
	warnx << "hdrE: sig freq weight avg avg*peers avg*teamsize cmp2prev multi\n";
d3536 1
d3550 2
a3551 1
	     << "      	-n		<how many>\n"
a3573 1
	     << "	-C		calculate distance\n"
@


1.79
log
@add2vecomapx: fixed segfault
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.78 2011/06/08 02:12:29 vsfgd Exp vsfgd $	*/
d32 1
a32 1
static char rcsid[] = "$Id: gpsi.C,v 1.78 2011/06/08 02:12:29 vsfgd Exp vsfgd $";
a50 1
static char *xpathfile;
d108 1
d127 1
a129 1
//void retrieveDHT(chordID ID, int, str&, chordID guess = 0);
d134 2
a135 2
double sig_inter(std::vector<POLY>, std::vector<POLY>, bool&);
double sig_uni(std::vector<POLY>, std::vector<POLY>, bool&);
d705 1
d708 1
d710 1
d825 1
a825 1
			xpathfile = optarg;
d910 2
a911 2
	// sigs are required when listening or reading
	if ((lflag == 1 || rflag == 1) && sflag == 0) usage();
d938 8
a945 33
	// TODO: read XPath query in memory
	// (copied from psi.C)
	if (Qflag == 1 && xflag == 1) {
		if (stat(xpathfile, &statbuf) != 0)
			fatal << "'" << xpathfile << "' does not exist" << "\n";

		// Read the query signatures from a file
		FILE *qfp = fopen(xpathfile, "r");
		assert(qfp);

		// Open the tags files too...
		std::string tagsfile = xpathfile + std::string(TAGFILE);
			
		FILE *fpTags = fopen(tagsfile.c_str(), "r");
		assert(fpTags);

		// Open the tag depth file...
		std::string tagdepth = xpathfile + std::string(TAGDEPTH);
		FILE *fpTagDepth = fopen(tagdepth.c_str(), "r");
		assert(fpTagDepth);

		// Open the value file...
		std::string valfile = xpathfile + std::string(VALFILE);
		FILE *fpVal = fopen(valfile.c_str(), "r");
		assert(fpVal);

		// DON'T use readData to retrieve signatures from input files...
		// since the size filed uses POLY as a basic unit and not byte...
		// Format is <n = # of sigs><sig size><sig>... n times...
		int numSigs;
		if (fread(&numSigs, sizeof(numSigs), 1, qfp) != 1) {
			warnx << "break\n";
			//break;
d947 9
a955 30
		assert(numSigs > 0);

		std::vector<std::vector<POLY> > listOfSigs;
		listOfSigs.clear();
			
		for (int t = 0; t < numSigs; t++) {
			POLY *buf;
			int size;
			if (fread(&size, sizeof(int), 1, qfp) != 1) {
				assert(0);
			}
				
			buf = new POLY[size];
			assert(buf);
			if (fread(buf, sizeof(POLY), size, qfp) != (size_t) size) {
				assert(0);
			}
				
			std::vector<POLY> sig;
			sig.clear();
			for (int i = 0; i < size; i++) {
				sig.push_back(buf[i]);
			}

			listOfSigs.push_back(sig);
			sig2str(sig, sigbuf);
			warnx << sigbuf << "\n";

			// free the allocated memory
			delete[] buf;
a956 45
			
		//warnx << "******* Processing query " << count << " ********\n";
		//numReads = numWrites = dataReadSize = cacheHits = 0;

		// Read the distinct tags
		std::vector<std::string> distinctTags;
		distinctTags.clear();

		// Tag depth
		std::vector<std::string> tagDepth;
		tagDepth.clear();
			
		readTags(fpTags, distinctTags);
		warnx << "distinctTags:\n";
		for (int i = 0; i < (int) distinctTags.size(); i++) {
			warnx << distinctTags[i].c_str() << "\n";
		}
		readTags(fpTagDepth, tagDepth);
		warnx << "tagDepth:\n";
		for (int i = 0; i < (int) tagDepth.size(); i++) {
			warnx << tagDepth[i].c_str() << "\n";
		}

		// Pick the highest depth entry
		int maxDepth = -1;
		int maxDepthId = -1;
		for (int p = 0; p < (int) tagDepth.size(); p++) {
			if (atoi(tagDepth[p].c_str()) > maxDepth) {
				maxDepth = atoi(tagDepth[p].c_str());
				maxDepthId = p;
			}
		}
		warnx << "maxDepth: " << maxDepth << ", maxDepthId: " << maxDepthId << "\n";

		// Read the values
		std::multimap<POLY, std::pair<std::string, enum OPTYPE> > valList;
		valList.clear();
		readValues(fpVal, valList);

		/*
		std::vector<POLY> valSig;
		valSig.clear();
		*/

		// TODO: verify
d1641 1
d1643 1
a1643 1
	int n, msglen, recvlen, nothing, tind;
d1645 1
d1647 2
a1648 1
	msglen = recvlen = nothing = 0;
d1815 1
d1819 2
a1820 2
		sig.clear();
		ret = getKeyValue(gmsg.cstr(), key, keyteamid, sig, freq, weight, recvlen);
d1831 3
a1833 3
		sig2str(sig, sigbuf);
		warnx << "sig: " << sigbuf << "\n";
		warnx << "query result:\n";
d1839 1
d1842 2
a1843 1
			mapType::iterator sigitr = totalT[tind][0].find(sig);
d1847 4
a1850 2
				warnx << "sig found\n";
				printdouble("f: ", freq);
d1854 24
d1879 1
a1879 2
				warnx << "sig NOT found\n";
		}
d2082 104
a2191 1
	chordID rootNodeID;
d3370 1
a3370 1
	warnx << "hdrB: sig freq weight avg avg*n:peers avg*q:mgroups cmp2prev multi\n";
d3385 1
a3385 1
		printdouble(" ", avg * mgroups);
d3405 1
a3405 1
	warnx << "hdrE: sig freq weight avg avg*n:peers avg*q:mgroups cmp2prev multi\n";
d3431 1
a3431 1
	warn << "\t" << __progname << " -Q -S dhash-sock -s sigdir -F hashfile -d 1122941 -j irrpoly-deg9.dat -B 10 -R 16 -u\n\n";
d3433 1
a3433 1
	warn << "\t" << __progname << " -Q -S dhash-sock -x xpathsig -F hashfile -d 1122941 -j irrpoly-deg9.dat -B 10 -R 16 -u\n\n";
d3435 1
a3435 1
	warn << "\t" << __progname << " -H -I -s sigdir -F hashfile -d 1122941 -j irrpoly-deg9.dat -B 10 -R 16 -u -p\n\n";
d3442 1
a3442 1
	     << "\t     -H -d 1122941 -j irrpoly-deg9.dat -u -B 50 -R 10 -I -E -P initfile -p\n\n";
d3470 1
a3470 1
	     << "	-u		make POLYs unique (convert multiset to set)\n"
d3475 1
a3475 1
	     << "	-x		<xpath file>\n"
d3485 1
a3485 1
	     << "	-r		read signatures (requires -s)\n"
@


1.78
log
@printlist: move teamID in list hdr
lshchordID: remove calcteam/printteam output
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.77 2011/06/07 06:06:07 vsfgd Exp vsfgd $	*/
d32 1
a32 1
static char rcsid[] = "$Id: gpsi.C,v 1.77 2011/06/07 06:06:07 vsfgd Exp vsfgd $";
d2536 1
a2552 1
	warnx << "totalT[tind].size(): " << totalT[tind].size() << "\n";
@


1.77
log
@printlistall displays the correct txseq now
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.76 2011/06/01 14:36:43 vsfgd Exp vsfgd $	*/
d32 1
a32 1
static char rcsid[] = "$Id: gpsi.C,v 1.76 2011/06/01 14:36:43 vsfgd Exp vsfgd $";
d121 1
a121 1
int printlist(vecomap, int, int);
d434 2
d437 1
a440 1
			sort(minhash.begin(), minhash.end());
d445 1
d447 1
a447 1
		calcteamids(minhash);
d525 1
a525 1
	if (plist == 1) printteamidfreq();
d2521 1
d2537 3
d2546 1
d3290 4
a3293 2
		warnx << "teamID(i=" << i << "): " << teamID << "\n";
		totalsigs += printlist(totalT[i], 0, seq);
d3301 1
a3301 1
printlist(vecomap teamvecomap, int listnum, int seq)
d3317 7
a3323 1
	warnx << "list T_" << listnum << ": txseq: " << seq << " len: " << teamvecomap[listnum].size() << "\n";
@


1.76
log
@randcol range was wrong (excluded last team member)
Mflag: count number of total lists and zerosized files
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.75 2011/05/25 02:52:00 vsfgd Exp vsfgd $	*/
d32 1
a32 1
static char rcsid[] = "$Id: gpsi.C,v 1.75 2011/05/25 02:52:00 vsfgd Exp vsfgd $";
d122 1
a122 1
int printlistall();
d1333 1
a1333 1
				printlistall();
d3271 1
a3271 1
printlistall()
d3283 1
a3283 1
		totalsigs += printlist(totalT[i], 0, -1);
@


1.75
log
@teamindex can store pointers to multiple lists
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.74 2011/05/23 06:55:29 vsfgd Exp vsfgd $	*/
d32 1
a32 1
static char rcsid[] = "$Id: gpsi.C,v 1.74 2011/05/23 06:55:29 vsfgd Exp vsfgd $";
d121 2
a122 2
void printlist(vecomap, int, int);
void printlistall();
d457 2
a458 1
				randcol = randomNumGenZ(range-1);
d577 1
a577 1
		int randcol = randomNumGenZ(range-1);
d653 1
a653 1
			int randcol = randomNumGenZ(range-1);
d690 1
a690 1
	int ch, gintval, initintval, waitintval, nids, valLen, logfd, nlists;
d708 1
a708 1
	gintval = waitintval = nids = nlists = 0;
d1357 1
a1357 1
						int randcol = randomNumGenZ(range-1);
d1422 3
d1432 3
a1434 1
			nlists += loadinitstate(initfp);
d1438 2
a1439 1
		warnx << "total lists/teams added: " << nlists << "\n";
d1453 1
d1460 1
d2017 5
a2021 2
	tmpvecomap.push_back(uniqueSigList);
	totalT.push_back(tmpvecomap);
d3234 8
d3246 5
d3252 2
a3253 2
		if (itr->second.size() > 1) {
			for (int i = 0; i < (int)itr->second.size(); i++) {
d3262 5
d3270 1
a3270 1
void
d3274 1
d3283 1
a3283 1
		printlist(totalT[i], 0, -1);
d3285 3
d3290 1
a3290 1
void
d3294 1
a3294 1
	int n, nmulti, ixsim, setsize;
d3306 1
a3306 1
	n = nmulti = ixsim = 0;
d3313 1
d3358 3
@


1.74
log
@consistent naming: XGossip+ -> XGossip, XGossip -> VanillaXGossip
removed commented code
printing all lists and teamids
FIXED: incorrect association of teamIDs and lists!
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.73 2011/04/27 14:48:43 vsfgd Exp vsfgd $	*/
d32 1
a32 1
static char rcsid[] = "$Id: gpsi.C,v 1.73 2011/04/27 14:48:43 vsfgd Exp vsfgd $";
d83 2
a84 1
typedef std::map<chordID, int> teamid2totalT;
d1911 1
a1911 1
			tind = teamitr->second;
d1964 1
a1964 1
	int tind;
d1973 1
d1988 3
a1990 2
			warnx << "teamID(" << tind << "): " << teamID << "\n";
			teamindex[teamID] = tind;
d1992 1
a1992 1
			// (but don't do it for the very first index line
a2050 38
void
loginitstateold(FILE *initfp)
{
	std::vector<POLY> sig;
	sig.clear();
	str sigbuf;
	// merged list is first
	int listnum = 0;
	double freq, weight;

	teamid2totalT::iterator teamitr = teamindex.begin();
	for (int i = 0; i < (int)totalT.size(); i++) {
		// TODO: need assert?
		//assert(teamitr == teamindex.end());
		if (teamitr == teamindex.end()) {
			warnx << "teamindex < totalT at i=" << i
			      << " : " << teamindex.size()
			      << " < " << totalT.size() << "\n";
			break;
		}
		strbuf z;
		z << teamitr->first;
		str teamID(z);
		fprintf(initfp, "index:%d:listsize:%d:teamID:%s\n", i, totalT[i][listnum].size(), teamID.cstr());
		for (mapType::iterator itr = totalT[i][listnum].begin();
		     itr != totalT[i][listnum].end(); itr++) {
			sig = itr->first;
			freq = itr->second[0];
			weight = itr->second[1];
			sig2str(sig, sigbuf);
			fprintf(initfp, "%s:", sigbuf.cstr());
			fprintf(initfp, "%f:", freq);
			fprintf(initfp, "%f\n", weight);
		}
		++teamitr;
	}
}

d2201 1
a2201 1
		tind = teamitr->second;
d2207 1
a2207 1
		teamindex[teamID] = tind;
d2329 4
a2332 2
		if (itr->second == tix) {
			return itr->first;
d2517 1
a2517 1
		tind = teamitr->second;
d2526 1
a2526 1
		teamindex[teamID] = tind;
d3226 8
a3233 1
		warnx << " tix: " << itr->second;
@


1.73
log
@fixed inform_team wraparound (set nextID to team[0])
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.72 2011/03/26 21:09:11 vsfgd Exp vsfgd $	*/
d32 1
a32 1
static char rcsid[] = "$Id: gpsi.C,v 1.72 2011/03/26 21:09:11 vsfgd Exp vsfgd $";
d58 1
d74 2
a75 2
// local list T_m is stored in allT[0];
// use only for storing the sigs initially
d94 1
a94 1
// XGossip(+)
d96 1
a96 1
// Vanilla Gossip
d104 1
d112 2
a113 1
void loadinitstate(FILE *);
d121 1
d123 1
d386 1
a386 1
lshchordID(vecomap teamvecomap, std::vector<std::vector<chordID> > &matrix, int intval = -1, InsertType msgtype = INVALID, int listnum = 0, int col = 0)
d388 1
d392 2
a393 2
	std::vector<POLY> sig1;
	std::vector<POLY> sig2;
d402 1
d413 1
d418 1
d445 14
a458 27
		/*
		matrix.push_back(minhash);
		range = (int)minhash.size();
		// randomness verified
		randcol = randomNumGenZ(range-1);
		//randcol = range / 2;
		ID = (matrix.back())[randcol];
		warnx << "ID in randcol " << randcol << ": " << ID << "\n";
		buckets.push_back(ID);
		*/
	
		if (gflag == 1 && msgtype != INVALID) {
		std::vector<chordID> team;
		chordID teamID;
		team.clear();
		for (int i = 0; i < (int)minhash.size(); i++) {
			teamID = minhash[i];
			warnx << "teamID: " << teamID << "\n";
			// TODO: check return status
			make_team(NULL, teamID, team);
			range = team.size();
			// randomness verified
			randcol = randomNumGenZ(range-1);
			ID = team[randcol];
			//ID = (matrix.back())[randcol];
			warnx << "ID in randcol " << randcol << ": " << ID << "\n";
			if (gflag == 1 && msgtype != INVALID) {
d479 1
a479 2
				//sleep(intval);
				warnx << "sleeping (lsh)...\n";
d481 3
a483 3
				initsleep = 0;
				delaycb(intval, 0, wrap(initsleepnow));
				while (initsleep == 0) acheck();
a487 1
		}
d520 1
a520 1
	if (plist == 1) printteamids();
d611 2
a612 2
//
// TODO: verify
d642 1
a642 1
		matrix.push_back(minhash);
d645 4
d687 2
a688 2
	int Gflag, Lflag, lflag, rflag, Sflag, sflag, zflag, vflag, Hflag, dflag, jflag, mflag, Iflag, Eflag, Pflag, Dflag, Mflag, Fflag, xflag, Qflag;
	int ch, gintval, initintval, waitintval, nids, valLen, logfd, tix;
d705 2
a706 3
	Gflag = Lflag = lflag = rflag = Sflag = sflag = zflag = vflag = Hflag = dflag = jflag = mflag = Eflag = Iflag = Pflag = Dflag = Mflag = Fflag = xflag = Qflag = 0;

	gintval = waitintval = nids = 0;
d710 1
a710 1
	// init or txseq.back() segfaults!
d712 1
a712 1
	// init dummysig!
d716 1
d837 1
d851 1
d853 1
a853 1
	srandom(loseed);
a855 1
		warnx << "unsorted IDs:\n";
d859 1
a859 1
			warnx << "ID: " << ID << "\n";
d867 1
a867 1
		warnx << "\n";
d905 1
d907 1
a907 1
		// overwrite existing file
d914 1
d918 1
d921 1
d930 2
a931 2
	// copied from psi.C
	// read XPath query in memory
d1042 1
d1083 2
a1084 1
		// exec phase
d1114 1
d1129 1
d1136 1
d1187 1
a1188 1
	std::vector<std::vector<chordID> > cmatrix;
d1190 1
d1197 1
a1197 1
	// XGossip+ init phase
d1213 1
a1213 2
			lshchordID(allT, cmatrix, initintval, INITGOSSIP);
			cmatrix.clear();
d1217 1
a1217 1
		printdouble("xgossip+ init phase time: ", endTime - beginTime);
a1223 1
			//sleep(waitintval);
d1228 1
d1233 1
a1233 3
				for (int i = 0; i < (int)totalT.size(); i++) {
					printlist(totalT[i], 0, -1);
				}
d1243 1
a1243 1
	// XGossip exec phase
d1245 1
a1245 1
		warnx << "xgossip exec...\n";
d1252 2
a1261 1
			//mergelists(allT);
d1265 1
a1265 1
			warnx << "inserting XGOSSIP:\n"
a1269 1
				//printlist(allT, 0, txseq.back());
d1272 1
a1272 2
			makeKeyValue(&value, valLen, key, key, totalT[0][0], txseq.back(), XGOSSIP);
			//makeKeyValue(&value, valLen, key, key, allT[0], txseq.back(), XGOSSIP);
a1281 1
				//doublefreq(allT, 0);
d1292 1
a1292 1
	// XGossip+ exec phase
d1294 1
d1299 1
a1299 16
				teamid2totalT::iterator teamitr = teamindex.begin();
				for (int i = 0; i < (int)totalT.size(); i++) {
					// TODO: need assert?
					//assert(teamitr == teamindex.end());
					if (teamitr == teamindex.end()) {
						warnx << "teamindex < totalT at i=" << i
						      << " : " << teamindex.size()
						      << " < " << totalT.size() << "\n";
						break;
					}
					teamID = teamitr->first;
					tix = teamitr->second;
					warnx << "teamID(i=" << i << ",tix=" << tix << "): " << teamID << "\n";
					printlist(totalT[i], 0, -1);
					++teamitr;
				}
d1309 1
a1309 1
		warnx << "xgossip+ exec...\n";
a1313 2
		// xgossip+ sigs grouped by lsh chordid/poly
		//vecomap groupedT;
d1317 2
d1331 1
a1331 15
				teamid2totalT::iterator teamitr = teamindex.begin();
				for (int i = 0; i < (int)totalT.size(); i++) {
					// TODO: need assert?
					//assert(teamitr == teamindex.end());
					if (teamitr == teamindex.end()) {
						warnx << "teamindex < totalT at i=" << i
						      << " : " << teamindex.size()
						      << " < " << totalT.size() << "\n";
						break;
					}
					teamID = teamitr->first;
					warnx << "teamID(" << i << "): " << teamID << "\n";
					printlist(totalT[i], 0, txseq.back());
					++teamitr;
				}
a1333 7
			//srand(loseed);
			// TODO: the same as minhash.size()?
			//int range = mgroups;
			//int randcol = int((double)range * rand() / (RAND_MAX + 1.0));
			// TODO: verify randomness
			//int randcol = randomNumGenZ(range-1);
			// TODO: use findMod()
a1335 19
				/*
				// don't send anything
				//lshpoly(0, pmatrix, 0, -1, randcol);
				lshpoly(pmatrix);
				poly2sig polyindex;
				warnx << "pmatrix.size(): " << pmatrix.size() << "\n";
				warnx << "POLYs in random column " << randcol << ":\n";
				for (int i = 0; i < (int)pmatrix.size(); i++) {
					warnx << pmatrix[i][randcol] << "\n";;
					// store index of signature associated with POLY
					polyindex[pmatrix[i][randcol]].push_back(i);
				}
				warnx << "POLY: [sig indices].size()\n";
				for (poly2sig::iterator itr = polyindex.begin();
				     itr != polyindex.end(); itr++) {
					warnx << itr->first << ": " << itr->second.size() << "\n";
				}
				pmatrix.clear();
				*/
a1337 1
				teamid2totalT::iterator teamitr = teamindex.begin();
a1338 14
					/*
					beginTime = getgtod();    
					warnx << "running lshchordID...\n";
					//lshchordID(cmatrix, -1, INVALID, 0, randcol);
					lshchordID(totalT[i], cmatrix);
					endTime = getgtod();    
					printdouble("lshchordID time: ", endTime - beginTime);
					warnx << "\n";
					chordID2sig idindex;
					warnx << "cmatrix.size(): " << cmatrix.size() << "\n";
					warnx << "cmatrix[0].size(): " << cmatrix[0].size() << "\n";
					warnx << "IDs in random column " << randcol << ":\n";
					*/

d1341 1
a1341 1
						warnx << "inserting XGOSSIPP:\n"
d1344 4
a1347 7
						// TODO: need assert?
						//assert(teamitr == teamindex.end());
						if (teamitr == teamindex.end()) {
							warnx << "teamindex < totalT at i=" << i
							      << " : " << teamindex.size()
							      << " < " << totalT.size() << "\n";
							break;
a1348 1
						teamID = teamitr->first;
a1350 11
						/*
						// TODO: inefficient?
						// get teamID for this totalT[i]
						for (teamid2totalT::iterator itr = teamindex.begin(); itr != teamindex.end(); itr++) {
							if (itr->second == i) {
								teamID = itr->first;
								warnx << "teamID: " << teamID << "\n";
							}
						}
						*/

d1367 1
a1367 1
						makeKeyValue(&value, valLen, key, teamID, totalT[i][0], txseq.back(), XGOSSIPP);
a1391 1
					++teamitr;
d1394 1
a1394 5
				//cmatrix.clear();
				// CLEAR ME!
				//groupedT.clear();
				warnx << "sleeping (xgossip+)...\n";
				//sleep(gintval);
a1397 126

				/* old algorithm
				//col = 0;
				for (int i = 0; i < (int)cmatrix.size(); i++) {
					//for (int j = 0; j < (int)cmatrix[i].size(); j++) {
					//	warnx << cmatrix[i][j] << " ";
					//}
					//warnx << "\n";
					//warnx << cmatrix[i][randcol] << "\n";
					// store index of signature associated with chordID
					idindex[cmatrix[i][randcol]].push_back(i);
					//idindex[cmatrix[i][0]].push_back(i);
					//chordID2sig::iterator itr = idindex.find(matrix[i][randcol]);
					//if (itr != idindex.end()) {
					//	itr->second[0] += 1;
					//} else {
						// store index of signature associated with chordID
						//idindex[matrix[i][randcol]].push_back(i);
					//}

				}
				warnx << "idindex.size(): " << idindex.size() << "\n";
				warnx << "ID: sigs-per-id sigs-indices\n";
				int uniqueids = 0;
				for (chordID2sig::iterator itr = idindex.begin();
				     itr != idindex.end(); itr++) {
					uniqueids += itr->second.size();
					warnx << itr->first << ": " << itr->second.size();
					if (itr->second.size() > 1) {
						for (int i = 0; i < (int)itr->second.size(); i++) {
							warnx << " " << itr->second[i];
						}
						warnx << "\n";
					} else {
						warnx << " " << itr->second[0] << "\n";
					}

					// create a map for each chordID
					mapType groupbyid;
					//warnx << "groupbyid:\n";
					for (int i = 0; i < (int)itr->second.size(); i++) {
						mapType::iterator j = allT[0].begin();
						// point to the nth map element (random access)
						std::advance(j, itr->second[i]);
						assert(j != allT[0].end());
						//sig2str(j->first, sigbuf);
						//warnx << "sig: " << sigbuf;
						// copy freq and weight of sig
						groupbyid[j->first].push_back(j->second[0]);
						groupbyid[j->first].push_back(j->second[1]);
						//printdouble(" ", j->second[0]);
						//printdouble(" ", j->second[1]);
						//warnx << "\n";
					}
					groupedT.push_back(groupbyid);

				}
				warnx << "uniqueids: " << uniqueids << "\n";
				warnx << "groupedT.size(): " << groupedT.size() << "\n";

				if (gflag == 1) {
					warnx << "inserting XGOSSIPP:\n"
					      << "txseq: " << txseq.back() << "\n";

					chordID2sig::iterator itr = idindex.begin();
					for (int i = 0; i < (int)groupedT.size(); i++) {
						// end addresses the location succeeding the last element 
						// in a map (not the last element itself)
						if (itr == idindex.end()) {
							warnx << "idindex ended\n";
							break;
						}
						//warnx << "groupedT[" << i << "]:\n";
						//double freq, weight;
						//for (mapType::iterator jitr = groupedT[i].begin(); jitr != groupedT[i].end(); jitr++) {
							//sig = jitr->first;
							//freq = jitr->second[0];
							//weight = jitr->second[1];
							//sig2str(sig, sigbuf);
							//warnx << "sig: " << sigbuf;
							//printdouble(" ", freq);
							//printdouble(" ", weight);
							//warnx << "\n";
						//}
						ID = itr->first;
						strbuf z;
						z << ID;
						str key(z);
						warnx << "txID: " << ID << "\n";

						makeKeyValue(&value, valLen, key, groupedT[i], txseq.back(), XGOSSIPP);

						status = insertDHT(ID, value, valLen, MAXRETRIES);
						cleanup(value);

						// do not exit if insert FAILs!
						if (status != SUCC) {
							warnx << "error: insert FAILed\n";
							// to preserve mass conservation:
							// "send" msg to yourself
							doublefreqgroup(0, groupedT[i]);
						} else {
							warnx << "insert SUCCeeded\n";
						}

						++itr;

						warnx << "sleeping (groups)...\n";
						//sleep(initintval);
						groupsleep = 0;
						delaycb(initintval, 0, wrap(groupsleepnow));
						while (groupsleep == 0) acheck();
					}
					txseq.push_back(txseq.back() + 1);
					cmatrix.clear();
					// CLEAR ME!
					groupedT.clear();
					warnx << "sleeping (xgossip+)...\n";
					//sleep(gintval);
					gossipsleep = 0;
					delaycb(gintval, 0, wrap(gossipsleepnow));
					while (gossipsleep == 0) acheck();
				} else {
					return 0;
				}
				*/
a1400 2
		std::vector<std::vector<chordID> > cmatrix;
		cmatrix.clear();
d1406 1
a1406 2
			querychordID(cmatrix, initintval, QUERYX);
			cmatrix.clear();
d1409 1
a1409 2
			querychordID(cmatrix, initintval, QUERYS);
			cmatrix.clear();
d1422 1
d1427 1
a1427 1
			loadinitstate(initfp);
d1431 1
d1433 6
d1446 4
a1449 3
			for (int i = 0; i < (int)totalT.size(); i++) {
				printlist(totalT[i], 0, -1);
			}
d1700 1
a1700 1
// TODO: verify xgossip+ part
d1717 1
a1717 1
	int n, msglen, recvlen, nothing;
d1779 1
a1779 1
	if (msgtype == XGOSSIP || msgtype == XGOSSIPP) {
d1785 3
a1787 1
		} else if (msgtype == XGOSSIP) {
a1788 2
		} else {
			warnx << "XGOSSIPP";
d1805 1
a1805 1
		if (msgtype == XGOSSIPP) warnx << " teamID: " << keyteamid;
d1846 1
a1846 1
		if (msgtype == XGOSSIP) {
d1904 1
a1904 1
		warnx << "query result: ";
d1906 23
d1942 1
d1954 1
a1954 1
void
d2010 2
d2020 34
d2339 1
d2348 1
a2348 1
			//warnx << "teamID found in teamidminhash\n";
d2351 1
a2351 1
			//warnx << "teamID NOT found in teamidminhash\n";
d2357 15
d2532 1
a2532 1
// xgossip(+)
d2568 1
a2568 1
// vanilla gossip
d3240 1
a3240 1
printteamids()
d3242 1
a3242 1
	warnx << "printteamds:\n";
d3253 30
d3364 1
a3364 1
	warn << "Vanilla Gossip:\n";
d3366 1
a3366 1
	warn << "XGossip+:\n";
d3374 1
a3374 1
	     << "	-E		exec phase of XGossip+ (requires -H)\n"
d3379 1
a3379 1
	     << "	-I		init phase of XGossip+ (requires -H)\n"
d3386 1
a3386 1
					"\t\t\t(after XGossip+ init state is complete)\n"
d3393 1
a3393 1
					"\t\t\t(interval between inserts in XGossip+)\n"
d3398 1
a3398 1
					"\t\t\t(wait time after XGossip+ init phase is done)\n"
d3400 1
a3400 1
					"(multiply freq of sigs by)\n"
d3406 1
a3406 1
					"\t\t\t(XGossip+)\n"
@


1.72
log
@generalized freq multiplication and division (replaced doublefreq and splitfreq)
added ability to increase # of sigs by multiplying their freq (after calcfreq)
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.71 2011/03/25 17:14:12 vsfgd Exp vsfgd $	*/
d32 1
a32 1
static char rcsid[] = "$Id: gpsi.C,v 1.71 2011/03/25 17:14:12 vsfgd Exp vsfgd $";
d461 1
a461 1
			//warnx << "ID in randcol " << randcol << ": " << ID << "\n";
a2452 1
	// if last member of team, don't inform first (it already knows)
d2454 2
a2455 1
		warnx << "i am the last team member, not informing\n";
d2972 3
a2974 3
		tmpsig = citr[i]->first;
		sig2str(tmpsig, sigbuf);
		warnx << "1st dummy: " << sigbuf << "\n";
d2978 3
a2980 4
		/*
		tmpsig = citr[i]->first;
		sig2str(tmpsig, sigbuf);
		warnx << "2nd dummy: " << sigbuf << "\n";
a2981 1
		*/
d2999 2
a3000 2
			printdouble("new local dummy sumw/2: ", sumw/2);
			warnx << "\n";
d3002 1
a3002 1
			warnx << "mergelists: breaking from loop\n";
d3036 1
a3036 1
				warnx << "minsig found in T_" << i << "\n";
d3064 1
a3064 1
			warnx << "T_0: updating sums of minsig\n";
d3070 1
d3076 1
d3078 1
a3078 1
			warnx << "T_0: inserting minsig...\n";
@


1.71
log
@commented out debug msgs of mergelists
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.70 2011/03/25 15:49:30 vsfgd Exp vsfgd $	*/
d32 1
a32 1
static char rcsid[] = "$Id: gpsi.C,v 1.70 2011/03/25 15:49:30 vsfgd Exp vsfgd $";
d62 1
d101 1
a101 1
void doublefreq(vecomap&, int);
d113 1
a130 1
void splitfreq(vecomap&, int);
d719 1
a719 1
	while ((ch = getopt(argc, argv, "B:cD:d:EF:G:gHhIj:L:lMmn:P:pQq:R:rS:s:T:t:uvw:x:Z:z")) != -1)
d814 3
d1150 4
d1242 1
d1275 2
a1276 2
				// "send" msg to yourself
				doublefreq(totalT[0], 0);
d1458 2
a1459 1
							doublefreq(totalT[i], 0);
d2958 1
a2958 1
		splitfreq(teamvecomap, 0);
d3115 1
a3115 1
		splitfreq(allT, 0);
d3299 1
a3299 1
doublefreq(vecomap &teamvecomap, int listnum)
d3303 10
a3312 1
	for (mapType::iterator itr = teamvecomap[listnum].begin(); itr != teamvecomap[listnum].end(); itr++) {
d3314 1
a3314 1
		itr->second[0] = freq * 2;
d3316 1
a3316 1
		itr->second[1] = weight * 2;
d3318 1
a3318 1
	warnx << "doublefreq: setsize: " << teamvecomap[listnum].size() << "\n";
d3322 1
a3322 1
splitfreq(vecomap &teamvecomap, int listnum)
d3329 1
a3329 1
		itr->second[0] = freq / 2;
d3331 1
a3331 1
		itr->second[1] = weight / 2;
d3333 1
a3333 1
	warnx << "splitfreq: setsize: " << teamvecomap[listnum].size() << "\n";
d3499 3
@


1.70
log
@added list len in printlist header
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.69 2011/03/24 20:52:00 vsfgd Exp vsfgd $	*/
d32 1
a32 1
static char rcsid[] = "$Id: gpsi.C,v 1.69 2011/03/24 20:52:00 vsfgd Exp vsfgd $";
d3006 1
a3006 1
//#ifdef _DEBUG_
d3010 1
a3010 1
//#endif
d3018 1
a3018 1
//#ifdef _DEBUG_
d3021 1
a3021 1
//#endif
@


1.69
log
@fixed the rest of the allT -> totalT transitions in vanilla gossip
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.68 2011/03/23 01:08:43 vsfgd Exp vsfgd $	*/
d32 1
a32 1
static char rcsid[] = "$Id: gpsi.C,v 1.68 2011/03/23 01:08:43 vsfgd Exp vsfgd $";
d3380 1
a3380 1
	warnx << "list T_" << listnum << ": txseq: " << seq << "\n";
@


1.68
log
@renamed XGossip to Vanilla Gossip
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.67 2011/03/22 22:27:30 vsfgd Exp vsfgd $	*/
d32 1
a32 1
static char rcsid[] = "$Id: gpsi.C,v 1.67 2011/03/22 22:27:30 vsfgd Exp vsfgd $";
d73 1
d92 4
a95 1
void add2vecomap(std::vector<std::vector <POLY> >, std::vector<double>, std::vector<double>, chordID);
d1234 2
d1243 3
a1245 1
			mergelists(allT);
d1253 2
a1254 1
				printlist(allT, 0, txseq.back());
d1256 3
a1258 1
			makeKeyValue(&value, valLen, key, key, allT[0], txseq.back(), XGOSSIP);
d1267 2
a1268 1
				doublefreq(allT, 0);
d1999 5
a2003 2
		      << " rxID: " << key
		      << " teamID: " << keyteamid << "\n";
d2042 5
a2046 1
		add2vecomap(sigList, freqList, weightList, teamID);
d2652 1
d2654 1
a2654 1
add2vecomap(std::vector<std::vector<POLY> > sigList, std::vector<double> freqList, std::vector<double> weightList, chordID teamID)
d2688 18
d2966 3
a2968 1
		// skip 2nd dummy
d2973 1
@


1.67
log
@many xgossip changes
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.66 2010/12/11 01:42:38 vsfgd Exp vsfgd $	*/
d32 1
a32 1
static char rcsid[] = "$Id: gpsi.C,v 1.66 2010/12/11 01:42:38 vsfgd Exp vsfgd $";
d3404 1
a3404 1
	warn << "XGossip:\n";
@


1.66
log
@fix wording of usage()
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.65 2010/11/27 17:58:10 vsfgd Exp vsfgd $	*/
d32 1
a32 1
static char rcsid[] = "$Id: gpsi.C,v 1.65 2010/11/27 17:58:10 vsfgd Exp vsfgd $";
d45 2
a46 2
static const char* dsock;
static const char* gsock;
d61 1
d75 11
d91 1
a91 1
void add2vecomap(std::vector<std::vector <POLY> >, std::vector<double>, std::vector<double>);
d95 2
a96 1
void doublefreq(int);
d98 2
a99 2
void informteam(chordID, std::vector<POLY>);
void initgossiprecv(chordID, std::vector<POLY>, double, double);
d106 2
a107 2
void mergelists(void);
void mergelistsp(void);
d111 2
a112 1
void printlist(int, int);
d120 1
a120 1
bool string2sig(std::string, std::vector<POLY> &);
d122 5
a126 2
void splitfreq(int);
void tokenize(const std::string &, std::vector<std::string> &, const std::string &);
d376 1
a376 1
lshchordID(std::vector<std::vector<chordID> > &matrix, int intval = -1, InsertType msgtype = INVALID, int listnum = 0, int col = 0)
d379 1
d381 2
d387 1
a387 1
	int valLen;
d389 1
a389 1
	//str sigbuf;
d394 2
a395 1
	for (mapType::iterator itr = allT[listnum].begin(); itr != allT[listnum].end(); itr++) {
d400 6
a419 1
		/*
d421 3
a423 1
			warnx << "minhash IDs:\n";
a427 1
		*/
d429 3
d433 9
a441 1
		
d443 9
a451 1
			int range = (int)minhash.size();
d453 3
a455 2
			int randcol = randomNumGenZ(range-1);
			ID = (matrix.back())[randcol];
d457 19
a475 7
			strbuf t;
			t << ID;
			str key(t);
			warnx << "inserting " << msgtype << ":\n";
			makeKeyValue(&value, valLen, key, sig, freq, weight, msgtype);
			status = insertDHT(ID, value, valLen, MAXRETRIES);
			cleanup(value);
d477 7
a483 6
			// do not exit if insert FAILs!
			if (status != SUCC) {
				// TODO: do I care?
				warnx << "error: insert FAILed\n";
			} else {
				warnx << "insert SUCCeeded\n";
d485 9
d495 17
a511 3
			// TODO: how long (if at all)?
			//sleep(intval);
			warnx << "sleeping (lsh)...\n";
d513 5
a517 5
			initsleep = 0;
			delaycb(intval, 0, wrap(initsleepnow));
			while (initsleep == 0) acheck();
		}
		delete myLSH;
d519 4
d526 1
a526 1
// TODO: verify
d528 1
a528 1
lshpoly(std::vector<std::vector<POLY> > &matrix, int intval = -1, InsertType msgtype = INVALID, int listnum = 0, int col = 0)
d544 1
a544 1
	for (mapType::iterator itr = allT[listnum].begin(); itr != allT[listnum].end(); itr++) {
d563 1
d591 2
a592 1
			makeKeyValue(&value, valLen, key, sig, freq, weight, msgtype);
d655 2
a656 1
			makeKeyValue(&value, valLen, key, sig, freq, weight, msgtype);
d685 1
a685 1
	int ch, gintval, initintval, waitintval, nids, valLen, logfd;
d691 2
d710 3
d714 1
a714 1
	while ((ch = getopt(argc, argv, "B:cD:d:EF:G:gHhIj:L:lMmn:P:pQq:R:rS:s:T:t:uvw:x:z")) != -1)
d813 3
d847 1
a847 1
		std::vector<chordID> ids;
a851 3
			//t << ID;
			//str tmpkey(t);
			//warnx << tmpkey << "\n";
d853 1
a853 3
			ids.push_back(ID);
			//warnx << "successorID: " << successorID(ID, 0) << "\n";
			//sleep(5);
d855 1
a855 1
		sort(ids.begin(), ids.end());
d857 7
a863 2
		for (int i = 0; i < (int)ids.size(); i++) {
			warnx << "ID: " << ids[i] << "\n";
d1053 2
a1054 1
			for (int i = 0; i < lfuncs; i++) {
d1079 1
d1087 1
a1087 1
					if (z <= lfuncs)
d1093 1
a1093 1
				assert((int)hasha.size() == lfuncs);
a1128 2
			dummysig.clear();
			dummysig.push_back(1);
d1137 1
d1139 3
d1143 2
a1144 1
			printlist(0, -1);
d1188 1
a1188 1
			lshpoly(pmatrix, initintval, INITGOSSIP);
d1192 1
a1192 1
			lshchordID(cmatrix, initintval, INITGOSSIP);
d1213 3
a1215 1
				printlist(0, -1);
a1235 3
			//std::vector<POLY> sig;
			//sig.clear();

d1237 1
a1237 1
			mergelists();
d1245 1
a1245 1
				printlist(0, txseq.back());
d1247 1
a1247 1
			makeKeyValue(&value, valLen, key, allT[0], txseq.back(), XGOSSIP);
d1256 1
a1256 1
				doublefreq(0);
d1273 16
a1288 1
				printlist(0, -1);
d1304 1
a1304 1
		vecomap groupedT;
d1310 5
a1314 1
			mergelistsp();
d1318 1
a1318 1
			delspecial(0);
d1320 15
a1334 1
				printlist(0, txseq.back());
d1339 1
a1339 1
			int range = mgroups;
d1342 1
a1342 1
			int randcol = randomNumGenZ(range-1);
d1345 2
d1364 1
d1367 2
a1368 13
				warnx << "running lshchordID...\n";
				beginTime = getgtod();    
				//lshchordID(cmatrix, -1, INVALID, 0, randcol);
				lshchordID(cmatrix);
				endTime = getgtod();    
				printdouble("lshchordID time: ", endTime - beginTime);
				warnx << "\n";
				chordID2sig idindex;
				warnx << "cmatrix.size(): " << cmatrix.size() << "\n";
				warnx << "cmatrix[0].size(): " << cmatrix[0].size() << "\n";
				warnx << "IDs in random column " << randcol << ":\n";
				//col = 0;
				for (int i = 0; i < (int)cmatrix.size(); i++) {
d1370 6
a1375 3
					for (int j = 0; j < (int)cmatrix[i].size(); j++) {
						warnx << cmatrix[i][j] << " ";
					}
d1377 4
a1380 1
					warnx << cmatrix[i][randcol] << "\n";
d1382 88
d1473 4
a1476 5
					/*
					chordID2sig::iterator itr = idindex.find(matrix[i][randcol]);
					if (itr != idindex.end()) {
						itr->second[0] += 1;
					} else {
d1478 2
a1479 3
						idindex[matrix[i][randcol]].push_back(i);
					}
					*/
d1533 12
a1544 14
						/*
						warnx << "groupedT[" << i << "]:\n";
						double freq, weight;
						for (mapType::iterator jitr = groupedT[i].begin(); jitr != groupedT[i].end(); jitr++) {
							sig = jitr->first;
							freq = jitr->second[0];
							weight = jitr->second[1];
							sig2str(sig, sigbuf);
							warnx << "sig: " << sigbuf;
							printdouble(" ", freq);
							printdouble(" ", weight);
							warnx << "\n";
						}
						*/
d1586 1
d1623 4
a1626 1
		mergelistsp();
d1631 3
a1633 1
			printlist(0, -1);
d1891 1
d1894 1
d1975 1
a1975 1
		ret = getKeyValue(gmsg.cstr(), key, sigList, freqList, weightList, seq, recvlen);
d1987 2
a1988 1
		      << " rxID: " << key << "\n";
d2026 2
a2027 1
		add2vecomap(sigList, freqList, weightList);
d2041 1
a2041 1
		ret = getKeyValue(gmsg.cstr(), key, sig, freq, weight, recvlen);
d2051 1
d2058 2
a2059 1
		initgossiprecv(ID, sig, freq, weight);
d2068 1
a2068 1
		ret = getKeyValue(gmsg.cstr(), key, sig, freq, weight, recvlen);
d2078 1
d2111 2
d2116 2
d2123 2
d2131 21
d2158 2
d2162 1
a2162 3

	warnx << "before loadinitstate allT.size(): " << allT.size() << "\n";
	allT.push_back(uniqueSigList);
d2175 25
a2199 8
	for (mapType::iterator itr = allT[listnum].begin(); itr != allT[listnum].end(); itr++) {
		sig = itr->first;
		freq = itr->second[0];
		weight = itr->second[1];
		sig2str(sig, sigbuf);
		fprintf(initfp, "%s:", sigbuf.cstr());
		fprintf(initfp, "%f:", freq);
		fprintf(initfp, "%f\n", weight);
d2216 1
d2314 1
a2314 1
	warnx << "Document signature: ";
d2321 1
a2326 11
	/*
	// isig test
	str sigbuf;
	std::vector<POLY> isig;
	isig.clear();
	isig = inverse(sig);
	sig2str(isig, sigbuf);
	sigList.push_back(isig);
	warnx << "isig: " << sigbuf << "\n";
	*/

d2334 1
a2334 1
initgossiprecv(chordID ID, std::vector<POLY> sig, double freq, double weight)
d2336 41
a2376 2
	std::vector<POLY> isig;
	//str sigbuf;
d2378 2
a2379 9
	isig.clear();
	isig = inverse(sig);
	//sig2str(isig, sigbuf);
	//warnx << "isig: " << sigbuf << "\n";

	mapType::iterator itr = allT[0].find(sig);
	mapType::iterator iitr = allT[0].find(isig);
	// s is regular and exists
	if ((sig[0] != 0) && (itr != allT[0].end())) {
d2381 14
a2394 11
		itr->second[0] += freq;
	// s is regular and s' exists
	} else if ((sig[0] != 0) && (iitr != allT[0].end())) {
		warnx << "initgossiprecv: delete special multiset tuple\n";
		// TODO: inefficient?
		allT[0].erase(iitr);
		allT[0][sig].push_back(freq);
		allT[0][sig].push_back(weight);
	// s and s' exist (s is special)
	} else if ((itr != allT[0].end()) && (iitr != allT[0].end())) {
		warnx << "initgossiprecv: do nothing\n";
d2396 8
a2403 5
		warnx << "initgossiprecv: inserting sig\n";
		allT[0][sig].push_back(freq);
		allT[0][sig].push_back(weight);
		warnx << "initgossiprecv: inform team\n";
		informteam(ID, sig);
d2409 1
a2409 1
informteam(chordID myID, std::vector<POLY> sig)
d2411 2
a2413 4
	std::vector<chordID> minhash;
	std::vector<POLY> isig;
	std::vector<POLY> lshsig;
	DHTStatus status;
d2416 1
a2416 1
	//str sigbuf;
d2418 11
a2428 29
	minhash.clear();
	isig.clear();
	lshsig.clear();
	lsh *myLSH = new lsh(sig.size(), lfuncs, mgroups, lshseed, 0, irrnums, hasha, hashb);
	// TODO: verify getUniqueSet works right
	if (uflag == 1) {
		lshsig = myLSH->getUniqueSet(sig);
		// TODO: findMod vs compute_hash!
		minhash = myLSH->getHashCode(lshsig);
	} else {
		minhash = myLSH->getHashCode(sig);
	}

	// is sig always a regular multiset?
	isig = inverse(sig);
	//sig2str(isig, sigbuf);
	//warnx << "informteam: isig: " << sigbuf << "\n";

	// O(n logn)
	sort(minhash.begin(), minhash.end());
	//for (int i = 0; i < (int)minhash.size(); i++) {
	//	warnx << "minhash[" << i << "]: "<< minhash[i] << "\n";
	//}

	// TODO: verify
	nextID = myID;
	if (myID == minhash.back()) {
		warnx << "warning: myID is last, using first\n";
		nextID = minhash.front();
d2430 2
a2431 6
		for (int i = 0; i < (int)minhash.size(); i++) {
			if (myID < minhash[i]) {
				nextID = minhash[i];
				break;
			}
		}
d2437 3
d2442 1
a2442 3
	makeKeyValue(&value, valLen, key, isig, freq, weight, INFORMTEAM);
	// or strlen?
	//ID = compute_hash(value, sizeof(value));
d2444 1
a2444 1
	warnx << "myID: " << myID << " nextID: " << nextID << "\n";
d2454 55
d2510 1
a2510 1
	delete myLSH;
d2513 1
a2513 1
// TODO: make more efficient? in-place instead?
d2538 1
a2538 1
tokenize(const std::string& str, std::vector<std::string>& tokens, const std::string& delimiters = " ")
d2585 1
a2613 1
// verified
a2632 1
// verified
d2634 1
a2634 1
add2vecomap(std::vector<std::vector<POLY> > sigList, std::vector<double> freqList, std::vector<double> weightList)
d2636 1
d2638 3
d2646 20
a2665 2
	allT.push_back(uniqueSigList);
	warnx << "add2vecomap: allT.size(): " << allT.size() << "\n";
a2672 17
	std::vector<POLY> isig1, isig2;

	// if both special, treat them as regular
	if (s1[0] == 0 && s2[0] == 0) {
		isig1.clear();
		isig2.clear();
		isig1 = inverse(s1);
		isig2 = inverse(s2);
		s1 = isig1;
		s2 = isig2;
	// special multisets are greater than any regular multiset
	} else if (s1[0] == 0 && s2[0] != 0) {
		return false;
	} else if (s1[0] != 0 && s2[0] == 0) {
		return true;
	}

d2688 208
a2895 1
// verified
d2897 1
a2897 1
mergelists()
d2902 1
d2906 3
a2908 2
	int n = allT.size();
	warnx << "initial allT.size(): " << n << "\n";
d2910 1
a2910 1
		splitfreq(0);
d2915 1
a2915 1
			printlist(i, -1);
d2922 1
a2922 1
		citr.push_back(allT[i].begin());
d2924 8
d2939 1
a2939 1
			if (citr[i] == allT[i].end()) {
d2948 1
a2948 1
				sumw += allT[i][dummysig][1];
d2952 2
a2953 1
			allT[0][dummysig][1] = sumw / 2;
d2961 1
a2961 1
			if (citr[i] == allT[i].end()) {
d2965 1
a2965 1
#ifdef _DEBUG_
d2969 1
a2969 1
#endif
d2977 1
a2977 1
#ifdef _DEBUG_
d2980 1
a2980 1
#endif
d2985 3
a2987 3
			// TODO: verify
			if ((citr[i] != allT[i].end()) && (citr[i]->first == minsig)) {
				//warnx << "minsig found in T_" << i << "\n";
d2995 1
a2995 1
				if (citr[i] == allT[i].end()) {
d3000 2
a3001 2
				sumf += allT[i][dummysig][0];
				sumw += allT[i][dummysig][1];
d3011 3
a3013 2
		// update allT[0]
		if (citr[0]->first == minsig) {
d3015 3
a3017 3
			//warnx << "updating sums of minsig\n";
			allT[0][minsig][0] = sumf/2;
			allT[0][minsig][1] = sumw/2;
d3021 5
d3027 3
a3029 3
			//warnx << "inserting minsig...\n";
			allT[0][minsig].push_back(sumf/2);
			allT[0][minsig].push_back(sumw/2);
d3034 1
a3034 1
			//citr[0] = allT[0].find(minsig);
d3041 6
a3046 2
	while (allT.size() > 1) allT.pop_back();
	//warnx << "allT.size() after pop: " << allT.size() << "\n";
d3049 1
a3049 1
// TODO: verify
d3051 1
a3051 1
mergelistsp()
d3064 1
a3064 1
		splitfreq(0);
d3229 1
a3229 1
// TODO: verify
a3246 1
// verified
d3248 1
a3248 1
doublefreq(int listnum)
d3252 1
a3252 1
	for (mapType::iterator itr = allT[listnum].begin(); itr != allT[listnum].end(); itr++) {
d3258 1
a3258 1
	warnx << "doublefreq: setsize: " << allT[listnum].size() << "\n";
a3260 1
// verified
d3262 1
a3262 1
splitfreq(int listnum)
d3266 1
a3266 1
	for (mapType::iterator itr = allT[listnum].begin(); itr != allT[listnum].end(); itr++) {
d3273 1
a3273 1
	warnx << "splitfreq: setsize: " << allT[listnum].size() << "\n";
d3276 1
a3276 1
// verified
a3308 1
// verified
d3310 14
a3323 1
printlist(int listnum, int seq)
d3325 2
a3326 1
	int n, nsig, nisig;
d3328 2
a3329 2
	double sumavg = 0;
	double sumsum = 0;
d3331 3
a3333 2
	//sig.clear();
	//std::vector<POLY> isig;
d3336 6
a3341 4
	n = nsig = nisig = 0;
	warnx << "list T_" << listnum << ": " << seq << " " << allT[listnum].size() << "\n";
	warnx << "hdrB: freq weight avg avg*n:peers avg*q:mgroups\n";
	for (mapType::iterator itr = allT[listnum].begin(); itr != allT[listnum].end(); itr++) {
a3347 6

		if (sig[0] == 0)
			++nisig;
		else
			++nsig;

d3355 16
a3370 1
		warnx << "\n";
d3372 1
d3374 1
a3374 1
	warnx << "hdrE: freq weight avg avg*n:peers avg*q:mgroups\n";
d3377 12
a3388 3
	warnx << " setsize: " << allT[listnum].size();
	warnx << " setsig: " << nsig;
	warnx << " setisig: " << nisig << "\n";
d3401 1
a3401 3
	warn << "\t" << __progname << " -H -E -s sigdir -F hashfile -d 1122941 -j irrpoly-deg9.dat -B 10 -R 16 -u\n\n";
	warn << "LSH on init file:\n";
	warn << "\t" << __progname << " -H -E -P initfile -F hashfile -d 1122941 -j irrpoly-deg9.dat -B 10 -R 16 -u\n\n";
d3438 2
a3439 1
					"\t\t\t(wait time after XGossip+ init phase is done)\n\n"
d3444 1
@


1.65
log
@don't modify sig when converting from multiset to set
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.64 2010/11/24 17:11:25 vsfgd Exp vsfgd $	*/
d32 1
a32 1
static char rcsid[] = "$Id: gpsi.C,v 1.64 2010/11/24 17:11:25 vsfgd Exp vsfgd $";
d2830 1
a2830 1
	     << "      	-q		<estimate of # of peers in DHT>\n"
d2835 1
a2835 1
					"\t\t\t(init interval)\n"
d2837 1
a2837 1
					"\t\t\t(gossip interval in exec phase)\n"
d2840 1
a2840 1
					"\t\t\t(wait interval after init phase is done)\n\n"
d2842 1
a2842 1
	     << "	-g		gossip (requires -S, -G, -s, -i)\n"
@


1.64
log
@don't create a new hash.dat when querying
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.63 2010/11/12 19:59:16 vsfgd Exp vsfgd $	*/
d32 1
a32 1
static char rcsid[] = "$Id: gpsi.C,v 1.63 2010/11/12 19:59:16 vsfgd Exp vsfgd $";
d63 4
a66 2
int lfuncs = 5;
int mgroups = 100;
d275 1
d283 2
d295 2
a296 2
			myLSH->getUniqueSet(sig);
			sig2str(sig, sigbuf);
d304 1
d306 1
a306 1
			polyhash = myLSH->getHashCodeFindMod(sig, myLSH->getIRRPoly());
d308 1
a308 1
			idhash = myLSH->getHashCode(sig);
d363 1
d371 1
d373 1
d384 2
a385 2
			myLSH->getUniqueSet(sig);
			//sig2str(sig, sigbuf);
d387 3
a391 2
		minhash = myLSH->getHashCode(sig);

d445 1
d454 3
d467 2
a468 2
			myLSH->getUniqueSet(sig);
			//sig2str(sig, sigbuf);
d470 3
a474 2
		minhash = myLSH->getHashCodeFindMod(sig, myLSH->getIRRPoly());

d530 1
d537 1
d539 1
d548 4
a551 1
			myLSH->getUniqueSet(sig);
a553 1
		minhash = myLSH->getHashCode(sig);
d2109 1
d2111 1
d2117 3
d2122 7
a2128 6
	//warnx << "informteam: getUniqueSet\n";
	// TODO: check uflag?
	myLSH->getUniqueSet(sig);
	//warnx << "informteam: getHashCode\n";
	// TODO: findMod vs compute_hash!
	std::vector<chordID> minhash = myLSH->getHashCode(sig);
a2129 1
	isig.clear();
d2759 1
a2759 1
	warnx << "hdrB: freq weight avg avg*p\n";
d2779 1
d2783 1
a2783 1
	warnx << "hdrE: freq weight avg avg*p\n";
@


1.63
log
@added signature-based querying
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.62 2010/10/18 04:43:52 vsfgd Exp vsfgd $	*/
d32 1
a32 1
static char rcsid[] = "$Id: gpsi.C,v 1.62 2010/10/18 04:43:52 vsfgd Exp vsfgd $";
d917 3
a919 1
		if (Iflag == 1 || gflag == 0) {
@


1.62
log
@load irrpolyfile and hashfile contents in memory (don't read the files on every lsh object creation)
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.61 2010/10/11 16:05:32 vsfgd Exp vsfgd $	*/
d32 1
a32 1
static char rcsid[] = "$Id: gpsi.C,v 1.61 2010/10/11 16:05:32 vsfgd Exp vsfgd $";
d51 1
d100 1
d508 62
d574 1
a574 1
	int Gflag, Lflag, lflag, rflag, Sflag, sflag, zflag, vflag, Hflag, dflag, jflag, mflag, Iflag, Eflag, Pflag, Dflag, Mflag, Fflag;
d590 1
a590 1
	Gflag = Lflag = lflag = rflag = Sflag = sflag = zflag = vflag = Hflag = dflag = jflag = mflag = Eflag = Iflag = Pflag = Dflag = Mflag = Fflag = 0;
d599 1
a599 1
	while ((ch = getopt(argc, argv, "B:cD:d:EF:G:gHhIj:L:lMmn:P:pq:R:rS:s:T:t:uvw:z")) != -1)
d671 3
d694 4
d751 2
a752 2
	// read, gossip, LSH or listen
	if (rflag == 0 && gflag == 0 && lflag == 0 && Hflag == 0 && Mflag == 0) usage();
d757 6
d769 1
a769 1
	if (Hflag == 1 && (dflag == 0 || jflag == 0)) usage();
d801 112
d993 1
a993 1
	if (gflag == 1 || lflag == 1) {
d999 1
a999 1
	if ((rflag == 1 || gflag == 1 || Hflag == 1 || lflag == 1) && sflag == 1) {
d1005 2
a1006 1
		if (Hflag == 0) {
d1022 2
a1023 1
		// create log.init of sigs
d1029 1
d1349 19
a1367 3
	} else if (rflag == 1) {
		return 0;
	} else if (Hflag == 1) {
d1391 5
d1529 38
d1652 2
a1790 2
		double freq, weight;
		std::vector<POLY> sig;
d1809 35
d2096 1
d2768 4
d2815 1
a2815 1
	     << "	-H		generate chordIDs/POLYs using LSH (requires  -s, -d, -j)\n"
d2819 1
@


1.61
log
@save hash funcs to file
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.60 2010/09/21 05:09:20 vsfgd Exp vsfgd $	*/
d9 1
d32 1
a32 1
static char rcsid[] = "$Id: gpsi.C,v 1.60 2010/09/21 05:09:20 vsfgd Exp vsfgd $";
d51 3
d283 1
a283 1
		lsh *myLSH = new lsh(sig.size(), lfuncs, mgroups, lshseed, 0, irrpolyfile, hashfile);
d368 1
a368 1
		lsh *myLSH = new lsh(sig.size(), lfuncs, mgroups, lshseed, col, irrpolyfile, hashfile);
d446 1
a446 1
		lsh *myLSH = new lsh(sig.size(), lfuncs, mgroups, lshseed, col, irrpolyfile, hashfile);
d726 1
a726 3
		// init phase
		if (Iflag == 1)
			acc = "w+";
d728 1
a728 1
		else if (gflag == 0)
d730 3
a732 3
		// exec phase
		else
			acc = "r";
d734 22
a755 3
		if ((hashfp = fopen(hashfile, acc.c_str())) == NULL) {
			fatal << "can't open hash file " << hashfile << "\n";
		}
d757 30
a786 18
		int random_integer_a;
		int random_integer_b;
		int lowest_a = 1, highest_a = -9;
		int lowest_b = 0, highest_b = -9;
		highest_a = highest_b = lshseed;
		int range_a = (highest_a - lowest_a) + 1;
		int range_b = (highest_b - lowest_b) + 1;
		std::vector<int> randa;
		std::vector<int> randb;
		randa.clear();
		randb.clear();
		srand(lshseed);
		for (int i = 0; i < lfuncs; i++) {
			// TODO: verify randomness
			random_integer_a  = lowest_a + int((double)range_a*rand()/(RAND_MAX + 1.0));
			random_integer_b  = lowest_b + int((double)range_b*rand()/(RAND_MAX + 1.0));
			randa.push_back(random_integer_a);
			randb.push_back(random_integer_b);
a787 9

		for (int i = 0; i < (int)randa.size(); i++) {
			fprintf(hashfp, "%d\n", randa[i]);
		}

		for (int i = 0; i < (int)randb.size(); i++) {
			fprintf(hashfp, "%d\n", randb[i]);
		}
		fclose(hashfp);
d793 9
d1807 1
a1807 1
	lsh *myLSH = new lsh(sig.size(), lfuncs, mgroups, lshseed, 0, irrpolyfile, hashfile);
d2482 1
a2482 1
	warn << "\t" << __progname << " -H -E -s sigdir -F hashfile -d 1122941 -j irrpoly-deg9.dat -B 10 -R 16\n\n";
d2484 1
a2484 1
	warn << "\t" << __progname << " -H -E -P initfile -F hashfile -d 1122941 -j irrpoly-deg9.dat -B 10 -R 16\n\n";
@


1.60
log
@added action for testing mergelistsp
fixed mergelistsp? (check for end of list before comparing with minsing)
(no more seg faults!)
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.59 2010/09/19 23:54:15 vsfgd Exp vsfgd $	*/
d31 1
a31 1
static char rcsid[] = "$Id: gpsi.C,v 1.59 2010/09/19 23:54:15 vsfgd Exp vsfgd $";
d46 1
a46 1
static char *logfile;
d49 1
d279 1
a279 1
		lsh *myLSH = new lsh(sig.size(), lfuncs, mgroups, lshseed, 0, irrpolyfile);
d364 1
a364 1
		lsh *myLSH = new lsh(sig.size(), lfuncs, mgroups, lshseed, col, irrpolyfile);
d391 3
a393 3
			int col = randomNumGenZ(range-1);
			ID = (matrix.back())[col];
			//warnx << "ID in col " << col << ": " << ID << "\n";
d442 1
a442 1
		lsh *myLSH = new lsh(sig.size(), lfuncs, mgroups, lshseed, col, irrpolyfile);
d467 3
a469 3
		int col = randomNumGenZ(range-1);
		mypoly = (matrix.back())[col];
		warnx << "POLY in col " << col << ": " << mypoly << "\n";
d506 1
a506 1
	int Gflag, Lflag, lflag, rflag, Sflag, sflag, zflag, vflag, Hflag, dflag, jflag, mflag, Iflag, Eflag, Pflag, Dflag, Mflag;
d522 1
a522 1
	Gflag = Lflag = lflag = rflag = Sflag = sflag = zflag = vflag = Hflag = dflag = jflag = mflag = Eflag = Iflag = Pflag = Dflag = Mflag = 0;
a525 1
	//irrpolyfile = initfile = logfile = NULL;
d531 1
a531 1
	while ((ch = getopt(argc, argv, "B:cD:d:EG:gHhIj:L:lMmn:P:pq:R:rS:s:T:t:uvw:z")) != -1)
d553 4
d691 1
a691 1
	// TODO: handle sflag & Pflag
d710 13
d725 4
d732 30
a761 2
		if ((initfp = fopen(initfile, acc.c_str())) == NULL) {
			fatal << "can't open init file" << initfile << "\n";
d763 1
d798 7
d958 1
a958 1
			//int col = int((double)range * rand() / (RAND_MAX + 1.0));
d960 1
a960 1
			int col = randomNumGenZ(range-1);
d964 1
a964 1
				//lshpoly(0, pmatrix, 0, -1, col);
d968 1
a968 1
				warnx << "POLYs in random column " << col << ":\n";
d970 1
a970 1
					warnx << pmatrix[i][col] << "\n";;
d972 1
a972 1
					polyindex[pmatrix[i][col]].push_back(i);
d984 1
d991 3
a993 2
				//warnx << "IDs in random column " << col << ":\n";
				col = 0;
d995 7
a1001 5
					//for (int j = 0; j < (int)cmatrix[i].size(); j++) {
					//	warnx << cmatrix[i][j] << " ";
					//}
					//warnx << "\n";
					//warnx << cmatrix[i][col] << "\n";
d1003 2
a1004 1
					idindex[cmatrix[i][col]].push_back(i);
d1006 1
a1006 1
					chordID2sig::iterator itr = idindex.find(matrix[i][col]);
d1011 1
a1011 1
						idindex[matrix[i][col]].push_back(i);
d1774 1
a1774 1
	lsh *myLSH = new lsh(sig.size(), lfuncs, mgroups, lshseed, 0, irrpolyfile);
d2448 6
d2465 1
d2468 1
a2468 1
					"\t\t\t(requires -g, -s, -d, -j, -I -w)\n"
@


1.59
log
@replaced the last sleep (for groups) with delaycb
removed sleep after starting to listen
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.58 2010/09/18 21:43:56 vsfgd Exp vsfgd $	*/
d31 1
a31 1
static char rcsid[] = "$Id: gpsi.C,v 1.58 2010/09/18 21:43:56 vsfgd Exp vsfgd $";
d505 1
a505 1
	int Gflag, Lflag, lflag, rflag, Sflag, sflag, zflag, vflag, Hflag, dflag, jflag, mflag, Iflag, Eflag, Pflag;
d514 1
d516 1
d521 1
a521 1
	Gflag = Lflag = lflag = rflag = Sflag = sflag = zflag = vflag = Hflag = dflag = jflag = mflag = Eflag = Iflag = Pflag = 0;
d531 1
a531 1
	while ((ch = getopt(argc, argv, "B:cd:EG:gHhIj:L:lmn:P:pq:R:rS:s:T:t:uvw:z")) != -1)
d542 4
d583 3
d673 1
a673 1
	if (rflag == 0 && gflag == 0 && lflag == 0 && Hflag == 0) usage();
d681 2
d684 1
a684 2
	if (Hflag == 1 && (dflag == 0 || jflag == 0))
		usage();
d1066 22
d1511 1
d2019 2
a2020 1
			if (citr[i]->first == minsig) {
d2092 2
a2093 2
		for (int i = 0; i < n; i++)
			printlist(i, -1);
d2126 1
d2142 1
a2142 1
			} else if (z == 0){
d2152 1
d2169 1
a2169 1
			if (citr[i]->first == minsig) {
a2174 1
			// TODO: do not check if at end of list?
d2250 1
a2250 1
	//warnx << "allT.size() after pop: " << allT.size() << "\n";
a2392 1
	     << "	-R		rows for LSH (a.k.a. l hash functions)\n"
d2394 2
a2396 1
	     << "	-I		init phase of XGossip+ (requires -H)\n"
a2397 1
	     << "	-S		<dhash socket>\n"
d2400 1
a2400 1
	     << "	-d		<random prime number for LSH seed>\n"
a2404 1
	     << "	-u		make POLYs unique (convert multiset to set)\n"
d2410 2
d2417 1
d2425 1
@


1.58
log
@clear groupedT!
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.57 2010/09/17 01:54:01 vsfgd Exp vsfgd $	*/
d31 1
a31 1
static char rcsid[] = "$Id: gpsi.C,v 1.57 2010/09/17 01:54:01 vsfgd Exp vsfgd $";
d36 1
d143 7
d756 1
a756 1
		sleep(5);
d1033 4
a1036 1
						sleep(initintval);
@


1.57
log
@reorder default parameters of lshchordID and lshpoly
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.56 2010/09/15 00:35:20 vsfgd Exp vsfgd $	*/
d31 1
a31 1
static char rcsid[] = "$Id: gpsi.C,v 1.56 2010/09/15 00:35:20 vsfgd Exp vsfgd $";
a908 2
				// don't send anything
				//lshchordID(0, cmatrix, 0, -1, col);
d918 5
a922 1
					//warnx << cmatrix[i][col] << "\n";;
d1028 3
a1031 1
					cmatrix.clear();
d1982 1
d1988 1
d2110 1
d2117 1
d2130 1
d2133 1
d2138 1
d2140 1
@


1.56
log
@fixed lsh
test lsh locally
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.55 2010/07/19 14:29:14 vsfgd Exp vsfgd $	*/
d31 1
a31 1
static char rcsid[] = "$Id: gpsi.C,v 1.55 2010/07/19 14:29:14 vsfgd Exp vsfgd $";
d338 1
a338 1
lshchordID(int listnum, std::vector<std::vector<chordID> > &matrix, unsigned int loseed = 0, int intval = -1, int col = 0, InsertType msgtype = INVALID)
d416 1
a416 1
lshpoly(int listnum, std::vector<std::vector<POLY> > &matrix, unsigned int loseed = 0, int intval = 0, int col = 0, InsertType msgtype = INVALID)
d763 1
a763 1
			lshpoly(0, pmatrix, loseed, initintval, INITGOSSIP);
d767 1
a767 1
			lshchordID(0, cmatrix, loseed, initintval, INITGOSSIP);
d890 1
a890 1
				lshpoly(0, pmatrix);
d911 1
a911 1
				lshchordID(0, cmatrix);
@


1.55
log
@replaced sleep() with delaycb() for xgossip
(and all other instances of sleep)
fixed mergelists to not check for end of list
fixed mergelistsp to not check for end of list
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.54 2010/07/16 17:50:15 vsfgd Exp vsfgd $	*/
d31 1
a31 1
static char rcsid[] = "$Id: gpsi.C,v 1.54 2010/07/16 17:50:15 vsfgd Exp vsfgd $";
a55 1
// TODO: command line args?
d270 1
a270 1
		lsh *myLSH = new lsh(sig.size(), lfuncs, mgroups, lshseed, irrpolyfile);
d338 1
a338 1
lshchordID(int listnum, std::vector<std::vector<chordID> > &matrix, unsigned int loseed = 0, int intval = -1, InsertType msgtype = INVALID)
d355 1
a355 1
		lsh *myLSH = new lsh(sig.size(), lfuncs, mgroups, lshseed, irrpolyfile);
d367 1
a368 1
		warnx << "minhash.size(): " << minhash.size() << "\n";
d378 1
a378 6
		int range = (int)minhash.size();
		// randomness verified
		int col = randomNumGenZ(range-1);
		ID = (matrix.back())[col];
		warnx << "ID in col " << col << ": " << ID << "\n";

d380 5
d416 1
a416 1
lshpoly(int listnum, std::vector<std::vector<POLY> > &matrix, unsigned int loseed = 0, int intval = 0, InsertType msgtype = INVALID)
d433 1
a433 1
		lsh *myLSH = new lsh(sig.size(), lfuncs, mgroups, lshseed, irrpolyfile);
a483 2
			// TODO: how long (if at all)?
			//sleep(intval);
a484 1

d844 1
a844 1
	} else if (gflag == 1 && Hflag == 1 && Eflag == 1) {
d846 1
a846 1
			warnx << "loading init state from file...\n";
d848 5
a852 1
			printlist(0, -1);
d854 1
a854 1
			fatal << "no init state available\n";
d856 1
a856 1
			warnx << "using state from init phase\n";
d889 1
d907 2
d910 1
d912 3
d917 2
a918 1
				warnx << "IDs in random column " << col << ":\n";
d947 1
a947 1
					      warnx << " " << itr->second[0] << "\n";
d973 48
a1020 2
				warnx << "inserting XGOSSIPP:\n"
				      << "txseq: " << txseq.back() << "\n";
d1022 2
a1023 43
				chordID2sig::iterator itr = idindex.begin();
				for (int i = 0; i < (int)groupedT.size(); i++) {
					// end addresses the location succeeding the last element 
					// in a map (not the last element itself)
					if (itr == idindex.end()) {
						warnx << "idindex ended\n";
						break;
					}
					/*
					warnx << "groupedT[" << i << "]:\n";
					double freq, weight;
					for (mapType::iterator jitr = groupedT[i].begin(); jitr != groupedT[i].end(); jitr++) {
						sig = jitr->first;
						freq = jitr->second[0];
						weight = jitr->second[1];
						sig2str(sig, sigbuf);
						warnx << "sig: " << sigbuf;
						printdouble(" ", freq);
						printdouble(" ", weight);
						warnx << "\n";
					}
					*/
					ID = itr->first;
					strbuf z;
					z << ID;
					str key(z);
					warnx << "txID: " << ID << "\n";

					// TODO: same round for each group?
					makeKeyValue(&value, valLen, key, groupedT[i], txseq.back(), XGOSSIPP);

					status = insertDHT(ID, value, valLen, MAXRETRIES);
					cleanup(value);

					// do not exit if insert FAILs!
					if (status != SUCC) {
						warnx << "error: insert FAILed\n";
						// to preserve mass conservation:
						// "send" msg to yourself
						// TODO: needed?
						doublefreqgroup(0, groupedT[i]);
					} else {
						warnx << "insert SUCCeeded\n";
d1025 9
a1033 6

					++itr;

					warnx << "sleeping (groups)...\n";
					// TODO: needed?
					sleep(initintval);
a1034 7
				txseq.push_back(txseq.back() + 1);
				warnx << "sleeping (xgossip+)...\n";
				cmatrix.clear();
				//sleep(gintval);
				gossipsleep = 0;
				delaycb(gintval, 0, wrap(gossipsleepnow));
				while (gossipsleep == 0) acheck();
d1454 1
a1454 1
	warnx << "allT.size(): " << allT.size() << "\n";
a1537 1
	// TODO: move to main
d1664 1
a1664 1
	lsh *myLSH = new lsh(sig.size(), lfuncs, mgroups, lshseed, irrpolyfile);
a1970 12
			// TODO: combine 1st and 3rd cases
			// DO NOT skip lists which are done:
			// use their dummy
			/*
			if (citr[i] == allT[i].end()) {
				//warnx << "no minsig in T_" << i
				//      << " (list ended)\n";
				sumf += allT[i][dummysig][0];
				sumw += allT[i][dummysig][1];
				//continue;
			} else if (citr[i]->first == minsig) {
			*/
@


1.54
log
@discard nothing reads
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.53 2010/07/15 06:37:58 vsfgd Exp vsfgd $	*/
d31 1
a31 1
static char rcsid[] = "$Id: gpsi.C,v 1.53 2010/07/15 06:37:58 vsfgd Exp vsfgd $";
d38 1
d156 7
d403 1
a404 1
			//sleep(intval);
a408 1

d486 1
d488 4
a491 1
			sleep(intval);
d842 4
a845 1
			sleep(gintval);
d1022 4
a1025 1
				sleep(gintval);
d1250 1
a1250 1
	int n, msglen, recvlen; 
d1253 1
a1253 1
	msglen = recvlen = 0;
d1269 1
a1271 2
			close(fd);
			++closefd;
d1273 11
d1296 2
a1297 2
		warnx << "\nreadgossip: n: " << n << "\n";
		warnx << "readgossip: recvlen: " << recvlen << "\n";
d1963 1
d1966 1
d1968 2
a1969 2
				warnx << "no minsig in T_" << i
				      << " (list ended)\n";
d1974 3
a1976 1
				warnx << "minsig found in T_" << i << "\n";
d1982 5
a1986 1
				warnx << "no minsig in T_" << i << "\n";
d2118 8
a2125 4
			// TODO:
			// necessary to check if at end of list?
			// does revese order of if/else matter?
			if ((citr[i] == allT[i].end()) && (minsig[0] != 0)) {
a2135 6
			} else if (citr[i]->first == minsig) {
				//warnx << "minsig found in T_" << i << "\n";
				sumf += citr[i]->second[0];
				sumw += citr[i]->second[1];
				// XXX: itr of T_0 will be incremented later
				if (i != 0) ++citr[i];
@


1.53
log
@remove threading (commented)
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.52 2010/07/15 02:19:17 vsfgd Exp vsfgd $	*/
d31 1
a31 1
static char rcsid[] = "$Id: gpsi.C,v 1.52 2010/07/15 02:19:17 vsfgd Exp vsfgd $";
a1243 1
			// disable readability callback?
a1244 1
			// do you have to close?
d1252 1
a1252 2
			warnx << "readgossip: no more to read\n";
			// 0 or NULL?
a1253 1
			// do you have to close?
d1256 1
a1256 5
			// do you have to break?
			break;
			// what's the difference and should we continue?
			//exit(0);
			//return;
a1277 5
	if (recvlen == 0) {
		warnx << "readgossip: nothing received\n";
		return;
	}

d1384 1
a1384 1
	// always disable readability callback before closing a f*cking fd
@


1.52
log
@disable readibility callback before closing fd!
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.51 2010/07/14 20:48:40 vsfgd Exp vsfgd $	*/
a22 2
//#include <pthread.h>

d31 1
a31 1
static char rcsid[] = "$Id: gpsi.C,v 1.51 2010/07/14 20:48:40 vsfgd Exp vsfgd $";
a110 2
//pthread_mutex_t lock;

a489 3
	//pthread_t thread_ID;
	//void *exit_status;

a792 2
		//pthread_mutex_init(&lock, NULL);
		//pthread_create(&thread_ID, NULL, listengossip, NULL);
a804 1
			//pthread_mutex_lock(&lock);
a816 1
			//pthread_mutex_unlock(&lock);
a829 1
			//pthread_join(thread_ID, &exit_status);
a832 2
		// when do we destroy the thread?
		//pthread_mutex_destroy(&lock);
a844 2
		//pthread_mutex_init(&lock, NULL);
		//pthread_create(&thread_ID, NULL, listengossip, NULL);
a855 1
			//pthread_mutex_lock(&lock);
a929 1
					//pthread_mutex_lock(&lock);
a945 1
					//pthread_mutex_unlock(&lock);
a1010 2
		// when do we destroy the thread?
		//pthread_mutex_destroy(&lock);
a1804 1
	//pthread_mutex_lock(&lock);
a1816 1
	//pthread_mutex_unlock(&lock);
a1824 1
	//pthread_mutex_lock(&lock);
a1829 1
	//pthread_mutex_unlock(&lock);
@


1.51
log
@keep track of creating and closing fd
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.50 2010/07/08 23:29:58 vsfgd Exp vsfgd $	*/
d33 1
a33 1
static char rcsid[] = "$Id: gpsi.C,v 1.50 2010/07/08 23:29:58 vsfgd Exp vsfgd $";
a1196 2
//void *
//listengossip(void *)
d1212 2
a1213 1
		return;
a1214 4

	fdcb(fd, selread, wrap(acceptconn, fd));

	//return NULL;
d1230 2
a1231 1
	} else if (errno != EAGAIN) {
d1234 1
a1234 1
		//fdcb(fd, selread, 0);
d1266 1
a1266 1
			fdcb(fd, selread, 0);
d1277 1
a1277 1
			fdcb(fd, selread, 0);
a1308 2
		close(fd);
		++closefd;
d1334 1
a1334 1
			fdcb(fd, selread, 0);
d1400 1
a1400 1
			fdcb(fd, selread, 0);
d1418 5
a1422 2
	// TODO: ?
	//close(fd);
@


1.50
log
@nothing received added
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.49 2010/07/07 17:57:54 vsfgd Exp vsfgd $	*/
d33 1
a33 1
static char rcsid[] = "$Id: gpsi.C,v 1.49 2010/07/07 17:57:54 vsfgd Exp vsfgd $";
d40 2
d790 2
d1213 1
d1234 1
d1273 1
d1284 1
d1314 1
d1342 1
d1408 1
@


1.49
log
@close fd only when done reading
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.48 2010/07/07 16:45:03 vsfgd Exp vsfgd $	*/
d33 1
a33 1
static char rcsid[] = "$Id: gpsi.C,v 1.48 2010/07/07 16:45:03 vsfgd Exp vsfgd $";
d69 1
a69 1
void acceptconnection(int);
d1200 1
a1200 1
	if (fd < 0) fatal << "Error creating gsock" << strerror (errno) << "\n";
d1207 1
a1207 1
		fatal("Error from listen: %m\n");
d1212 1
a1212 1
	fdcb(fd, selread, wrap(acceptconnection, fd));
d1219 1
a1219 1
acceptconnection(int fd)
d1221 3
a1223 2
	sockaddr_in sin;
	unsigned sinlen = sizeof(sin);
d1225 2
a1226 2
	//bzero(&sin, sizeof(sin));
	int cs = accept(fd, (struct sockaddr *) &sin, &sinlen);
d1230 1
a1230 1
		warnx << "accept: error: " << strerror(errno) << "\n";
d1277 1
a1277 1
			// TODO: ?
a1300 2
	// XXX: InsertType
	//} while ((recvlen + (int)sizeof(int)) < msglen);
d1303 6
@


1.48
log
@close fd after done reading from gsock
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.47 2010/07/06 03:25:21 vsfgd Exp vsfgd $	*/
d33 1
a33 1
static char rcsid[] = "$Id: gpsi.C,v 1.47 2010/07/06 03:25:21 vsfgd Exp vsfgd $";
d1409 1
a1409 1
	close(fd);
@


1.47
log
@converted lshchordID sleep() to delaycb()
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.46 2010/07/05 00:40:38 vsfgd Exp vsfgd $	*/
d33 1
a33 1
static char rcsid[] = "$Id: gpsi.C,v 1.46 2010/07/05 00:40:38 vsfgd Exp vsfgd $";
d1265 1
a1265 1
			//close(fd);
d1276 2
d1407 3
@


1.46
log
@initintval may be 0
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.45 2010/07/03 21:11:21 vsfgd Exp vsfgd $	*/
d33 1
a33 1
static char rcsid[] = "$Id: gpsi.C,v 1.45 2010/07/03 21:11:21 vsfgd Exp vsfgd $";
d38 2
a39 1
int sleepnow;
d144 1
a144 1
wakeupnow()
d146 9
a154 2
	warnx << "sleep interval is up\n";
	++sleepnow;
d398 6
a403 1
			sleep(intval);
d778 3
a780 3
			delaycb(waitintval, 0, wrap(wakeupnow));
			while (sleepnow == 0) acheck();
			//sleepnow = 0;
@


1.45
log
@substitute sleep() at end of init phase with delaycb
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.44 2010/07/02 03:51:11 vsfgd Exp vsfgd $	*/
d33 1
a33 1
static char rcsid[] = "$Id: gpsi.C,v 1.44 2010/07/02 03:51:11 vsfgd Exp vsfgd $";
d498 2
a499 1
	gintval = initintval = waitintval = nids = 0;
d655 1
a655 1
	if ((Hflag == 1 && gflag == 1) && (waitintval == 0 || initintval == 0) &&
@


1.44
log
@ctim
e
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.43 2010/06/29 01:59:35 vsfgd Exp vsfgd $	*/
d33 1
a33 1
static char rcsid[] = "$Id: gpsi.C,v 1.43 2010/06/29 01:59:35 vsfgd Exp vsfgd $";
d38 1
d142 7
d762 6
a767 1
			sleep(waitintval);
@


1.43
log
@overwrite log.gpsi
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.42 2010/06/24 13:34:06 vsfgd Exp vsfgd $	*/
d33 1
a33 1
static char rcsid[] = "$Id: gpsi.C,v 1.42 2010/06/24 13:34:06 vsfgd Exp vsfgd $";
d709 2
a710 2
	warnx << "ctime: " << ctime(&rawtime);
	warnx << "sincepoch: " << time(&rawtime) << "\n";
d832 2
a833 1
		warnx << "execsincepoch: " << time(&rawtime) << "\n";
@


1.42
log
@printlist after init phase
display n sig and isig
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.41 2010/06/24 03:38:55 vsfgd Exp vsfgd $	*/
d33 1
a33 1
static char rcsid[] = "$Id: gpsi.C,v 1.41 2010/06/24 03:38:55 vsfgd Exp vsfgd $";
d654 2
a655 2
		// TODO: overwrite existing file
		logfd = open(logfile, O_RDWR | O_CREAT, 0666);
@


1.41
log
@final init state phase
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.40 2010/06/12 23:36:35 vsfgd Exp vsfgd $	*/
d33 1
a33 1
static char rcsid[] = "$Id: gpsi.C,v 1.40 2010/06/12 23:36:35 vsfgd Exp vsfgd $";
d758 3
d2244 1
a2244 1
	int n = 0;
d2253 1
d2264 5
a2268 8
		/*
		isig = inverse(sig);
		sig2str(isig, sigbuf);
		warnx << "isig" << n << ": " << sigbuf << "\n";
		isig = inverse(isig);
		sig2str(isig, sigbuf);
		warnx << "isig^2" << n << ": " << sigbuf << "\n";
		*/
d2281 3
a2283 1
	warnx << " setsize: " << allT[listnum].size() << "\n";
@


1.40
log
@modified sigcmp to correctly handle special multisets
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.39 2010/06/09 02:23:55 vsfgd Exp vsfgd $	*/
a6 1
#include <fstream>
d33 1
a33 1
static char rcsid[] = "$Id: gpsi.C,v 1.39 2010/06/09 02:23:55 vsfgd Exp vsfgd $";
d44 1
d80 2
d84 2
d94 1
d97 1
d474 1
a474 1
	int Gflag, Lflag, lflag, rflag, Sflag, sflag, zflag, vflag, Hflag, dflag, jflag, mflag;
d488 1
a488 1
	Gflag = Lflag = lflag = rflag = Sflag = sflag = zflag = vflag = Hflag = dflag = jflag = mflag = 0;
d491 1
a491 1
	irrpolyfile = NULL;
d497 1
a497 1
	while ((ch = getopt(argc, argv, "B:cd:G:gHhI:i:j:L:lmn:pq:R:rS:s:uvw:z")) != -1)
d512 6
d528 1
a528 1
		case 'I':
d531 1
a531 1
		case 'i':
d551 4
d637 2
a638 1
	if (gflag == 1 && (gintval == 0 || sflag == 0)) usage();
d640 2
a641 2
	// action H
	if (Hflag == 1 && (sflag == 0 || dflag == 0 || jflag == 0))
d645 3
a647 1
	if ((Hflag == 1 && gflag == 1) && (waitintval == 0 || initintval == 0))
d654 1
d661 13
d685 1
a685 1
	if (rflag == 1 || gflag == 1 || Hflag == 1 || lflag == 1) {
d721 6
d728 4
a731 1
	if (Hflag == 1) {
d735 1
a735 8
		if (gflag == 1) {
			warnx << "listening for gossip...\n";
			listengossip();		
			sleep(5);
			warnx << "initgossipsend...\n";
			warnx << "init interval: " << initintval << "\n";
		}

d750 1
d755 3
a765 1
		warnx << "listening for gossip...\n";
a767 2
		listengossip();		
		sleep(5);
d814 11
a824 1
	} else if (gflag == 1 && Hflag == 1) {
a998 4
	} else if (lflag == 1) {
		warnx << "listening for gossip...\n";
		listengossip();
		//listengossip(NULL);
d1376 102
a1505 2
	//FILE *tagsfp;
	//std::string tagsfile;
d1694 33
d1735 1
a1735 1
	for (int i = 0; i < (int) sig.size(); i++)
d2286 7
a2292 1
	warn << "Usage: " << __progname << " [-h] [options...]\n\n";
d2297 2
a2298 1
	     << "	-d		<random prime number for LSH seed>\n"
d2300 1
d2303 1
a2303 4
	     << "      	-I		<how often>\n"
					"\t\t\t(init interval)\n"
	     << "      	-i		<how often>\n"
					"\t\t\t(gossip interval)\n"
d2308 1
d2310 2
a2313 1
	     << "	-S		<dhash socket>\n"
d2315 4
a2318 1
	     << "	-u		make POLYs unique (convert multiset to set)\n"
d2320 1
a2320 1
					"\t\t\t(wait interval b/w init and exec phase)\n\n"
d2324 1
@


1.39
log
@added logging of init phase length
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.38 2010/06/07 01:51:21 vsfgd Exp vsfgd $	*/
d34 1
a34 1
static char rcsid[] = "$Id: gpsi.C,v 1.38 2010/06/07 01:51:21 vsfgd Exp vsfgd $";
d90 1
a90 1
bool sigcmp(const std::vector<POLY>&, const std::vector<POLY>&);
d714 1
d1637 1
a1637 1
sigcmp(const std::vector<POLY>& s1, const std::vector<POLY>& s2)
d1639 16
a1654 2
	//warnx << "sigcmp: S1 size: " << s1.size()
	//      << ", S2 size: " << s2.size() << "\n";
d1867 1
a1867 1
			// DO NOT skip special multisets?
d1897 4
a1900 11
			// TODO: if end of list, will it segfault?
			if (citr[i]->first == minsig) {
				//warnx << "minsig found in T_" << i << "\n";
				sumf += citr[i]->second[0];
				sumw += citr[i]->second[1];
				// XXX: itr of T_0 will be incremented later
				if (i != 0) ++citr[i];
			// DO NOT skip lists which are done:
			// use special multiset
			// TODO: necessary to check if at end of list?
			} else if ((citr[i] == allT[i].end()) && (minsig[0] != 0)) {
d1911 6
d1918 3
@


1.38
log
@added -B and -R (lfuncs and mgroups)
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.37 2010/06/07 01:35:09 vsfgd Exp vsfgd $	*/
d34 1
a34 1
static char rcsid[] = "$Id: gpsi.C,v 1.37 2010/06/07 01:35:09 vsfgd Exp vsfgd $";
d692 1
d712 2
a714 1
			warnx << "xgossip+ init phase done\n";
d782 1
@


1.37
log
@xgossip+ draft4 version
extensive testing on eagle
pre-planetlab testing
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.36 2010/05/03 00:40:32 vsfgd Exp vsfgd $	*/
d34 1
a34 1
static char rcsid[] = "$Id: gpsi.C,v 1.36 2010/05/03 00:40:32 vsfgd Exp vsfgd $";
d491 1
a491 1
	while ((ch = getopt(argc, argv, "cd:G:gHhI:i:j:L:lmn:pq:rS:s:uvw:z")) != -1)
d493 6
d683 2
d2093 2
@


1.36
log
@xgossip+ initgossiprecv draft2 version
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.35 2010/04/04 15:06:20 vsfgd Exp vsfgd $	*/
d12 1
d34 1
a34 1
static char rcsid[] = "$Id: gpsi.C,v 1.35 2010/04/04 15:06:20 vsfgd Exp vsfgd $";
d45 1
a45 1
int lshseed;
d47 2
d51 1
d54 14
a67 4
int lfuncs = 10;
int mgroups = 20;
 
void accept_connection(int);
a71 1
void calcfreqO(std::vector<std::vector <POLY> >);
d73 2
a74 1
void inform_team(chordID, std::vector<chordID>, std::vector<POLY>);
d78 4
a81 3
void listen_gossip(void);
//void *listen_gossip(void *);
void merge_lists(void);
d85 1
a85 1
void read_gossip(int);
d88 1
a104 5
typedef std::map<std::vector<POLY>, std::vector<double>, CompareSig> mapType;
typedef std::vector<mapType> vecomap;
// local list T[0] is stored in allT[0];
vecomap allT;

d223 239
d468 3
a470 4
	int Gflag, gflag, Lflag, lflag, rflag, Sflag, sflag, zflag, vflag, Hflag, dflag, jflag, mflag, uflag;

	int ch, intval, nids, valLen;
	int logfd;
d476 1
d480 1
d482 1
a482 1
	Gflag = gflag = Lflag = lflag = rflag = Sflag = sflag = zflag = vflag = Hflag = dflag = jflag = mflag = uflag = 0;
d484 1
a484 1
	intval = nids = lshseed = 0;
d488 2
d491 1
a491 1
	while ((ch = getopt(argc, argv, "cd:G:gHhi:j:L:lmn:pq:rS:s:uvz")) != -1)
d510 3
d514 1
a514 1
			intval = strtol(optarg, NULL, 10);
d553 3
d615 9
a623 2
	// TODO: check intval bound
	if (gflag == 1 && intval == 0 && sflag == 0) usage();
d625 2
a626 2
	if (rflag == 1 && sflag == 0) usage();
	if (Hflag == 1 && sflag == 0 && dflag == 0 && jflag == 0) usage();
d646 1
a646 1
	if (rflag == 1 || gflag == 1 || Hflag == 1) {
d652 5
a656 13
		dummysig.clear();
		dummysig.push_back(1);
		sigList.push_back(dummysig);

		/*
		std::vector<POLY> testsig;
		testsig.clear();
		testsig.push_back(6228403);
		testsig.push_back(6228403);
		testsig.push_back(6228403);
		testsig.push_back(6228403);
		sigList.push_back(testsig);
		*/
a668 159
	// LSH
	if (Hflag == 1 && dflag != 0 && sflag != 0 && jflag != 0) {
		// XXX: ugly, use templates
		// InitGossipSend
		// (use findMod())
		double freq, weight;
		if (mflag == 1) {
			std::vector<POLY> minhash;
			std::vector<std::vector<POLY> > matrix;
			std::vector<POLY> sig;
			str sigbuf;
			int col;

			for (mapType::iterator itr = allT[0].begin(); itr != allT[0].end(); itr++) {
				sig = itr->first;
				freq = itr->second[0];
				weight = itr->second[1];

				lsh *myLSH = new lsh(sig.size(), lfuncs, mgroups, lshseed, irrpolyfile);

				// convert multiset to set
				if (uflag == 1) {
					/*
					for (unsigned int i = 0; i < sig.size(); i++) {
						warnx << "nomod..." << sig[i] << "\n";
					}
					for (unsigned int i = 0; i < sig.size(); i++) {
						warnx << "mod..." << (myLSH->getUniqueSet(sig))[i] << "\n";
					}
					*/

					sig2str(sig, sigbuf);
					warnx << "multiset: " << sigbuf << "\n";
					myLSH->getUniqueSet(sig);
					sig2str(sig, sigbuf);
					warnx << "set: " << sigbuf << "\n";
				}

				minhash = myLSH->getHashCodeFindMod(sig, myLSH->getIRRPoly());

				//warnx << "minhash.size(): " << minhash.size() << "\n";
				if (plist == 1) {
					warnx << "minhash IDs:\n";
					for (int i = 0; i < (int)minhash.size(); i++) {
						warnx << minhash[i] << "\n";
					}
				}

				matrix.push_back(minhash);
				delete myLSH;
			}
			// call srand/srandom right before calling rand/random
			//srand(time(NULL));
			srand(loseed);
			int range = (int)minhash.size();
			col = int((double)range * rand() / (RAND_MAX + 1.0));

			warnx << "POLYs in random column " << col << ":\n";
			for (int i = 0; i < (int)matrix.size(); i++) {
				warnx << matrix[i][col] << "\n";;
			}
		// InitGossipSend
		// (use compute_hash())
		} else {
			std::vector<chordID> minhash;
			std::vector<std::vector<chordID> > matrix;
			std::vector<POLY> sig;
			str sigbuf;
			int col;

			if (gflag == 1) {
				warnx << "listening for gossip...\n";
				listen_gossip();		
				sleep(5);
				warnx << "gossiping...\n";
				warnx << "interval: " << intval << "\n";
			}

			for (mapType::iterator itr = allT[0].begin(); itr != allT[0].end(); itr++) {
				sig = itr->first;
				freq = itr->second[0];
				weight = itr->second[1];

				lsh *myLSH = new lsh(sig.size(), lfuncs, mgroups, lshseed, irrpolyfile);
				// convert multiset to set
				if (uflag == 1) {
					/*
					for (unsigned int i = 0; i < sig.size(); i++) {
						warnx << "nomod..." << sig[i] << "\n";
					}
					for (unsigned int i = 0; i < sig.size(); i++) {
						warnx << "mod..." << (myLSH->getUniqueSet(sig))[i] << "\n";
					}
					*/

					sig2str(sig, sigbuf);
					warnx << "multiset: " << sigbuf << "\n";
					myLSH->getUniqueSet(sig);
					sig2str(sig, sigbuf);
					warnx << "set: " << sigbuf << "\n";
				}

				minhash = myLSH->getHashCode(sig);

				//warnx << "minhash.size(): " << minhash.size() << "\n";
				if (plist == 1) {
					warnx << "minhash IDs:\n";
					for (int i = 0; i < (int)minhash.size(); i++) {
						warnx << minhash[i] << "\n";
					}
				}

				matrix.push_back(minhash);

				//srand(time(NULL));
				srand(loseed);
				int range = (int)minhash.size();
				col = int((double)range * rand() / (RAND_MAX + 1.0));
				ID = (matrix.back())[col];
				warnx << "ID in col " << col << ": " << ID << "\n";

				if (gflag == 1) {
					strbuf t;
					t << ID;
					str key(t);
					warnx << "inserting INITGOSSIP:\n";
					makeKeyValue(&value, valLen, key, sig, freq, weight, INITGOSSIP);
					status = insertDHT(ID, value, valLen, MAXRETRIES);
					cleanup(value);

					// do not exit if insert FAILs!
					if (status != SUCC) {
						warnx << "error: insert FAILed\n";
					} else {
						warnx << "insert SUCCeeded\n";
					}

					// TODO: ?
					warnx << "sleeping...\n";
					sleep(intval);
				}

				delete myLSH;
			}
		
			/*
			warnx << "chordIDs in random column " << col << ":\n";
			for (int i = 0; i < (int)matrix.size(); i++) {
				warnx << matrix[i][col] << "\n";;
			}
			*/
		}

		// continue listening
		warnx << "done with sigs\n";
		sleep(360);
		return 0;
	}

d677 14
d692 24
a715 1
	if (gflag == 1) {
d718 2
a719 2
		//pthread_create(&thread_ID, NULL, listen_gossip, NULL);
		listen_gossip();		
d721 2
a722 2
		warnx << "gossiping...\n";
		warnx << "interval: " << intval << "\n";
a724 1
		txseq.push_back(0);
d734 3
a736 3
			double beginTime = getgtod();    
			merge_lists();
			double endTime = getgtod();    
d739 1
a739 1
			warnx << "inserting GOSSIP:\n"
d745 1
a745 1
			makeKeyValue(&value, valLen, key, allT[0], txseq.back(), GOSSIP);
d761 2
a762 2
			warnx << "sleeping...\n";
			sleep(intval);
d764 160
d925 12
d943 5
a947 3
		listen_gossip();
		//listen_gossip(NULL);
	} else
d949 1
d1107 1
d1109 1
a1109 1
//listen_gossip(void *)
d1111 1
a1111 1
listen_gossip(void)
d1115 1
a1115 1
	if (fd < 0) fatal << "Error creating GOSSIP socket" << strerror (errno) << "\n";
d1127 1
a1127 1
	fdcb(fd, selread, wrap(accept_connection, fd));
d1132 1
d1134 1
a1134 1
accept_connection(int fd)
d1150 1
a1150 1
	fdcb(cs, selread, wrap(read_gossip, cs));
d1153 1
d1155 1
a1155 1
read_gossip(int fd)
d1176 1
a1176 1
			warnx << "read_gossip: read failed\n";
d1186 1
a1186 1
			warnx << "read_gossip: no more to read\n";
d1206 2
a1207 2
		warnx << "\nread_gossip: n: " << n << "\n";
		warnx << "read_gossip: recvlen: " << recvlen << "\n";
d1224 11
a1234 2
	if (msgtype == GOSSIP) {
		warnx << "GOSSIP";
d1287 6
a1292 1
		if (msgtype == INITGOSSIP)
d1294 1
a1294 1
		else
d1296 2
a1308 1
		sig2str(sig, sigbuf);
d1310 5
a1314 4
		warnx << "sig: " << sigbuf;
		printdouble(" ", freq);
		printdouble(" ", weight);
		warnx << "\n";
d1317 1
a1317 1
	} else
d1319 1
d1324 1
d1344 1
d1395 12
d1412 1
a1415 1
	str sigbuf;
d1417 1
d1421 2
a1422 2
	sig2str(isig, sigbuf);
	warnx << "isig: " << sigbuf << "\n";
d1424 4
a1427 4
	mapType::iterator itr1 = allT[0].find(sig);
	mapType::iterator itr2 = allT[0].find(isig);
	if ((itr1 != allT[0].end()) && (sig[0] != 0)) {
		// update freq
d1429 3
a1431 3
		itr1->second[0] += freq;
	} else if ((itr1 != allT[0].end()) && (itr2 != allT[0].end())) {
		// delete special multiset tuple
d1433 7
a1439 9
		// figure out which is the special multiset
		if (sig[0] == 0) {
			// TODO: inefficient?
			allT[0].erase(itr1);
		} else if (isig[0] == 0) {
			// TODO: inefficient?
			allT[0].erase(itr2);
		} else
			warnx << "error: no special multiset\n";
d1441 5
a1445 19
		// if s (sig) is special, s' (isig) is regular
		if ((sig[0] == 0) && (itr2 != allT[0].end())) {
			// delete regular multiset tuple
			warnx << "initgossiprecv: delete regular multiset tuple\n";
			// TODO: inefficient?
			allT[0].erase(itr1);
		} else {
			// inform team
			warnx << "initgossiprecv: inform team\n";
			allT[0][sig].push_back(freq);
			allT[0][sig].push_back(weight);

			lsh *myLSH = new lsh(sig.size(), lfuncs, mgroups, lshseed, irrpolyfile);
			std::vector<chordID> minhash = myLSH->getHashCode(sig);

			inform_team(ID, minhash, sig);

			delete myLSH;
		}
d1449 1
d1451 1
a1451 1
inform_team(chordID myID, std::vector<chordID> minhash, std::vector<POLY> sig)
a1454 1
	str sigbuf;
d1458 9
d1471 2
a1472 2
	sig2str(isig, sigbuf);
	warnx << "inform_team: isig: " << sigbuf << "\n";
d1476 5
a1480 3
	for (int i = 0; i < (int)minhash.size(); i++) {
		warnx << "minhash[" << i << "]: "<< minhash[i] << "\n";
	}
d1482 9
a1490 4
	for (int i = 0; i < (int)minhash.size(); i++) {
		if (myID < minhash[i]) {
			nextID = minhash[i];
			break;
a1492 2
	if (nextID == myID)
		warnx << "warning: no new ID\n";
a1499 1
	//makeKeyValue(&value, valLen, key, minhash, INFORMTEAM);
d1508 1
d1513 2
d1540 1
d1555 1
d1583 2
a1584 1
// deprecated: use merge_lists() instead
d1606 1
d1623 1
a1626 1
	// Return TRUE if s1 < s2
d1630 3
a1632 2
	if (s1.size() < s2.size()) return true;
	else if (s1.size() == s2.size()) {
d1634 4
a1637 2
			if (s1[i] < s2[i]) return true;
			else if (s1[i] > s2[i]) return false;
d1640 3
a1642 1
	} else return false;
d1645 1
d1647 1
a1647 1
merge_lists()
d1724 1
a1724 1
			// DO NOT skip lists which are done
d1727 2
a1728 2
				//warnx << "no minsig in T_" << i
				//      << " (list ended)\n";
d1733 1
a1733 1
				//warnx << "minsig found in T_" << i << "\n";
d1739 1
a1739 1
				//warnx << "no minsig in T_" << i << "\n";
d1779 192
a1976 1

d1985 1
d2001 22
d2034 1
d2043 1
a2049 1

a2079 200
// copied from psi.C
void
calcfreqO(std::vector<std::vector <POLY> > sigList)
{
	std::vector<int> group1;
	std::vector<int> group2;
	std::vector<POLY> lcm1;
	std::vector<POLY> lcm2;
	std::multimap<int, int> sortedSigList;

#ifdef _ELIMINATE_DUP_
	std::map<std::vector<POLY>, std::vector<int>, CompareSig> uniqueSigList;
	std::map<int, std::map<std::vector<POLY>, std::vector<int>, CompareSig>::const_iterator > duplicateList;

	// Sort them based on degree
	for (int i = 0; i < (int) sigList.size(); i++) {
		std::map<std::vector<POLY>, std::vector<int> >::iterator itr = uniqueSigList.find(sigList[i]);
		if (itr != uniqueSigList.end()) {
			itr->second.push_back(i+1);
		} else {
			int deg = getDegree(sigList[i]);
			//warnx << "Check degree: " << deg << "\n";
			sortedSigList.insert(std::pair<int, int>(deg, i));
			std::vector<int> e;
			e.clear();
			e.push_back(i+1);
			uniqueSigList[sigList[i]] = e;

			std::map<std::vector<POLY>, std::vector<int>, CompareSig>:: const_iterator uitr = 
			uniqueSigList.find(sigList[i]);
			//warnx << "Size of unique sig list: " << uniqueSigList.size() << "\n";
			assert(uitr != uniqueSigList.end());

			duplicateList[i+1] = uniqueSigList.find(sigList[i]);
		}
	}
	assert(uniqueSigList.size() > 0);

	// If all are identical
	if (uniqueSigList.size() == 1) {
		for (int i = 0; i < (int) floor(MAXENTRIES/2.0); i++) {
			group1.push_back(i+1);
		}
		lcm1 = uniqueSigList.begin()->first;

		for (int i = (int) floor(MAXENTRIES/2.0); i < MAXENTRIES; i++) {
			group2.push_back(i+1);
		}
		lcm2 = uniqueSigList.begin()->first;
		return;
	}
	warnx << "Size of unique sig list: " << uniqueSigList.size() << "\n";
	warnx << "Size of dup sig list: " << duplicateList.size() << "\n";
#else
	// Sort them based on degree
	for (int i = 0; i < (int) sigList.size(); i++) {
		int deg = getDegree(sigList[i]);
		//warnx << "Check degree: " << deg << "\n";
		sortedSigList.insert(std::pair<int, int>(deg, i));
	}
#endif

	warnx << "Size of sorted sig list: " << sortedSigList.size() << "\n";

	int seed1 = -1, seed2 = -1;
	std::vector<POLY> gcdPoly;
	int minDeg = INT_MAX;

	// Find the two most dissimilar
	std::multimap<int, int>::reverse_iterator endItrI = sortedSigList.rbegin();
	int i = 0;
	int MAXSIGS = 10;
	// Adjust the last sig to be checked
	while (i < MAXSIGS && endItrI != sortedSigList.rend()) {
		endItrI++;
		i++;
	}		

	for (std::multimap<int, int>::reverse_iterator itrI = sortedSigList.rbegin();
	     itrI != endItrI; itrI++) {

		std::multimap<int, int>::reverse_iterator itrJ = itrI;
		itrJ++;

		for (; itrJ != endItrI; itrJ++) {
			gcdPoly.clear();
			gcdSpecial(gcdPoly, sigList[itrI->second], sigList[itrJ->second]);
			std::vector<POLY> mylcm;
			mylcm = sigList[itrI->second];

			//int deg = pSim(sigList[itrI->second], sigList[itrJ->second], gcdPoly,
			//    metric);
			int deg = pSimOpt(mylcm, sigList[itrJ->second], gcdPoly, metric);
			//warnx << "Degree: " << deg << "\n";
			if (deg < minDeg) {
				seed1 = itrI->second;
				seed2 = itrJ->second;
				minDeg = deg;
			}

			if (deg < 0) break;
		}
	}

	//warnx << "MINDEGREE: " << minDeg << "\n";
	group1.push_back(seed1+1);
	group2.push_back(seed2+1);

	//warnx << "SEED1 : " << seed1
	//      << "  SEED2 : " << seed2
	//      << "\n";
	lcm1 = sigList[seed1];
	lcm2 = sigList[seed2];

	std::vector<POLY> gcd1, gcd2;
	std::vector<POLY> testLCM1, testLCM2;

	for (std::multimap<int, int>::iterator itr = sortedSigList.begin();
	     itr != sortedSigList.end(); itr++) {
		if (itr->second == seed1 || itr->second == seed2) continue;

		gcd1.clear();
		gcd2.clear();

		gcdSpecial(gcd1, lcm1, sigList[itr->second]);
		gcdSpecial(gcd2, lcm2, sigList[itr->second]);

		testLCM1 = lcm1;
		testLCM2 = lcm2;

		//int deg1 = getDegree(gcd1);
		//int deg2 = getDegree(gcd2);
		int deg1 = pSimOpt(testLCM1, sigList[itr->second], gcd1, metric);
		int deg2 = pSimOpt(testLCM2, sigList[itr->second], gcd2, metric);

		if (deg1 > deg2) {
			//lcm(lcm1, sigList[itr->second]);
			lcm1 = testLCM1;
			group1.push_back(itr->second+1);
		}
		else if (deg1 < deg2) {
			//lcm(lcm2, sigList[itr->second]);
			lcm2 = testLCM2;
			group2.push_back(itr->second+1);
		} else {
			if (group1.size() <= group2.size()) {
				//lcm(lcm1, sigList[itr->second]);
				lcm1 = testLCM1;
				group1.push_back(itr->second+1);
			} else {
				//lcm(lcm2, sigList[itr->second]);
				lcm2 = testLCM2;
				group2.push_back(itr->second+1);
			}
		}		
	}

#ifdef _ELIMINATE_DUP_
	int group1Size = group1.size();
	int group2Size = group2.size();
	warnx << "Group1 size: " << group1Size << "\n";

	for (int i = 0; i < group1Size; i++) {
		std::map<int, std::map<std::vector<POLY>, std::vector<int>, CompareSig>::const_iterator >::const_iterator itr = 
		duplicateList.find(group1[i]);

		assert(itr != duplicateList.end());

		std::map<std::vector<POLY>, std::vector<int>, CompareSig>::const_iterator ditr = itr->second;
		//warnx << "--> " << ditr->second.size() << "\n";
		// Skip the first entry -- already in group1
		for (int k = 1; k < (int) ditr->second.size(); k++) {
			group1.push_back(ditr->second[k]);	
		}
	}

	warnx << "Group2 size: " << group2Size << "\n";

	for (int i = 0; i < group2Size; i++) {
		std::map<int, std::map<std::vector<POLY>, std::vector<int>, CompareSig>::const_iterator >::const_iterator itr = 
		duplicateList.find(group2[i]);

		assert(itr != duplicateList.end());

		std::map<std::vector<POLY>, std::vector<int>, CompareSig>::const_iterator ditr = itr->second;

		//warnx << "--> " << ditr->second.size() << "\n";
		// Skip the first entry -- already in group2
		for (int k = 1; k < (int) ditr->second.size(); k++) {
			group2.push_back(ditr->second[k]);	
		}
	}
	warnx << "Sig list size: " << sigList.size() << "\nTotal size: " << group1.size() + group2.size() << "\n";
	// Header is absent - one less
	//assert(group1.size() + group2.size() == (size_t) MAXENTRIES);
#endif

	return;
}

d2089 3
a2091 1
					"\t\t\t(requires  -g, -s, -d, -j)\n"
d2093 1
d2099 1
a2099 1
	     << "      	-p		print list of signatures\n"
d2103 3
a2105 1
	     << "	-u		convert multiset to set\n\n"
d2109 1
a2109 1
	     << "	-l		listen for gossip (requires -S, -G, -L)\n"
@


1.35
log
@init gossip phase (except inform team)
doublefreq when insert fails
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.34 2010/03/28 16:29:26 vsfgd Exp vsfgd $	*/
d3 1
d33 1
a33 1
static char rcsid[] = "$Id: gpsi.C,v 1.34 2010/03/28 16:29:26 vsfgd Exp vsfgd $";
d60 2
a61 2
void inform_team(std::vector<chordID>);
void initgossiprecv(std::vector<POLY>, double, double);
d328 2
d337 2
a338 1
			warnx << "successorID: " << successorID(ID, 0) << "\n";
d341 5
d414 2
a415 1
		// use findMod()
d472 2
a473 1
		// use compute_hash()
d478 1
d495 18
a528 1
				warnx << "random col: " << col << "\n";
d530 1
a530 1
				warnx << "ID in col: " << ID << "\n";
d536 1
d543 1
a543 1
						warnx << "insert FAILed\n";
d548 1
d564 3
d604 2
a605 1
			warnx << "inserting:\ntxseq: " << txseq.back()
d617 1
a617 1
				warnx << "insert FAILed\n";
d848 1
d911 1
a911 1
	if (msgtype == GOSSIP)
d913 2
a914 7
	else if (msgtype == INITGOSSIP) {
		warnx << "INITGOSSIP";
		warnx << "\n";
		double freq, weight;
		std::vector<POLY> sig;
		sig.clear();
		ret = getKeyValue(gmsg.cstr(), key, sig, freq, weight, recvlen);
d916 1
d922 4
a925 6
		sig2str(sig, sigbuf);
		warnx << "rxID: " << key;
		warnx << " sig: " << sigbuf;
		printdouble(" freq: ", freq);
		printdouble(" weight: ", weight);
		warnx << "\n";
d927 9
a935 26
		initgossiprecv(sig, freq, weight);
		
		return;
	} else
		warnx << "invalid";

	ret = getKeyValue(gmsg.cstr(), key, sigList, freqList, weightList, seq, recvlen);
	if (ret == -1) {
		fdcb(fd, selread, 0);
		close(fd);
		return;
	}

	warnx << " rxlistlen: " << sigList.size()
	      << " rxseq: " << seq
	      << " txseq-cur: " << txseq.back()
	      << " rxID: " << key << "\n";

	// count rounds off by one
	n = seq - txseq.back();
	if (n < 0) {
		warnx << "warning: rxseq<txseq n: " << abs(n) << "\n";
		if (discardmsg == 1) {
			if (abs(n) != 1) {
				warnx << "warning: msg discarded\n";
				return;
d937 7
a943 7
		}
	} else if (n > 0) {
		warnx << "warning: rxseq>txseq n: " << n << "\n";
		if (discardmsg == 1) {
			if (n != 1) {
				warnx << "warning: msg discarded\n";
				return;
a945 1
	}
d948 12
a959 12
	for (int i = 0; i < (int) sigList.size(); i++) {
		sig2str(sigList[i], sigbuf);
		warnx << "sig[" << i << "]: " << sigbuf << "\n";
	}
	for (int i = 0; i < (int) freqList.size(); i++) {
		printdouble("freq[i]: ", freqList[i]);
		warnx << "\n";
	}
	for (int i = 0; i < (int) weightList.size(); i++) {
		printdouble("weight[i]: ", weightList[i]);
		warnx << "\n";
	}
d962 28
a989 4
	rxseq.push_back(seq);
	add2vecomap(sigList, freqList, weightList);
	//calcfreqM(sigList, freqList, weightList);
	//if (plist == 1) printlist(0);
d1069 1
a1069 1
initgossiprecv(std::vector<POLY> sig, double freq, double weight)
d1083 1
d1087 10
a1096 1
		allT[0].erase(itr2);
d1098 1
d1101 2
d1105 2
d1113 1
a1113 1
			inform_team(minhash);
d1121 1
a1121 1
inform_team(std::vector<chordID> minhash)
d1123 6
d1130 40
d1473 1
a1473 1
	std::vector<POLY> isig;
d1487 1
d1494 1
d1723 2
a1724 1
	     << "      	-m		call findMod instead of compute_hash\n"
@


1.34
log
@count rounds off by one when discarding
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.33 2010/03/25 14:06:50 vsfgd Exp vsfgd $	*/
d24 1
d32 1
a32 1
static char rcsid[] = "$Id: gpsi.C,v 1.33 2010/03/25 14:06:50 vsfgd Exp vsfgd $";
d42 2
d47 4
d58 3
d62 1
d219 1
a219 1
	int ch, intval, nids, lshseed, valLen;
a221 1
	char *irrpolyfile;
d330 5
a334 3
			t << ID;
			str tmpkey(t);
			warnx << tmpkey << "\n";
a417 5
				int kc = sig.size();
				warnx << "kc: " << kc << "\n";
				int lc = 10;
				int mc = 20;
				int nc = lshseed;
d419 1
a419 1
				lsh *myLSH = new lsh(kc, lc, mc, nc, irrpolyfile);
d469 8
a480 5
				int kc = sig.size();
				warnx << "kc: " << kc << "\n";
				int lc = 10;
				int mc = 20;
				int nc = lshseed;
d482 1
a482 1
				lsh *myLSH = new lsh(kc, lc, mc, nc, irrpolyfile);
d502 1
d583 3
a883 5
		sig2str(sig, sigbuf);
		warnx << "sig: " << sigbuf;
		printdouble(" freq: ", freq);
		printdouble(" weight: ", weight);
		warnx << "\n";
d890 9
d1032 66
d1328 15
d1376 1
d1390 6
@


1.33
log
@added option to discard out-of-round messages
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.32 2010/03/18 05:58:32 vsfgd Exp vsfgd $	*/
d31 1
a31 1
static char rcsid[] = "$Id: gpsi.C,v 1.32 2010/03/18 05:58:32 vsfgd Exp vsfgd $";
d484 27
d513 2
a514 5
			//srand(time(NULL));
			srand(loseed);
			int range = (int)minhash.size();
			col = int((double)range * rand() / (RAND_MAX + 1.0));

d519 1
d550 2
a551 2
			std::vector<POLY> sig;
			sig.clear();
d798 1
d802 1
d851 2
a852 1
	} while ((recvlen + (int)sizeof(int)) < msglen);
d858 27
a884 1
	//assert(gmsg);
d896 19
a914 10
	// TODO: check if sizes are the same?
	//warnx << ", freqList size: " << freqList.size()
	//warnx << ", weightList size: " << weightList.size() << "\n";

	if (seq < txseq.back()) {
		warnx << "discarding: rxseq < txseq\n";
		if (discardmsg == 1) return;
	} else if (seq > txseq.back()) {
		warnx << "discarding: rxseq > txseq\n";
		if (discardmsg == 1) return;
a917 1
	str sigbuf;
d1513 2
d1527 1
a1527 1
	     << "	-H		generate chordIDs/POLYs using LSH (requires -s, -d, -j)\n"
@


1.32
log
@discard out of round messages
print merge lists time
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.31 2010/03/17 00:18:53 vsfgd Exp vsfgd $	*/
d31 1
a31 1
static char rcsid[] = "$Id: gpsi.C,v 1.31 2010/03/17 00:18:53 vsfgd Exp vsfgd $";
d42 1
d206 1
a206 1
	int Gflag, gflag, Lflag, lflag, rflag, Sflag, sflag, zflag, vflag, pflag, Hflag, dflag, jflag, mflag, uflag;
d220 1
a220 1
	Gflag = gflag = Lflag = lflag = rflag = Sflag = sflag = zflag = vflag = pflag = Hflag = dflag = jflag = mflag = uflag = 0;
d227 1
a227 1
	while ((ch = getopt(argc, argv, "d:G:gHhi:j:L:lmn:pq:rS:s:uvz")) != -1)
d229 3
d267 1
a267 1
			pflag = 1;
d348 4
a351 1
	if (pflag == 1) plist = 1;
d354 2
a355 1
		if (stat(dsock, &statbuf) != 0) fatal << "socket does not exist" << "\n";
d394 1
d402 4
a405 2
			for (int i = 0; i < (int)sigList.size(); i++) {
				sig = sigList[i];
d434 1
a434 1
				warnx << "minhash.size(): " << minhash.size() << "\n";
d462 4
a465 2
			for (int i = 0; i < (int)sigList.size(); i++) {
				sig = sigList[i];
d475 1
a475 1
				warnx << "minhash.size(): " << minhash.size() << "\n";
d848 1
a848 1
		return;
d851 1
a851 1
		return;
d884 1
d1448 1
@


1.31
log
@lsh changes concerning getUniqueSet
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.30 2010/03/08 22:10:57 vsfgd Exp vsfgd $	*/
d31 1
a31 1
static char rcsid[] = "$Id: gpsi.C,v 1.30 2010/03/08 22:10:57 vsfgd Exp vsfgd $";
d44 6
a50 5
//void retrieveDHT(chordID ID, int, str&, chordID guess = 0);

chordID randomID(void);
void accept_connection(int);
bool sigcmp(const std::vector<POLY>&, const std::vector<POLY>&);
d54 3
a57 1
int getdir(std::string, std::vector<std::string>&);
d59 1
d61 1
a61 6
void add2vecomap(std::vector<std::vector <POLY> >, std::vector<double>, std::vector<double>);
void calcfreq(std::vector<std::vector <POLY> >);
void calcfreqM(std::vector<std::vector <POLY> >, std::vector<double>, std::vector<double>);
void calcfreqO(std::vector<std::vector <POLY> >);
void printlist(int, int);
void printdouble(std::string, double);
d78 1
d516 1
d518 3
d833 7
a839 5
	// TODO: discard out of round msgs?
	if (seq < txseq.back())
		warnx << "warning: rxseq < txseq\n";
	else if (seq > txseq.back())
		warnx << "warning: rxseq > txseq\n";
a955 1
	//int deg;
a960 3
	//deg = getDegree(sig);
	//warnx << "deg of dummy sig: " << deg << "\n";

a968 2
			//deg = getDegree(sigList[i]);
			//warnx << "deg of sig: " << deg << "\n";
@


1.30
log
@output changes
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.29 2010/03/02 17:11:38 vsfgd Exp vsfgd $	*/
d31 1
a31 1
static char rcsid[] = "$Id: gpsi.C,v 1.29 2010/03/02 17:11:38 vsfgd Exp vsfgd $";
d86 1
a86 1
std::vector<int> rxmsglen;
d205 1
a205 1
	int Gflag, gflag, Lflag, lflag, rflag, Sflag, sflag, zflag, vflag, pflag, Hflag, dflag, jflag, mflag;
d219 1
a219 1
	Gflag = gflag = Lflag = lflag = rflag = Sflag = sflag = zflag = vflag = pflag = Hflag = dflag = jflag = mflag = 0;
d226 1
a226 1
	while ((ch = getopt(argc, argv, "d:G:gHhi:j:L:lmn:pq:rS:s:vz")) != -1)
d279 3
d302 10
d319 1
a319 1
			sleep(5);
d361 10
a383 1

d385 1
d390 1
a392 3
			srand(time(NULL));
			//srand(lshseed);

d398 1
a398 1
				int mc = 50;
d402 19
d424 5
a428 3
				warnx << "minhash IDs:\n";
				for (int i = 0; i < (int)minhash.size(); i++) {
					warnx << minhash[i] << "\n";
a431 1

d434 5
a438 2
			int range = (int)minhash.size() + 1;
			col = int((double)range*rand()/(RAND_MAX + 1.0));
d444 1
a444 1

a450 2
			srand(time(NULL));

d456 1
a456 1
				int mc = 50;
d463 5
a467 3
				warnx << "minhash IDs:\n";
				for (int i = 0; i < (int)minhash.size(); i++) {
					warnx << minhash[i] << "\n";
a470 1

d473 4
a476 1
			col = rand() % (int)minhash.size();
a486 11
	// set random local seed
	char host[256];
	struct timeval tv;
	unsigned int loseed;
	gethostname(host, 256);
	gettimeofday(&tv, NULL);
	loseed = ((long)tv.tv_sec + (long)tv.tv_usec) / (long)getpid();
	//warnx << "loseed: " << loseed << "\n";
	srandom(loseed);
	//srandom(time(NULL));

d505 1
d1434 1
a1434 1
	     << "	-d		<random prime number for seed>\n"
d1439 1
a1439 1
	     << "      	-m		use findMod instead of compute_hash\n"
d1444 2
a1445 1
	     << "	-s		<dir with sigs>\n\n"
@


1.29
log
@change log format again (for easier signature attributes parsing)
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.28 2010/02/23 22:35:32 vsfgd Exp vsfgd $	*/
d31 1
a31 1
static char rcsid[] = "$Id: gpsi.C,v 1.28 2010/02/23 22:35:32 vsfgd Exp vsfgd $";
d85 2
d481 2
a482 2
			warnx << "inserting:\ntxseq: "
			      << txseq.back() << "\ntxID: " << ID << "\n";
d757 1
a757 1
			warnx << "rxmsglen: " << msglen << "\n";
d763 1
a763 1
		warnx << "read_gossip: n: " << n << "\n";
d785 4
a788 3
	warnx << "rxlistlen: " << sigList.size() << "\n"
	      << "rxseq: " << seq << "\n"
	      << "rxID: " << key << "\n";
d793 6
d1189 2
a1190 4
	warnx << "\n";
	printdouble("printlist: multisetsize: ", sumsum);
	warnx << "\n";
	warnx << "printlist: setsize: " << allT[listnum].size() << "\n";
@


1.28
log
@output changes
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.27 2010/02/21 00:32:05 vsfgd Exp vsfgd $	*/
d31 1
a31 1
static char rcsid[] = "$Id: gpsi.C,v 1.27 2010/02/21 00:32:05 vsfgd Exp vsfgd $";
d61 1
a61 1
void printlist(int);
d353 1
a353 2
			warnx << "initial ";
			printlist(0);
d482 1
a482 2
				warnx << "gossiping merged ";
				printlist(0);
d882 1
a882 1
	warnx << "Size of sig list: " << sigList.size() << "\n";
d931 1
a931 1
	warnx << "calcfreq: Size of unique sig list: " << allT[0].size() << "\n";
d1006 1
a1006 1
			printlist(i);
a1126 1
	warnx << "splitting list T_" << listnum << ":\n";
d1134 1
a1134 1
	warnx << "splitfreq: Size of unique sig list: " << allT[listnum].size() << "\n";
d1149 1
a1149 1
printlist(int listnum)
d1151 1
d1158 2
a1159 2
	warnx << "list T_" << listnum << ":\n";
	warnx << "hdr: freq, weight, avg, avg*p, avg*(p-5), avg*(p+5)\n";
d1170 5
a1174 8
		warnx << "sig: " << sigbuf << "\n";

		printdouble("attr: ", freq);
		printdouble(", ", weight);
		printdouble(", ", avg);
		printdouble(", ", avg * peers);
		printdouble(", ", avg * (peers-5));
		printdouble(", ", avg * (peers+5));
d1176 1
d1178 2
a1179 2
	warnx << "hdr: freq, weight, avg, avg*p, avg*(p-5), avg*(p+5)\n";
	printdouble("printlist: Sum of avg: ", sumavg);
d1181 1
a1181 1
	printdouble("printlist: Sum of sum (multiset): ", sumsum);
d1183 1
a1183 1
	warnx << "printlist: Size of unique sig list (set): " << allT[listnum].size() << "\n";
@


1.27
log
@changes in merge_lists() and in output
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.26 2010/02/18 04:35:59 vsfgd Exp vsfgd $	*/
d31 1
a31 1
static char rcsid[] = "$Id: gpsi.C,v 1.26 2010/02/18 04:35:59 vsfgd Exp vsfgd $";
d452 2
a453 1
	warnx << "date: " << ctime(&rawtime);
d467 1
a467 1
		warnx << "interval: " << intval << " sec\n";
d481 1
a481 1
			      << txseq.back() << ", txID: " << ID << "\n";
d757 1
a757 1
			warnx << "msglen: " << msglen;
d763 1
a763 1
		warnx << "\nread_gossip: n: " << n << "\n";
d785 3
a787 2
	warnx << ", listlen: " << sigList.size() << ", rxseq: " << seq
	      << ", rxID: " << key << "\n";
d1161 1
d1174 6
a1179 6
		printdouble("freq: ", freq);
		printdouble(", weight: ", weight);
		printdouble(", avg: ", avg);
		printdouble(", avg*p: ", avg * peers);
		printdouble(", avg*p-5: ", avg * (peers-5));
		printdouble(", avg*p+5: ", avg * (peers+5));
d1182 1
@


1.26
log
@many changes:
- cleaner log output
- more info in log
- algo 2 from draft implemented (merge_lists()...)
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.25 2010/01/30 23:12:03 vsfgd Exp vsfgd $	*/
d31 1
a31 1
static char rcsid[] = "$Id: gpsi.C,v 1.25 2010/01/30 23:12:03 vsfgd Exp vsfgd $";
d42 1
d204 1
d218 1
d224 1
a224 1
	while ((ch = getopt(argc, argv, "d:G:gHhi:j:L:lmn:prS:s:vz")) != -1)
d263 3
d456 1
d784 2
a785 1
	warnx << ", rxseq: " << seq << ", rxID: " << key << "\n";
d787 2
a788 3
	warnx << "sigList size: " << sigList.size()
	      << ", freqList size: " << freqList.size()
	      << ", weightList size: " << weightList.size() << "\n";
d931 1
a931 1
	warnx << "Size of unique sig list: " << allT[0].size() << "\n";
d952 1
a952 1
	warnx << "Size of unique sig list: " << allT[0].size() << "\n";
d997 1
a997 1
	warnx << "merge_lists:\n";
d1004 1
d1007 1
d1010 1
a1017 1
	warnx << "merging:\n";
d1023 1
a1023 1
				warnx << "end of T_" << i << "\n";
d1047 1
d1051 1
d1059 1
d1062 1
d1067 2
a1068 1
			// skip lists which are done
d1070 5
a1074 1
				continue;
d1076 1
a1076 1
				warnx << "minsig found in T_" << i << "\n";
d1079 1
a1079 1
				// XXX: if i == 0, itr will be incremented later
d1082 1
a1082 2
				warnx << "no minsig in T_" << i << "\n";
				// or use find()?
d1088 1
d1092 1
d1097 1
a1097 1
			warnx << "updating sums of minsig\n";
a1101 2
			//citr[0]->second[0] = sumf / 2;
			//citr[0]->second[1] = sumw / 2;
d1104 1
a1104 1
			warnx << "inserting minsig...\n";
d1108 3
a1110 1
			// XXX: point to the sig immediately following the inserted one
d1135 1
a1135 1
	warnx << "Size of unique sig list: " << allT[listnum].size() << "\n";
d1152 3
a1154 1
	double freq, weight, avg, n = 0;
d1158 1
a1158 1
	warnx << "printing list T_" << listnum << ":\n";
d1165 2
a1166 1
		n += avg;
d1174 3
d1179 5
a1183 2
	printdouble("Size of sig list: ", n);
	warnx << ", Size of unique sig list: " << allT[listnum].size() << "\n";
d1399 1
@


1.25
log
@deleted old commented code
merged freq and weight lists (use vector as value in map)
fixed splitfreq (don't add halves, just halve it)
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.24 2010/01/30 20:25:39 vsfgd Exp vsfgd $	*/
d31 1
a31 1
static char rcsid[] = "$Id: gpsi.C,v 1.24 2010/01/30 20:25:39 vsfgd Exp vsfgd $";
d47 2
d51 1
a51 1
void accept_connection(int);
d56 1
d60 1
a60 1
void printlist(void);
d62 1
a62 1
void splitfreq(void);
d76 6
a81 1
std::map<std::vector<POLY>, std::vector<double>, CompareSig> uniqueSigList;
d87 1
a87 1
std::vector<std::map<std::vector<POLY>, std::vector<double>, CompareSig> > allt;
d333 7
d346 4
a349 1
		if (plist == 1) printlist();
a469 1
			warnx << "inserting:\ntxseq: " << txseq.back() << "\n";
d471 8
a478 1
			makeKeyValue(&value, valLen, key, uniqueSigList, txseq.back(), GOSSIP);
a487 2
				splitfreq();
				if (plist == 1) printlist();
d491 1
d514 1
a514 1
	warnx << "key: " << ID << "\n";
d553 1
d635 1
a635 1
// deprecated (use make_randomID() instead)
d749 1
a749 1
			warnx << "read_gossip: msglen: " << msglen << "\n";
d755 1
a755 1
		warnx << "read_gossip: n: " << n << "\n";
d777 5
a781 5
	warnx << "rxseq: " << seq << "\n";
	warnx << "ID: " << key << "\n";
	warnx << "sigList size: " << sigList.size() << "\n";
	warnx << "freqList size: " << freqList.size() << "\n";
	warnx << "weightList size: " << weightList.size() << "\n";
d791 1
a791 2
		//snprintf(tmpbuf, sizeof(tmpbuf), "%f", freqList[i]);
		//warnx << "freq[" << i << "]: " << tmpbuf << "\n";
d795 1
a795 2
		//snprintf(tmpbuf, sizeof(tmpbuf), "%f", weightList[i]);
		//warnx << "weight[" << i << "]: " << tmpbuf << "\n";
d800 3
a802 2
	calcfreqM(sigList, freqList, weightList);
	if (plist == 1) printlist();
d850 1
a850 1
	warnx << "NUM sigs: " << numSigs << "\n";
d857 1
a857 1
		warnx << "invalid signature\n";
d859 1
a859 1
	warnx << "Signature size: " << size * sizeof(POLY) << " bytes\n";
a862 5
	// dummy sig
	// the polynomial "1" has a degree 0
	//sig.push_back(1);
	//sigList.push_back(sig);
	sig.clear();
d897 1
d901 2
a902 2
	//uniqueSigList[sigList[0]].push_back(0);
	//uniqueSigList[sigList[0]].push_back(1);
d907 3
a909 2
	for (int i = 0; i < (int) sigList.size(); i++) {
		std::map<std::vector<POLY>, std::vector<double> >::iterator itr = uniqueSigList.find(sigList[i]);
d917 1
d919 1
d923 2
a924 1
	warnx << "Size of unique sig list: " << uniqueSigList.size() << "\n";
d927 1
d934 4
a937 3
	for (int i = 0; i < (int) sigList.size(); i++) {
		std::map<std::vector<POLY>, std::vector<double> >::iterator itr = uniqueSigList.find(sigList[i]);
		if (itr != uniqueSigList.end()) {
d941 2
a942 2
			uniqueSigList[sigList[i]].push_back(freqList[i]);
			uniqueSigList[sigList[i]].push_back(weightList[i]);
d945 15
a959 1
	warnx << "Size of unique sig list: " << uniqueSigList.size() << "\n";
d961 19
a981 1
// for mass conservation
d983 122
a1104 1
splitfreq(void)
d1108 2
a1109 1
	for (std::map<std::vector<POLY>, std::vector<double> >::iterator itr = uniqueSigList.begin(); itr != uniqueSigList.end(); itr++) {
d1116 1
a1116 1
	warnx << "Size of unique sig list: " << uniqueSigList.size() << "\n";
d1127 1
a1127 1
	warnx << fmt.c_str() << ss.c_str() << "\n";
d1131 1
a1131 1
printlist(void)
d1133 1
a1133 1
	double freq, weight, avg;
a1135 1
	int n = 0;
d1137 2
a1138 2
	warnx << "uniqueSigList:\n";
	for (std::map<std::vector<POLY>, std::vector<double> >::iterator itr = uniqueSigList.begin(); itr != uniqueSigList.end(); itr++) {
d1144 1
a1144 1
		n += (int)avg;
d1150 3
a1152 2
		printdouble("weight: ", weight);
		printdouble("avg: ", avg);
d1154 2
a1155 2
	warnx << "Size of sig list: " << n << "\n";
	warnx << "Size of unique sig list: " << uniqueSigList.size() << "\n";
@


1.24
log
@testing lsh and dummies
before major changes implementing pseudo code from draft paper
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.23 2010/01/20 00:41:03 vsfgd Exp vsfgd $	*/
d31 1
a31 1
static char rcsid[] = "$Id: gpsi.C,v 1.23 2010/01/20 00:41:03 vsfgd Exp vsfgd $";
a42 6
//int getKeyValueLen(const char*);
//void getKeyValue(const char*, str&, std::vector<std::vector<POLY> >&, std::vector<double>&, std::vector<double>&, int&);
//void makeKeyValue(char **, int&, str&, std::map<std::vector<POLY>, double, CompareSig>&, std::map<std::vector<POLY>, double, CompareSig>&, int&, InsertType);
//int getKeyValue(const char*, str&, std::vector<POLY>&, double&, int&, int);
//void makeKeyValue(char **, int&, str&, std::vector<POLY>&, double&, int&, InsertType);

d73 3
a75 2
std::map<std::vector<POLY>, double, CompareSig> uniqueSigList;
std::map<std::vector<POLY>, double, CompareSig> uniqueWeightList;
d79 2
a286 1
			//ID = randomID();
a445 1
			//ID = randomID();
d454 1
a454 1
			makeKeyValue(&value, valLen, key, uniqueSigList, uniqueWeightList, txseq.back(), GOSSIP);
d611 1
a611 1
// TODO: verify randomness
a817 7
	// open tags
	//tagsfile = sigfile + std::string(TAGFILE);
	//warnx << "opening tagsfile: " << tagsfile.c_str() << "...\n";
	//tagsfp = fopen(tagsfile.c_str(), "r");
	// change to if?
	//assert(tagsfp);

d842 2
a843 2
	sig.push_back(1);
	sigList.push_back(sig);
a859 74

	/*
	char hostname[64];
	gethostname(hostname, sizeof(hostname));
#ifdef _LIVE_
	strcpy(hostname, "");
#endif
	// TODO: add docidType arg?
	char docId[128];
	// Read the document id
	int len;
	// len of docid string includes \0
	if (fread(&len, sizeof(len), 1, sigfp) != 1) {
		assert(0);
	}

	if (fread(&docId, len, 1, sigfp) != 1) {
		assert(0);
	}
	// XXX: add the hostname
	strcat(docId, ".");
	strcat(docId, hostname);
	strcat(docId, "#");

	//warnx << "**********************************************************\n";
	//warnx << "*            Inserting document " << docId << " ********\n";
	//warnx << "**********************************************************\n";

	// Read the distinct tags
	std::vector<std::string> distinctTags;
	distinctTags.clear();

	readTags(tagsfp, distinctTags);

	// Each H-index based on tagname!
	for (int ts = 0; ts < (int) distinctTags.size(); ts++) {
		// Do not insert for attributes
		if (distinctTags[ts].find(ATTRSUFFIX) != std::string::npos) {
			continue;
		}
		INDEXNAME = distinctTags[ts];

		// is REPLICAID needed?
		std::string root = INDEXNAME + std::string(ROOTNODEID);
		//std::string root = INDEXNAME + std::string(ROOTNODEID) + std::string(REPLICAID);
		//warnx << "********* H-index chosen for inserting signature:  " << distinctTags[ts].c_str() << " ********** \n";
		rootNodeID = compute_hash(root.c_str(), root.length());
		//warnx << "Root node id for index " << INDEXNAME.c_str() << " : " << rootNodeID << "\n";

		// ROOT node id			
		strbuf s;
		s << rootNodeID;
		str rootID(s);

		//warnx << "ROOT ID: " << rootID << "\n";
#ifdef _DEBUG_
		for (int l = 0; l < (int) sig.size(); l++) {
			warnx << sig[l] << " ";
		}
		//warnx << "\n";
#endif
	}
	fclose(sigfp);
	fclose(tagsfp);

	//warnx << "Data read in bytes: " << dataFetched << "\n";
	//warnx << "Data written in bytes: " << dataStored << "\n";
	//warnx << "Number of documents inserted: " << 1 << "\n";
	// TODO: count?
	//warnx << "Number of documents inserted: " << count - 1 << "\n";
	//warnx << "Number of full nodes: " << cacheOfFullNodes.size() << "\n";
	finishTime = getgtod();
	//std::cerr << "Time taken to process XML tags: " << finishTime - startTime << " secs " << std::endl;
	*/
d882 2
a883 2
	uniqueSigList[sigList[0]] = 0;
	uniqueWeightList[sigList[0]] = 1;
d888 2
a889 3
	// skip dummy sig
	for (int i = 1; i < (int) sigList.size(); i++) {
		std::map<std::vector<POLY>, double >::iterator itr = uniqueSigList.find(sigList[i]);
d893 1
a893 1
			itr->second += 1;
d897 2
a898 2
			uniqueSigList[sigList[i]] = 1;
			uniqueWeightList[sigList[i]] = 1;
a901 1
	warnx << "Size of unique weight list: " << uniqueWeightList.size() << "\n";
a908 1
	// skip dummy sig
d910 2
a911 3
	for (int i = 1; i < (int) sigList.size(); i++) {
		std::map<std::vector<POLY>, double >::iterator itr = uniqueSigList.find(sigList[i]);
		std::map<std::vector<POLY>, double >::iterator itrW = uniqueWeightList.find(sigList[i]);
d913 2
a914 3
			itr->second += freqList[i];
			itrW->second += weightList[i];
			//warnx << "sig: " << buf << "\nfreq: " << itr->second << "\n";
d916 2
a917 3
			uniqueSigList[sigList[i]] = freqList[i];
			uniqueWeightList[sigList[i]] = weightList[i];
			//warnx << "sig: " << buf << "\nfreq: " << uniqueSigList[sigList[i]] << "\n";
a920 1
	warnx << "Size of unique weight list: " << uniqueWeightList.size() << "\n";
d930 6
a935 10
	std::map<std::vector<POLY>, double>::iterator itrW = uniqueWeightList.begin();
	for (std::map<std::vector<POLY>, double>::iterator itr = uniqueSigList.begin();
	     itr != uniqueSigList.end(); itr++) {

		// first check if end of weightList?
		freq = itr->second;
		itr->second += freq / 2;
		weight = itrW->second;
		itrW->second += weight / 2;
		++itrW;
a937 3
	warnx << "Size of unique weight list: " << uniqueWeightList.size() << "\n";
	//warnx << "Size of unique sig list: " << uniqueSigList.size() - 1 << "\n";
	//warnx << "Size of unique weight list: " << uniqueWeightList.size() - 1 << "\n";
d960 1
a960 3
	std::map<std::vector<POLY>, double>::iterator itrW = uniqueWeightList.begin();
	for (std::map<std::vector<POLY>, double>::iterator itr = uniqueSigList.begin();
	     itr != uniqueSigList.end(); itr++) {
a961 1
		// first check if end of weightList?
d963 2
a964 2
		freq = itr->second;
		weight = itrW->second;
a966 1
		++itrW;
a971 3
		//snprintf(buf, sizeof(buf), "%f", freq);
		//warnx << "freq: " << buf << "\n";

a972 3
		//snprintf(buf, sizeof(buf), "%f", weight);
		//warnx << "weight: " << buf << "\n";

a973 2
		//snprintf(buf, sizeof(buf), "%f", avg);
		//warnx << "avg: " << buf << "\n";
a976 3
	warnx << "Size of unique weight list: " << uniqueWeightList.size() << "\n";
	//warnx << "Size of unique sig list: " << uniqueSigList.size() - 1 << "\n";
	//warnx << "Size of unique weight list: " << uniqueWeightList.size() - 1 << "\n";
@


1.23
log
@merged dipali's lsh code (1st revision)
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.22 2010/01/12 23:06:36 vsfgd Exp vsfgd $	*/
d31 1
a31 1
static char rcsid[] = "$Id: gpsi.C,v 1.22 2010/01/12 23:06:36 vsfgd Exp vsfgd $";
d197 1
a197 1
	int Gflag, gflag, Lflag, lflag, rflag, Sflag, sflag, zflag, vflag, pflag, Hflag, dflag;
d201 1
d210 1
a210 1
	Gflag = gflag = Lflag = lflag = rflag = Sflag = sflag = zflag = vflag = pflag = Hflag = dflag = 0;
d212 1
d216 1
a216 1
	while ((ch = getopt(argc, argv, "d:G:gHhi:L:ln:prS:s:vz")) != -1)
d235 4
d246 3
d310 1
a310 1
	if (Hflag == 1 && sflag == 0 && dflag == 0) usage();
d339 39
a377 23
	if (Hflag == 1 && dflag != 0 && sflag != 0) {
		std::vector<chordID> minhash;
		std::vector<std::vector<chordID> > matrix;
		std::vector<POLY> sig;
		int col;

		srand(time(NULL));

		for (int i = 0; i < (int)sigList.size(); i++) {
			sig = sigList[i];
			int kc = sig.size();
			warnx << "kc: " << kc << "\n";
			int lc = 10;
			int mc = 50;
			int nc = lshseed;

			lsh *myLSH = new lsh(kc, lc, mc, nc);
			minhash = myLSH->getHashCode(sig);

			warnx << "minhash.size(): " << minhash.size() << "\n";
			warnx << "minhash IDs:\n";
			for (int i = 0; i < (int)minhash.size(); i++) {
				warnx << minhash[i] << "\n";
d380 24
a403 1
			matrix.push_back(minhash);
d405 5
a409 3
			delete myLSH;
		}
		col = rand() % (int)minhash.size();
d411 4
a414 3
		warnx << "chordIDs in random column " << col << ":\n";
		for (int i = 0; i < (int)matrix.size(); i++) {
			warnx << matrix[i][col] << "\n";;
d852 5
d967 3
a969 6
	// add dummy sig
	//std::vector<POLY> sig;
	//sig.clear();
	// the polynomial "1" has a degree 0
	//sig.push_back(1);
	//sigList.push_back(sig);
d974 2
a975 1
	for (int i = 0; i < (int) sigList.size(); i++) {
d979 1
a989 2
	//warnx << "Size of unique sig list: " << uniqueSigList.size() - 1 << "\n";
	//warnx << "Size of unique weight list: " << uniqueWeightList.size() - 1 << "\n";
d997 1
d999 1
a999 1
	for (int i = 0; i < (int) sigList.size(); i++) {
a1002 2
			// don't merge the peer's dummy freq with your own dummy's freq
			//if ((deg = getDegree(sigList[i])) == 0) continue;
a1013 2
	//warnx << "Size of unique sig list: " << uniqueSigList.size() - 1 << "\n";
	//warnx << "Size of unique weight list: " << uniqueWeightList.size() - 1 << "\n";
d1302 1
d1304 1
d1311 1
a1311 1
	     << "	-H		generate chordIDs using LSH (requires -s, -d)\n"
@


1.22
log
@changed seed to include only seconds since epoch divided by pid
verified that seed is random
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.21 2010/01/11 17:32:05 vsfgd Exp vsfgd $	*/
d31 1
a31 1
static char rcsid[] = "$Id: gpsi.C,v 1.21 2010/01/11 17:32:05 vsfgd Exp vsfgd $";
a213 11
	// set random local seed
	char host[256];
	struct timeval tv;
	unsigned int loseed;
	gethostname(host, 256);
	gettimeofday(&tv, NULL);
	loseed = ((long)tv.tv_sec + (long)tv.tv_usec) / (long)getpid();
	//warnx << "loseed: " << loseed << "\n";
	srandom(loseed);
	//srandom(time(NULL));

a289 33
	if (Hflag == 1 && dflag != 0 && sflag != 0) {
		std::vector<chordID> minhash;
		std::vector<POLY> sig;

		getdir(sigdir, sigfiles);
		sigList.clear();
		warnx << "reading signatures from files...\n";
		for (unsigned int i = 0; i < sigfiles.size(); i++) {
			readsig(sigfiles[i], sigList);
		}

		// TODO
		sig = sigList[0];
		int kc = sig.size();
		warnx << "kc: " << kc << "\n";
		int lc = 100;
		int mc = 500;
		int nc = lshseed;

		lsh *myLSH = new lsh(kc, lc, mc, nc);
		minhash = myLSH->getHashCode(sig);

		warnx << "minhash.size(): " << minhash.size() << "\n";
		warnx << "minhash IDs:\n";
		for (int i = 0; i < (int) minhash.size(); i++) {
			warnx << minhash[i] << "\n";
		}

		delete myLSH;

		return 0;
	}

d291 2
a292 2
	// read, gossip or listen
	if (rflag == 0 && gflag == 0 && lflag == 0) usage();
d301 1
d317 1
a317 1
	if (rflag == 1 || gflag == 1) {
d329 51
d418 2
a419 2
				//splitfreq();
				//if (plist == 1) printlist();
d795 1
d1259 1
a1259 1
	     << "	-H		generate chordIDs using LSH (requires -s)\n"
@


1.21
log
@changed random seed from time() to unique
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.20 2009/12/30 22:26:00 vsfgd Exp vsfgd $	*/
d31 1
a31 1
static char rcsid[] = "$Id: gpsi.C,v 1.20 2009/12/30 22:26:00 vsfgd Exp vsfgd $";
d198 1
a198 1
	int ch, intval, nids, seed, valLen;
d210 1
a210 1
	intval = nids = seed = 0;
d213 3
a215 2
	// generate a unique seed (idea from ccrypt)
	char acc[512], host[256];
d217 1
d220 3
a222 5
	snprintf(acc, sizeof(acc), "%s,%ld,%ld,%ld", host, (long)tv.tv_sec,
		(long)tv.tv_usec, (long)getpid());
	//warnx << "acc: " << acc << "\n";
	//warnx << "uacc: " << (unsigned int)acc << "\n";
	srandom((unsigned int)acc);
d224 1
d229 1
a229 1
			seed = strtol(optarg, NULL, 10);
d318 1
a318 1
		int nc = seed;
d376 2
a377 2
	warnx << "acc: " << acc << "\n";
	warnx << "uacc: " << (unsigned long)acc << "\n";
@


1.20
log
@less output (use DEBUG)
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.19 2009/12/28 23:48:25 vsfgd Exp vsfgd $	*/
d31 1
a31 1
static char rcsid[] = "$Id: gpsi.C,v 1.19 2009/12/28 23:48:25 vsfgd Exp vsfgd $";
d197 2
a198 2
	int Gflag, gflag, Lflag, lflag, rflag, Sflag, sflag, zflag, vflag, pflag;
	int ch, intval, nids, valLen;
d209 2
a210 2
	Gflag = gflag = Lflag = lflag = rflag = Sflag = sflag = zflag = vflag = pflag = 0;
	intval = nids = 0;
d213 12
a224 2
	srandom(time(NULL));
	while ((ch = getopt(argc, argv, "rG:ghi:L:ln:pS:s:zv")) != -1)
d226 4
d237 3
d241 1
a241 1
			intval = atoi(optarg);
d251 1
a251 1
			nids = atoi(optarg);
d299 34
d374 3
d1239 1
a1239 1
	     << "	-S		<dhash socket>\n"
d1241 1
a1242 2
	     << "	-s		<dir with sigs>\n"
	     << "      	-i		<how often>\n"
d1244 3
a1246 1
	     << "      	-p		call printlist()\n\n"
d1248 4
d1253 1
a1253 4
	     << "	-r		read signatures (requires -s)\n"
	     << "	-z		generate random chordID (requires -n)\n"
	     << "	-l		listen for gossip (requires -S, -G, -L)\n"
	     << "	-g		gossip (requires -S, -G, -s, -i)\n";
@


1.19
log
@cast sizeof to int in arithmetic expressions
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.18 2009/12/28 23:42:59 vsfgd Exp vsfgd $	*/
d31 1
a31 1
static char rcsid[] = "$Id: gpsi.C,v 1.18 2009/12/28 23:42:59 vsfgd Exp vsfgd $";
a611 4
		warnx << "read_gossip: n: " << n << "\n";
		recvlen += n;
		warnx << "read_gossip: recvlen: " << recvlen << "\n";

d619 7
@


1.18
log
@many read_gossip changes:
keep reading from the socket
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.17 2009/12/21 16:25:47 vsfgd Exp vsfgd $	*/
d31 1
a31 1
static char rcsid[] = "$Id: gpsi.C,v 1.17 2009/12/21 16:25:47 vsfgd Exp vsfgd $";
d627 1
a627 1
	} while ((recvlen + sizeof(int)) < msglen);
@


1.17
log
@no changes
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.16 2009/12/18 15:16:46 vsfgd Exp vsfgd $	*/
d31 1
a31 1
static char rcsid[] = "$Id: gpsi.C,v 1.16 2009/12/18 15:16:46 vsfgd Exp vsfgd $";
d42 6
a48 4
void getKeyValue(const char*, str&, std::vector<std::vector<POLY> >&, std::vector<double>&, std::vector<double>&, int&);
void makeKeyValue(char **, int&, str&, std::map<std::vector<POLY>, double, CompareSig>&, std::map<std::vector<POLY>, double, CompareSig>&, int&, InsertType);
void getKeyValue(const char*, str&, std::vector<POLY>&, double&, int&);
void makeKeyValue(char **, int&, str&, std::vector<POLY>&, double&, int&, InsertType);
d50 1
a50 1
void retrieveDHT(chordID ID, int, str&, chordID guess = 0);
d362 3
d529 2
d545 1
a545 2
	} else {
		fdcb(fd, selread, wrap(accept_connection, fd));
d547 3
d554 1
a554 1
accept_connection(int lfd)
d560 1
a560 1
	int cs = accept(lfd, (struct sockaddr *) &sin, &sinlen);
d564 3
a566 1
		warnx << "accept error: errno=" << strerror(errno) << "\n";
d577 1
d582 40
a621 1
	int n, seq;
d623 5
a627 5
	n = buf.tosuio()->input(fd);
	if (n < 0) {
		warnx << "read_gossip: read failed\n";
		return;
	}
d629 7
a635 2
	if (n == 0) {
		warnx << "read_gossip: no more to read\n";
d637 1
a637 4
		// do you have to close?
		//close(fd);
		// what's the difference?
		// exit(0);
a639 5
	str gElem(buf);
	sigList.clear();
	freqList.clear();
	weightList.clear();
	getKeyValue(gElem.cstr(), key, sigList, freqList, weightList, seq);
d641 2
a642 2
	warnx << "reading from socket:\nrxseq: " << seq << "\nID: "
	      << key << "\n";
@


1.16
log
@commented pthread
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.15 2009/12/02 16:40:11 vsfgd Exp vsfgd $	*/
d31 1
a31 1
static char rcsid[] = "$Id: gpsi.C,v 1.15 2009/12/02 16:40:11 vsfgd Exp vsfgd $";
d51 2
a52 1
void *listen_gossip(void *);
d364 2
a365 1
		listen_gossip(NULL);
d524 2
a525 2
void *
listen_gossip(void *arg)
d541 1
a541 1
	return NULL;
@


1.15
log
@fdcb logic change
dhash_ make_async()
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.14 2009/12/02 03:32:32 vsfgd Exp vsfgd $	*/
d22 2
d31 1
a31 1
static char rcsid[] = "$Id: gpsi.C,v 1.14 2009/12/02 03:32:32 vsfgd Exp vsfgd $";
d51 1
a51 1
void listen_gossip(void);
d74 2
d191 3
d323 2
d341 1
d343 1
d356 1
d363 1
a363 1
		listen_gossip();		
d522 2
a523 2
void
listen_gossip(void)
d539 1
d827 1
d847 1
@


1.14
log
@don't close fd when done reading from socket
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.13 2009/12/01 04:26:16 vsfgd Exp vsfgd $	*/
d29 1
a29 1
static char rcsid[] = "$Id: gpsi.C,v 1.13 2009/12/01 04:26:16 vsfgd Exp vsfgd $";
d524 2
a526 1
	fdcb(fd, selread, wrap(accept_connection, fd));
@


1.13
log
@changes in socket setup
no splitfreq (no mass conservation)
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.12 2009/12/01 02:04:11 vsfgd Exp vsfgd $	*/
d29 1
a29 1
static char rcsid[] = "$Id: gpsi.C,v 1.12 2009/12/01 02:04:11 vsfgd Exp vsfgd $";
d536 1
a536 1
	if (cs >= 0)
d538 1
a538 1
	else if (errno != EAGAIN) {
d558 1
a558 1
		warnx << "read_gossip: read failed" << "\n";
d563 1
d565 2
a566 1
		close(fd);
@


1.12
log
@printlist is command line option now
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.11 2009/11/30 20:04:01 vsfgd Exp vsfgd $	*/
d29 1
a29 1
static char rcsid[] = "$Id: gpsi.C,v 1.11 2009/11/30 20:04:01 vsfgd Exp vsfgd $";
d341 2
a342 2
				splitfreq();
				if (plist == 1) printlist();
d521 1
d531 5
a535 5
	sockaddr_un sun;
	bzero(&sun, sizeof(sun));
	socklen_t sunlen = sizeof(sun);
	// vs "struct sockaddr *"
	int cs = accept(lfd, reinterpret_cast<sockaddr *> (&sun), &sunlen);
d537 1
a537 1
		warnx << "accepted connection on local socket\n";
d539 1
a539 1
		warnx << "accept: errno = " << strerror(errno) << "\n";
@


1.11
log
@use printdouble() to print doubles
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.10 2009/11/22 19:56:27 vsfgd Exp vsfgd $	*/
d26 1
a26 1
#define _DEBUG_
d29 1
a29 1
static char rcsid[] = "$Id: gpsi.C,v 1.10 2009/11/22 19:56:27 vsfgd Exp vsfgd $";
d39 1
d187 1
a187 1
	int Gflag, gflag, Lflag, lflag, rflag, Sflag, sflag, zflag, vflag;
d199 1
a199 1
	Gflag = gflag = Lflag = lflag = rflag = Sflag = sflag = zflag = vflag = 0;
d204 1
a204 1
	while ((ch = getopt(argc, argv, "rG:ghi:L:ln:S:s:zv")) != -1)
d226 3
d291 2
d307 1
a307 1
		printlist();
d342 1
a342 1
				printlist();
d600 1
a600 1
	printlist();
d1118 2
a1119 1
	     << "      	-n		<how many>\n\n"
@


1.10
log
@replaced fatal with warnx
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.9 2009/11/22 15:58:59 vsfgd Exp vsfgd $	*/
d4 1
a5 1
#include <dirent.h>
d9 5
a13 2
#include <stdio.h>
#include <string.h>
a15 2
#include <vector>
//#include <sstream>
d26 1
a26 1
//#define _DEBUG_
d29 1
a29 1
static char rcsid[] = "$Id: gpsi.C,v 1.9 2009/11/22 15:58:59 vsfgd Exp vsfgd $";
d58 1
a201 3
	//random_init();
	//u_long seed = time(NULL);
	//srandom(seed);
d301 1
a301 1
		//printlist();
d336 1
a336 1
				//printlist();
d392 4
a395 3
		char timebuf[1024];
		snprintf(timebuf, sizeof(timebuf), "%f", endTime - beginTime);
		warnx << "key insert time: " << timebuf << " secs\n";
a574 3
	// XXX
	//char tmpbuf[255];
	//std::ostringstream oss;
d581 1
a581 3
		//oss << freqList[i];
		//warnx << "freq[" << i << "]: " << oss.str() << "\n";
		//oss.flush();
d586 1
a586 3
		//oss << weightList[i];
		//warnx << "weight[" << i << "]: " << oss.str() << "\n";
		//oss.flush();
d594 1
a594 1
	//printlist();
d849 11
a863 3
	// XXX
	//char buf[255];
	//std::ostringstream oss;
d865 1
d877 1
d882 2
a884 2
		//oss << freq;
		//warnx << "freq: " << oss.str() << "\n";
d886 2
a887 1
		//oss.flush();
a888 2
		//oss << weight;
		//warnx << "weight: " << oss.str() << "\n";
d890 2
a891 1
		//oss.flush();
a892 2
		//oss << avg;
		//warnx << "avg: " << oss.str() << "\n";
a893 1
		//oss.flush();
d895 1
@


1.9
log
@call srandom before make_randomID
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.8 2009/11/18 21:31:56 vsfgd Exp vsfgd $	*/
d28 1
a28 1
static char rcsid[] = "$Id: gpsi.C,v 1.8 2009/11/18 21:31:56 vsfgd Exp vsfgd $";
d529 6
a534 2
	if (cs >= 0) warnx << "accepted connection on local socket\n";
	else if (errno != EAGAIN) fatal << "accept; errno = " << errno << "\n";
d550 4
a553 1
	if (n < 0) fatal << "read failed" << "\n";
@


1.8
log
@hadn't replaced all randomID() calls with make_randomID()
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.7 2009/11/18 19:55:21 vsfgd Exp vsfgd $	*/
d28 1
a28 1
static char rcsid[] = "$Id: gpsi.C,v 1.7 2009/11/18 19:55:21 vsfgd Exp vsfgd $";
d200 4
d307 1
a307 1
	warnx << "rcsid: " << rcsid;
d489 1
d793 4
a796 2
	warnx << "Size of unique sig list: " << uniqueSigList.size() - 1 << "\n";
	warnx << "Size of unique weight list: " << uniqueWeightList.size() - 1 << "\n";
d819 4
a822 2
	warnx << "Size of unique sig list: " << uniqueSigList.size() - 1 << "\n";
	warnx << "Size of unique weight list: " << uniqueWeightList.size() - 1 << "\n";
d842 4
a845 2
	warnx << "Size of unique sig list: " << uniqueSigList.size() - 1 << "\n";
	warnx << "Size of unique weight list: " << uniqueWeightList.size() - 1 << "\n";
d888 4
a891 2
	warnx << "Size of unique sig list: " << uniqueSigList.size() - 1 << "\n";
	warnx << "Size of unique weight list: " << uniqueWeightList.size() - 1 << "\n";
@


1.7
log
@too many changes to list
latest changes:
- use make_randomID() instead of randomID()
- raise the number of concurrent connections from 5 to 128
- disable printing of uniqueSigList
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.6 2009/10/07 04:23:42 vsfgd Exp vsfgd $	*/
d28 1
a28 1
static char rcsid[] = "$Id: gpsi.C,v 1.6 2009/10/07 04:23:42 vsfgd Exp vsfgd $";
d184 1
a184 1
	int Gflag, gflag, Lflag, lflag, rflag, Sflag, sflag, zflag;
d196 1
a196 1
	Gflag = gflag = Lflag = lflag = rflag = Sflag = sflag = zflag = 0;
d200 1
a200 1
	while ((ch = getopt(argc, argv, "rG:ghi:L:ln:S:s:z")) != -1)
d236 3
d248 5
d314 2
a315 1
			ID = randomID();
d1093 1
@


1.6
log
@planetlab ready, basic case, (no tabs)
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.5 2009/10/07 04:19:53 vsfgd Exp vsfgd $	*/
d14 1
d28 1
a28 1
//static char rcsid[] = "$Id: gpsi.C,v 1.5 2009/10/07 04:19:53 vsfgd Exp vsfgd $";
d57 1
d184 2
a185 1
	int ch, intval, fflag, Gflag, gflag, lflag, Sflag, sflag, valLen;
a186 1
	char *name;
d196 5
a200 2
	fflag = Gflag = gflag = lflag = Sflag = sflag = intval = 0;
	while ((ch = getopt(argc, argv, "fG:ghi:L:lS:s:")) != -1)
a201 3
		case 'f':
			fflag = 1;
			break;
d213 1
d219 6
d233 3
d245 46
a290 22
	// required flags
	if (Gflag == 0 || Sflag == 0 || sflag == 0) usage();

	// FIXME: make sure only one flag is set at a time
	if (fflag == 0 && gflag == 0 && lflag == 0) usage();

	// check intval bound
	if (gflag == 1 && intval == 0) usage();

	logfd = open(logfile, O_RDWR | O_CREAT, 0666);
	if (logfd < 0) fatal << "can't open log file " << logfile << "\n";
	lseek(logfd, 0, SEEK_END);
	errfd = logfd;

	if (stat(dsock, &statbuf) != 0) fatal << "socket does not exist" << "\n";
	dhash = New dhashclient(dsock);

	getdir(sigdir, sigfiles);
	sigList.clear();
	warnx << "reading signatures from files...\n";
	for (unsigned int i = 0; i < sigfiles.size(); i++) {
		readsig(sigfiles[i], sigList);
a292 3
	warnx << "calculating frequencies...\n";
	calcfreq(sigList);

d294 2
a295 1
	warnx << ctime(&rawtime);
d298 1
a298 1
		//std::cout << "starting to listen...\n";
a299 1
		//std::cout << "starting to gossip...\n";
d301 2
a303 2
		rxseq.clear();
		txseq.clear();
a309 1
			str buf;
a313 1
			//makeKeyValue(&value, valLen, key, uniqueSigList, w, txseq.back(), GOSSIP);
d318 8
a325 2
			if (status != SUCC) fatal("insert FAILed\n");
			else warnx << "insert SUCCeeded\n";
a326 2

			//std::cout << "waiting " << intval << " seconds...\n";
d329 2
a330 10
	} else if (fflag == 1) {
		str junk("");
		name = argv[3];
		str2chordID(name, ID);
		retrieveDHT(ID, RTIMEOUT, junk);

		if (retrieveError) {
			delete dhash;
			fatal("Unable to read node ID\n");
		}
d332 1
a332 1
		rxseq.clear();
d380 1
a380 1
		char timebuf[255];
d474 1
d478 1
d481 2
d484 2
d500 1
a500 1
	if (listen(fd, 5) < 0) {
d555 2
a556 1
	char tmpbuf[255];
d563 5
a567 2
		snprintf(tmpbuf, sizeof(tmpbuf), "%f", freqList[i]);
		warnx << "freq[" << i << "]: " << tmpbuf << "\n";
d570 5
a574 2
		snprintf(tmpbuf, sizeof(tmpbuf), "%f", weightList[i]);
		warnx << "weight[" << i << "]: " << tmpbuf << "\n";
d580 1
a580 1
	printlist();
d643 1
a643 1
	warnx << "Signature size: " << size << "\n";
d746 1
a746 1
		s << sig[i] << ".";
d755 11
a765 1
	//str buf;
a768 1
		//sig2str(sigList[i], buf);
d770 1
a771 2
			// increment weight too?
			//warnx << "sig: " << buf << "\nfreq: " << itr->second << "\n";
d773 2
a776 1
			//warnx << "sig: " << buf << "\nfreq: " << uniqueSigList[sigList[i]] << "\n";
a777 1
		//warnx << "Size of unique sig list: " << uniqueSigList.size() << "\n\n";
d779 2
a780 2
	warnx << "Size of unique sig list: " << uniqueSigList.size() << "\n";
	warnx << "Size of unique weight list: " << uniqueWeightList.size() << "\n";
d786 1
a786 1
	//str buf;
a790 1
		//sig2str(sigList[i], buf);
d792 2
a801 1
		//warnx << "Size of unique sig list: " << uniqueSigList.size() << "\n\n";
d803 23
a825 2
	warnx << "Size of unique sig list: " << uniqueSigList.size() << "\n";
	warnx << "Size of unique weight list: " << uniqueWeightList.size() << "\n";
d832 1
d834 2
a835 2
	std::vector<POLY> sig;
	char buf[255];
d852 15
a866 6
		snprintf(buf, sizeof(buf), "%f", freq);
		warnx << "freq: " << buf << "\n";
		snprintf(buf, sizeof(buf), "%f", weight);
		warnx << "weight: " << buf << "\n";
		snprintf(buf, sizeof(buf), "%f", avg);
		warnx << "avg: " << buf << "\n";
d868 2
a869 1

d1075 13
a1087 1
	warn << "usage: " << __progname << " [-h] [-S dhash-sock] [-G g-sock] [-L logfile] [-s sigdir] [-f | -l | -g [-i interval in sec]]\n";
@


1.5
log
@planetlab, basic case, (with tabs)
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.4 2009/08/19 04:52:35 vsfgd Exp vsfgd $	*/
d27 1
a27 1
//static char rcsid[] = "$Id: gpsi.C,v 1.4 2009/08/19 04:52:35 vsfgd Exp vsfgd $";
d264 1
a264 1
		std::cout << "starting to listen...\n";
d266 1
a266 1
		std::cout << "starting to gossip...\n";
d281 1
a281 1
			warnx << "inserting:\n\ttxseq: " << txseq.back() << "\n";
d318 1
a318 1
	warnx << "\tkey: " << ID << "\n";
d514 1
a514 1
	warnx << "reading from socket:\n\trxseq: " << seq << "\n\tID: "
d516 3
a518 3
	warnx << "\tsigList size: " << sigList.size() << "\n";
	warnx << "\tfreqList size: " << freqList.size() << "\n";
	warnx << "\tweightList size: " << weightList.size() << "\n";
d526 1
a526 1
		warnx << "\tsig[" << i << "]: " << sigbuf << "\n";
d530 1
a530 1
		warnx << "\tfreq[" << i << "]: " << tmpbuf << "\n";
d534 1
a534 1
		warnx << "\tweight[" << i << "]: " << tmpbuf << "\n";
d781 1
a781 1
		warnx << "\tsig: " << sigbuf << "\n";
d783 1
a783 1
		warnx << "\tfreq: " << buf << "\n";
d785 1
a785 1
		warnx << "\tweight: " << buf << "\n";
d787 1
a787 1
		warnx << "\tavg: " << buf << "\n";
@


1.4
log
@before new makeKeyValue call
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.3 2009/08/10 06:30:57 vsfgd Exp vsfgd $	*/
d24 1
a24 1
#define _DEBUG_
d27 1
a27 1
//static char rcsid[] = "$Id: gpsi.C,v 1.3 2009/08/10 06:30:57 vsfgd Exp vsfgd $";
d36 1
d38 2
a39 2
//void getKeyValue(const char*, str&, std::map<std::vector<POLY>, double, CompareSig>&, int&);
void makeKeyValue(char **, int&, str&, std::map<std::vector<POLY>, double, CompareSig>&, int&, InsertType);
d53 1
d55 1
d68 1
d183 1
a183 1
	double freq;
d187 1
d195 1
a195 1
	while ((ch = getopt(argc, argv, "fG:ghi:lS:s:")) != -1)
d210 3
d242 6
a247 1
	if (stat(dsock, &statbuf) != 0) fatal("socket does not exist\n");
d252 1
a252 1
	warnx << "reading signatures from files...\n\n";
a253 1
		//std::cout << sigfiles[i] << "\n";
d257 1
a257 1
	warnx << "calculating frequencies...\n\n";
d260 2
a261 1
	system("date");
d264 1
a264 1
		warnx << "starting to listen...\n";
d266 1
a266 1
		warnx << "starting to gossip...\n";
d281 9
a289 2
			for (std::map<std::vector<POLY>, double >::iterator itr = uniqueSigList.begin();
			     itr != uniqueSigList.end(); itr++) {
d291 1
a291 16
				sig = itr->first;
				freq = itr->second / 2;
				sig2str(sig, buf);
				std::cout << "\ninserting:\n\ttxseq: " << txseq.back() << "\n\tsig: "
				      << buf << "\n\tfreq/2: " << freq << "\n";
				//makeKeyValue(&value, valLen, key, sig, freq, txseq.back(), GOSSIP);
				makeKeyValue(&value, valLen, key, uniqueSigList, txseq.back(), GOSSIP);
				status = insertDHT(ID, value, valLen, MAXRETRIES);
				cleanup(value);

				if (status != SUCC) fatal("insert FAILed\n");
				else warnx << "insert SUCCeeded\n";
				// should every sig message have a different seq?
				txseq.push_back(txseq.back() + 1);
			}
			warnx << "waiting " << intval << " seconds...\n\n";
d318 1
a318 1
	warnx << "insert operation on key: " << ID << "\n";
d351 5
a355 2
		double endTime = getgtod();    
		std::cerr << "key insert time: " << endTime - beginTime << " secs\n";
d483 1
a483 2
	//if (cs >= 0) warnx << "accepted connection. file descriptor = " << cs << "\n";
	else if (errno != EAGAIN) fatal << "\taccept; errno = " << errno << "\n";
d492 5
a496 5
	str key, t;
	std::vector<POLY> sig;
	std::vector<std::vector <POLY> > sigList;
	int n, s;
	double freq;
d499 1
a499 1
	if (n < 0) fatal("read failed\n");
d509 10
a518 1
	getKeyValue(gElem.cstr(), key, sig, freq, s);
d520 17
a536 3
	sig2str(sig, t);
	std::cout << "\nreading from socket:\n\trxseq: " << s << "\n\tID: " << key
	      << "\n\tsig: " << t << "\n\tfreq: " << freq << "\n";
d538 3
a540 5
	// what about freq?
	rxseq.push_back(s);
	sigList.clear();
	sigList.push_back(sig);
	calcfreq(sigList);
d608 1
a608 1
	std::cout << "Document signature: ";
a613 1
		std::cout << e << ".";
d615 3
a617 1
	std::cout << "\n";
d619 1
a619 1
	warnx << "Size of sig list: " << sigList.size() << "\n\n";
d713 1
a713 1
calcfreq(std::vector<std::vector <POLY> > sigList)
d715 1
a715 1
	str buf;
d719 1
a719 1
		sig2str(sigList[i], buf);
d722 1
d726 25
d755 35
a789 1
	warnx << "Size of unique sig list: " << uniqueSigList.size() << "\n\n";
d995 1
a995 1
	warn << "usage: " << __progname << " [-h] [-S dhash-sock] [-G g-sock] [-s sigdir] [-f | -l | -g [-i interval in sec]]\n";
@


1.3
log
@uses new makeKeyValue() and getKeyValue():
(type,sig,freq)
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.2 2009/08/07 18:27:56 vsfgd Exp vsfgd $	*/
d27 1
a27 1
//static char rcsid[] = "$Id: gpsi.C,v 1.2 2009/08/07 18:27:56 vsfgd Exp vsfgd $";
d37 4
a40 7
//void getKeyValue(str&, str&, double&, double&);
//void makeKeyValue(char **, int&, str&, double&, double&, InsertType);

//void getKeyValue(const char*, str&, std::vector<POLY>&);
void getKeyValue(const char*, str&, std::vector<POLY>&, int&);
//void makeKeyValue(char **, int&, str&, std::vector<POLY>&, InsertType);
void makeKeyValue(char **, int&, str&, std::vector<POLY>&, int&, InsertType);
d48 5
a52 5
int getdir(std::string, std::vector<std::string> &);
void readsig(std::string);
bool sig2str(std::vector<POLY>, str &);
void calcfreq(void);
void calcfreqO(void);
d64 3
a66 8
std::vector<std::vector<POLY> > sigList;
std::map<std::vector<POLY>, int, CompareSig> uniqueSigList;

//vec<double> sum;
//std::vector<double> sum;
//vec<double> weight;
//std::vector<double> weight;
//vec<long int> seq;
d178 2
a179 2
	double s, w;
	int ch, intval, fflag, Gflag, gflag, lflag, Sflag, sflag, valLen, freq;
d187 1
d242 1
a242 1
		readsig(sigfiles[i]);
d246 1
a246 1
	calcfreq();
d254 1
a254 9
		sleep(10);

		/*
		srand(time(NULL));
		sum.push_back(rand() % 100 + 1);
		weight.push_back(1);
		seq.push_back(0);
		warnx << "\ninitial value: ";
		*/
d256 3
d268 1
a268 1
			for (std::map<std::vector<POLY>, int >::iterator itr = uniqueSigList.begin();
a270 2
				sig2str(itr->first, buf);
				warnx << "\ninserting:\nsig: " << buf << "\nfreq: " << itr->second << "\n";
d272 6
a277 2
				freq = itr->second;
				makeKeyValue(&value, valLen, key, sig, freq, GOSSIP);
d283 2
a298 3
		str k;
		getKeyValue(nodeEntries[0], k, s, w);
		std::cout << "KEY: " << k << "\nVALUE (s, w): (" << s << ", " << w << ")\n";
d300 1
d474 1
a474 1
	if (cs >= 0) warnx << "\taccepted connection on local socket\n";
d485 5
a489 2
	str key;
	int n, freq;
d502 1
a502 3
	str t;
	std::vector<POLY> sig;
	getKeyValue(gElem.cstr(), key, sig, freq);
d505 2
a506 1
	warnx << "\tread from socket: KEY = " << key << ", VALUE = (" << t << ", " << freq << ")\n";
d508 5
a512 13
	// TODO: store sig freq

	/*
	if (sum.empty() || weight.empty()) {
		sum.push_back(s);
		weight.push_back(w);
		seq.push_back(1);
	} else {
		sum.push_back(sum.back() + s);
		weight.push_back(weight.back() + w);
		seq.push_back(seq.back() + 1);
	}
	*/
d536 1
a536 1
readsig(std::string sigfile)
d684 1
a684 1
calcfreq(void)
d689 1
a689 1
		std::map<std::vector<POLY>, int >::iterator itr = uniqueSigList.find(sigList[i]);
d693 1
a693 1
			warnx << "sig: " << buf << "\nfreq: " << itr->second << "\n";
d696 1
a696 1
			warnx << "sig: " << buf << "\nfreq: " << uniqueSigList[sigList[i]] << "\n";
d698 1
a698 1
		warnx << "Size of unique sig list: " << uniqueSigList.size() << "\n\n";
d700 1
d705 1
a705 1
calcfreqO(void)
@


1.2
log
@can read sigs from sig files in specified dir
save sigs to a vector of sigs
generate a unique sig list and calc freq of each sig
@
text
@d1 1
a1 1
/*	$Id: gpsi.C,v 1.1 2009/08/04 03:11:55 vsfgd Exp vsfgd $	*/
d27 1
a27 1
//static char rcsid[] = "$Id: gpsi.C,v 1.1 2009/08/04 03:11:55 vsfgd Exp vsfgd $";
d37 7
a43 3
//int pSim(std::vector<POLY>&, std::vector<POLY>&, std::vector<POLY>&, bool);
void getKeyValue(str&, str&, double&, double&);
void makeKeyValue(char **, int&, str&, double&, double&, InsertType);
d70 1
a70 1
vec<double> sum;
d72 1
a72 1
vec<double> weight;
d74 1
a74 1
vec<long int> seq;
d187 1
a187 1
	int ch, intval, fflag, Gflag, gflag, lflag, Sflag, sflag, valLen;
d246 1
d248 1
a248 1
		std::cout << sigfiles[i] << "\n";
d252 1
d262 2
d269 1
d276 14
d291 3
a293 13
			std::cout << "seq = " << seq.back() << ", s = " << sum.back()
				  << ", w = " << weight.back() << ", avg (s/w) = "
				  << sum.back()/weight.back() << "\n";
				  
			s = sum.back()/2;
			w = weight.back()/2;
			std::cout << "gossiping: (s/2, w/2) = (" << s << ", " << w << ")\n";
			makeKeyValue(&value, valLen, key, s, w, GOSSIP);
			status = insertDHT(ID, value, valLen, MAXRETRIES);
			cleanup(value);

			if (status != SUCC) fatal("insert FAILed\n");
			else warnx << "insert SUCCeeded\n";
a295 1
			warnx << "current value: ";
d495 2
a496 3
	str gKey;
	int n;
	double s, w;
d509 3
a511 1
	getKeyValue(gElem.cstr(), gKey, s, w);
d513 2
a514 1
	warnx << "\tread from socket: KEY = " << gKey << "\n";
d516 1
a516 2
	//std::cout << "read from socket: KEY = " << gKey << ", VALUE (s, w) = ("
	//	  << s << ", " << w << ")\n";
d518 1
d528 1
a528 1
	// check if sum and weight vecs have the same size?
d562 1
a562 1
	warnx << "opening sigfile: " << sigfile.c_str() << "...\n";
d604 1
a604 1
	std::cout << "\n\n";
d606 1
a606 1
	warnx << "Signature list size: " << sigList.size() << "\n\n";
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$Id$	*/
d5 1
d8 1
d24 2
a25 1
#define DEBUG 1
d27 1
a27 1
//static char rcsid[] = "$Id$";
d34 1
a34 1
static const char* dhash_sock;
a35 2
static const char* logfile;
std::ofstream LogFile;
d37 1
d47 5
d55 1
d63 3
d78 3
d183 1
a183 2
	int ch, intval, fflag, Gflag, gflag, Lflag, lflag, Sflag, sflag, valLen;
	int count, maxcount;
d189 2
a190 3
	std::string sigfile, tagsfile;
	FILE *sigfp;
	FILE *tagsfp;
d192 2
a193 4
	fflag = Gflag = gflag = Lflag = lflag = Sflag = sflag = intval = 0;
	// FIXME: add maxcount arg?
	count = maxcount = 1;
	while ((ch = getopt(argc, argv, "fG:ghi:L:lS:s:")) != -1)
a207 4
		case 'L':
			Lflag = 1;
			logfile = optarg;
			break;
d213 1
a213 1
			dhash_sock = optarg;
d217 1
a217 1
			sigfile = optarg;
d229 1
a229 1
	if (Gflag == 0 || Sflag == 0 || Lflag == 0 || sflag == 0) usage();
d237 2
a238 2
	// check
	LogFile.open(logfile);
d240 6
a245 8
	// open signatures
	sigfp = fopen(sigfile.c_str(), "r");
	assert(sigfp);

	// open tags
	tagsfile = sigfile + std::string(TAGFILE);
	tagsfp = fopen(tagsfile.c_str(), "r");
	assert(tagsfp);
d247 1
a247 2
	if (stat(dhash_sock, &statbuf) != 0) fatal("socket does not exist\n");
	dhash = New dhashclient(dhash_sock);
d517 387
d907 1
a907 1
	warn << "usage: " << __progname << " [-h] [-S dhash-sock] [-G g-sock] [-L logfile] [-s sigfile] [-f | -l | -g [-i interval in sec]]\n";
@
